import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField
} from "./chunk-SNAQBZPT.js";

// node_modules/pdfjs-dist/build/pdf.min.mjs
var t = !("object" != typeof process || process + "" != "[object process]" || process.versions.nw || process.versions.electron && process.type && "browser" !== process.type);
var e = [1e-3, 0, 0, 1e-3, 0, 0];
var i = 1.35;
var s = 1;
var n = 2;
var a = 4;
var r = 16;
var o = 32;
var l = 64;
var h = 128;
var d = 256;
var c = { DISABLE: 0, ENABLE: 1, ENABLE_FORMS: 2, ENABLE_STORAGE: 3 };
var u = { DISABLE: -1, NONE: 0, FREETEXT: 3, HIGHLIGHT: 9, STAMP: 13, INK: 15, SIGNATURE: 101 };
var p = { RESIZE: 1, CREATE: 2, FREETEXT_SIZE: 11, FREETEXT_COLOR: 12, FREETEXT_OPACITY: 13, INK_COLOR: 21, INK_THICKNESS: 22, INK_OPACITY: 23, HIGHLIGHT_COLOR: 31, HIGHLIGHT_DEFAULT_COLOR: 32, HIGHLIGHT_THICKNESS: 33, HIGHLIGHT_FREE: 34, HIGHLIGHT_SHOW_ALL: 35, DRAW_STEP: 41 };
var g = { PRINT: 4, MODIFY_CONTENTS: 8, COPY: 16, MODIFY_ANNOTATIONS: 32, FILL_INTERACTIVE_FORMS: 256, COPY_FOR_ACCESSIBILITY: 512, ASSEMBLE: 1024, PRINT_HIGH_QUALITY: 2048 };
var f = 0;
var m = 1;
var b = 2;
var A = 3;
var w = 3;
var y = 4;
var v = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 };
var x = { TEXT: 1, LINK: 2, FREETEXT: 3, LINE: 4, SQUARE: 5, CIRCLE: 6, POLYGON: 7, POLYLINE: 8, HIGHLIGHT: 9, UNDERLINE: 10, SQUIGGLY: 11, STRIKEOUT: 12, STAMP: 13, CARET: 14, INK: 15, POPUP: 16, FILEATTACHMENT: 17, SOUND: 18, MOVIE: 19, WIDGET: 20, SCREEN: 21, PRINTERMARK: 22, TRAPNET: 23, WATERMARK: 24, THREED: 25, REDACT: 26 };
var E = 1;
var _ = 2;
var S = 3;
var C = 4;
var T = 5;
var M = { ERRORS: 0, WARNINGS: 1, INFOS: 5 };
var D = { dependency: 1, setLineWidth: 2, setLineCap: 3, setLineJoin: 4, setMiterLimit: 5, setDash: 6, setRenderingIntent: 7, setFlatness: 8, setGState: 9, save: 10, restore: 11, transform: 12, moveTo: 13, lineTo: 14, curveTo: 15, curveTo2: 16, curveTo3: 17, closePath: 18, rectangle: 19, stroke: 20, closeStroke: 21, fill: 22, eoFill: 23, fillStroke: 24, eoFillStroke: 25, closeFillStroke: 26, closeEOFillStroke: 27, endPath: 28, clip: 29, eoClip: 30, beginText: 31, endText: 32, setCharSpacing: 33, setWordSpacing: 34, setHScale: 35, setLeading: 36, setFont: 37, setTextRenderingMode: 38, setTextRise: 39, moveText: 40, setLeadingMoveText: 41, setTextMatrix: 42, nextLine: 43, showText: 44, showSpacedText: 45, nextLineShowText: 46, nextLineSetSpacingShowText: 47, setCharWidth: 48, setCharWidthAndBounds: 49, setStrokeColorSpace: 50, setFillColorSpace: 51, setStrokeColor: 52, setStrokeColorN: 53, setFillColor: 54, setFillColorN: 55, setStrokeGray: 56, setFillGray: 57, setStrokeRGBColor: 58, setFillRGBColor: 59, setStrokeCMYKColor: 60, setFillCMYKColor: 61, shadingFill: 62, beginInlineImage: 63, beginImageData: 64, endInlineImage: 65, paintXObject: 66, markPoint: 67, markPointProps: 68, beginMarkedContent: 69, beginMarkedContentProps: 70, endMarkedContent: 71, beginCompat: 72, endCompat: 73, paintFormXObjectBegin: 74, paintFormXObjectEnd: 75, beginGroup: 76, endGroup: 77, beginAnnotation: 80, endAnnotation: 81, paintImageMaskXObject: 83, paintImageMaskXObjectGroup: 84, paintImageXObject: 85, paintInlineImageXObject: 86, paintInlineImageXObjectGroup: 87, paintImageXObjectRepeat: 88, paintImageMaskXObjectRepeat: 89, paintSolidColorImageMask: 90, constructPath: 91, setStrokeTransparent: 92, setFillTransparent: 93, rawFillPath: 94 };
var P = 0;
var k = 1;
var I = 2;
var R = 3;
var F = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 };
var L = M.WARNINGS;
function setVerbosityLevel(t2) {
  Number.isInteger(t2) && (L = t2);
}
function getVerbosityLevel() {
  return L;
}
function info(t2) {
  L >= M.INFOS && console.log(`Info: ${t2}`);
}
function warn(t2) {
  L >= M.WARNINGS && console.log(`Warning: ${t2}`);
}
function unreachable(t2) {
  throw new Error(t2);
}
function assert(t2, e2) {
  t2 || unreachable(e2);
}
function createValidAbsoluteUrl(t2, e2 = null, i2 = null) {
  if (!t2) return null;
  if (i2 && "string" == typeof t2) {
    if (i2.addDefaultProtocol && t2.startsWith("www.")) {
      const e3 = t2.match(/\./g);
      (e3 == null ? void 0 : e3.length) >= 2 && (t2 = `http://${t2}`);
    }
    if (i2.tryConvertEncoding) try {
      t2 = function stringToUTF8String(t3) {
        return decodeURIComponent(escape(t3));
      }(t2);
    } catch {
    }
  }
  const s2 = e2 ? URL.parse(t2, e2) : URL.parse(t2);
  return function _isValidProtocol(t3) {
    switch (t3 == null ? void 0 : t3.protocol) {
      case "http:":
      case "https:":
      case "ftp:":
      case "mailto:":
      case "tel:":
        return true;
      default:
        return false;
    }
  }(s2) ? s2 : null;
}
function updateUrlHash(t2, e2, i2 = false) {
  const s2 = URL.parse(t2);
  if (s2) {
    s2.hash = e2;
    return s2.href;
  }
  return i2 && createValidAbsoluteUrl(t2, "http://example.com") ? t2.split("#", 1)[0] + (e2 ? `#${e2}` : "") : "";
}
function shadow(t2, e2, i2, s2 = false) {
  Object.defineProperty(t2, e2, { value: i2, enumerable: !s2, configurable: true, writable: false });
  return i2;
}
var O = function BaseExceptionClosure() {
  function BaseException(t2, e2) {
    this.message = t2;
    this.name = e2;
  }
  BaseException.prototype = new Error();
  BaseException.constructor = BaseException;
  return BaseException;
}();
var PasswordException = class extends O {
  constructor(t2, e2) {
    super(t2, "PasswordException");
    this.code = e2;
  }
};
var UnknownErrorException = class extends O {
  constructor(t2, e2) {
    super(t2, "UnknownErrorException");
    this.details = e2;
  }
};
var InvalidPDFException = class extends O {
  constructor(t2) {
    super(t2, "InvalidPDFException");
  }
};
var ResponseException = class extends O {
  constructor(t2, e2, i2) {
    super(t2, "ResponseException");
    this.status = e2;
    this.missing = i2;
  }
};
var FormatError = class extends O {
  constructor(t2) {
    super(t2, "FormatError");
  }
};
var AbortException = class extends O {
  constructor(t2) {
    super(t2, "AbortException");
  }
};
function bytesToString(t2) {
  "object" == typeof t2 && void 0 !== (t2 == null ? void 0 : t2.length) || unreachable("Invalid argument for bytesToString");
  const e2 = t2.length, i2 = 8192;
  if (e2 < i2) return String.fromCharCode.apply(null, t2);
  const s2 = [];
  for (let n2 = 0; n2 < e2; n2 += i2) {
    const a2 = Math.min(n2 + i2, e2), r2 = t2.subarray(n2, a2);
    s2.push(String.fromCharCode.apply(null, r2));
  }
  return s2.join("");
}
function stringToBytes(t2) {
  "string" != typeof t2 && unreachable("Invalid argument for stringToBytes");
  const e2 = t2.length, i2 = new Uint8Array(e2);
  for (let s2 = 0; s2 < e2; ++s2) i2[s2] = 255 & t2.charCodeAt(s2);
  return i2;
}
var util_FeatureTest = class {
  static get isLittleEndian() {
    return shadow(this, "isLittleEndian", function isLittleEndian() {
      const t2 = new Uint8Array(4);
      t2[0] = 1;
      return 1 === new Uint32Array(t2.buffer, 0, 1)[0];
    }());
  }
  static get isEvalSupported() {
    return shadow(this, "isEvalSupported", function isEvalSupported() {
      try {
        new Function("");
        return true;
      } catch {
        return false;
      }
    }());
  }
  static get isOffscreenCanvasSupported() {
    return shadow(this, "isOffscreenCanvasSupported", "undefined" != typeof OffscreenCanvas);
  }
  static get isImageDecoderSupported() {
    return shadow(this, "isImageDecoderSupported", "undefined" != typeof ImageDecoder);
  }
  static get platform() {
    const { platform: t2, userAgent: e2 } = navigator;
    return shadow(this, "platform", { isAndroid: e2.includes("Android"), isLinux: t2.includes("Linux"), isMac: t2.includes("Mac"), isWindows: t2.includes("Win"), isFirefox: e2.includes("Firefox") });
  }
  static get isCSSRoundSupported() {
    var _a5, _b;
    return shadow(this, "isCSSRoundSupported", (_b = (_a5 = globalThis.CSS) == null ? void 0 : _a5.supports) == null ? void 0 : _b.call(_a5, "width: round(1.5px, 1px)"));
  }
};
var N = Array.from(Array(256).keys(), (t2) => t2.toString(16).padStart(2, "0"));
var _Util_static, t_fn, e_fn;
var Util = class {
  static makeHexColor(t2, e2, i2) {
    return `#${N[t2]}${N[e2]}${N[i2]}`;
  }
  static scaleMinMax(t2, e2) {
    let i2;
    if (t2[0]) {
      if (t2[0] < 0) {
        i2 = e2[0];
        e2[0] = e2[2];
        e2[2] = i2;
      }
      e2[0] *= t2[0];
      e2[2] *= t2[0];
      if (t2[3] < 0) {
        i2 = e2[1];
        e2[1] = e2[3];
        e2[3] = i2;
      }
      e2[1] *= t2[3];
      e2[3] *= t2[3];
    } else {
      i2 = e2[0];
      e2[0] = e2[1];
      e2[1] = i2;
      i2 = e2[2];
      e2[2] = e2[3];
      e2[3] = i2;
      if (t2[1] < 0) {
        i2 = e2[1];
        e2[1] = e2[3];
        e2[3] = i2;
      }
      e2[1] *= t2[1];
      e2[3] *= t2[1];
      if (t2[2] < 0) {
        i2 = e2[0];
        e2[0] = e2[2];
        e2[2] = i2;
      }
      e2[0] *= t2[2];
      e2[2] *= t2[2];
    }
    e2[0] += t2[4];
    e2[1] += t2[5];
    e2[2] += t2[4];
    e2[3] += t2[5];
  }
  static transform(t2, e2) {
    return [t2[0] * e2[0] + t2[2] * e2[1], t2[1] * e2[0] + t2[3] * e2[1], t2[0] * e2[2] + t2[2] * e2[3], t2[1] * e2[2] + t2[3] * e2[3], t2[0] * e2[4] + t2[2] * e2[5] + t2[4], t2[1] * e2[4] + t2[3] * e2[5] + t2[5]];
  }
  static applyTransform(t2, e2, i2 = 0) {
    const s2 = t2[i2], n2 = t2[i2 + 1];
    t2[i2] = s2 * e2[0] + n2 * e2[2] + e2[4];
    t2[i2 + 1] = s2 * e2[1] + n2 * e2[3] + e2[5];
  }
  static applyTransformToBezier(t2, e2, i2 = 0) {
    const s2 = e2[0], n2 = e2[1], a2 = e2[2], r2 = e2[3], o2 = e2[4], l2 = e2[5];
    for (let e3 = 0; e3 < 6; e3 += 2) {
      const h2 = t2[i2 + e3], d2 = t2[i2 + e3 + 1];
      t2[i2 + e3] = h2 * s2 + d2 * a2 + o2;
      t2[i2 + e3 + 1] = h2 * n2 + d2 * r2 + l2;
    }
  }
  static applyInverseTransform(t2, e2) {
    const i2 = t2[0], s2 = t2[1], n2 = e2[0] * e2[3] - e2[1] * e2[2];
    t2[0] = (i2 * e2[3] - s2 * e2[2] + e2[2] * e2[5] - e2[4] * e2[3]) / n2;
    t2[1] = (-i2 * e2[1] + s2 * e2[0] + e2[4] * e2[1] - e2[5] * e2[0]) / n2;
  }
  static axialAlignedBoundingBox(t2, e2, i2) {
    const s2 = e2[0], n2 = e2[1], a2 = e2[2], r2 = e2[3], o2 = e2[4], l2 = e2[5], h2 = t2[0], d2 = t2[1], c2 = t2[2], u2 = t2[3];
    let p2 = s2 * h2 + o2, g2 = p2, f2 = s2 * c2 + o2, m2 = f2, b2 = r2 * d2 + l2, A2 = b2, w2 = r2 * u2 + l2, y2 = w2;
    if (0 !== n2 || 0 !== a2) {
      const t3 = n2 * h2, e3 = n2 * c2, i3 = a2 * d2, s3 = a2 * u2;
      p2 += i3;
      m2 += i3;
      f2 += s3;
      g2 += s3;
      b2 += t3;
      y2 += t3;
      w2 += e3;
      A2 += e3;
    }
    i2[0] = Math.min(i2[0], p2, f2, g2, m2);
    i2[1] = Math.min(i2[1], b2, w2, A2, y2);
    i2[2] = Math.max(i2[2], p2, f2, g2, m2);
    i2[3] = Math.max(i2[3], b2, w2, A2, y2);
  }
  static inverseTransform(t2) {
    const e2 = t2[0] * t2[3] - t2[1] * t2[2];
    return [t2[3] / e2, -t2[1] / e2, -t2[2] / e2, t2[0] / e2, (t2[2] * t2[5] - t2[4] * t2[3]) / e2, (t2[4] * t2[1] - t2[5] * t2[0]) / e2];
  }
  static singularValueDecompose2dScale(t2, e2) {
    const i2 = t2[0], s2 = t2[1], n2 = t2[2], a2 = t2[3], r2 = i2 ** 2 + s2 ** 2, o2 = i2 * n2 + s2 * a2, l2 = n2 ** 2 + a2 ** 2, h2 = (r2 + l2) / 2, d2 = Math.sqrt(h2 ** 2 - (r2 * l2 - o2 ** 2));
    e2[0] = Math.sqrt(h2 + d2 || 1);
    e2[1] = Math.sqrt(h2 - d2 || 1);
  }
  static normalizeRect(t2) {
    const e2 = t2.slice(0);
    if (t2[0] > t2[2]) {
      e2[0] = t2[2];
      e2[2] = t2[0];
    }
    if (t2[1] > t2[3]) {
      e2[1] = t2[3];
      e2[3] = t2[1];
    }
    return e2;
  }
  static intersect(t2, e2) {
    const i2 = Math.max(Math.min(t2[0], t2[2]), Math.min(e2[0], e2[2])), s2 = Math.min(Math.max(t2[0], t2[2]), Math.max(e2[0], e2[2]));
    if (i2 > s2) return null;
    const n2 = Math.max(Math.min(t2[1], t2[3]), Math.min(e2[1], e2[3])), a2 = Math.min(Math.max(t2[1], t2[3]), Math.max(e2[1], e2[3]));
    return n2 > a2 ? null : [i2, n2, s2, a2];
  }
  static pointBoundingBox(t2, e2, i2) {
    i2[0] = Math.min(i2[0], t2);
    i2[1] = Math.min(i2[1], e2);
    i2[2] = Math.max(i2[2], t2);
    i2[3] = Math.max(i2[3], e2);
  }
  static rectBoundingBox(t2, e2, i2, s2, n2) {
    n2[0] = Math.min(n2[0], t2, i2);
    n2[1] = Math.min(n2[1], e2, s2);
    n2[2] = Math.max(n2[2], t2, i2);
    n2[3] = Math.max(n2[3], e2, s2);
  }
  static bezierBoundingBox(t2, e2, i2, s2, n2, a2, r2, o2, l2) {
    l2[0] = Math.min(l2[0], t2, r2);
    l2[1] = Math.min(l2[1], e2, o2);
    l2[2] = Math.max(l2[2], t2, r2);
    l2[3] = Math.max(l2[3], e2, o2);
    __privateMethod(this, _Util_static, e_fn).call(this, t2, i2, n2, r2, e2, s2, a2, o2, 3 * (3 * (i2 - n2) - t2 + r2), 6 * (t2 - 2 * i2 + n2), 3 * (i2 - t2), l2);
    __privateMethod(this, _Util_static, e_fn).call(this, t2, i2, n2, r2, e2, s2, a2, o2, 3 * (3 * (s2 - a2) - e2 + o2), 6 * (e2 - 2 * s2 + a2), 3 * (s2 - e2), l2);
  }
};
_Util_static = new WeakSet();
t_fn = function(t2, e2, i2, s2, n2, a2, r2, o2, l2, h2) {
  if (l2 <= 0 || l2 >= 1) return;
  const d2 = 1 - l2, c2 = l2 * l2, u2 = c2 * l2, p2 = d2 * (d2 * (d2 * t2 + 3 * l2 * e2) + 3 * c2 * i2) + u2 * s2, g2 = d2 * (d2 * (d2 * n2 + 3 * l2 * a2) + 3 * c2 * r2) + u2 * o2;
  h2[0] = Math.min(h2[0], p2);
  h2[1] = Math.min(h2[1], g2);
  h2[2] = Math.max(h2[2], p2);
  h2[3] = Math.max(h2[3], g2);
};
e_fn = function(t2, e2, i2, s2, n2, a2, r2, o2, l2, h2, d2, c2) {
  if (Math.abs(l2) < 1e-12) {
    Math.abs(h2) >= 1e-12 && __privateMethod(this, _Util_static, t_fn).call(this, t2, e2, i2, s2, n2, a2, r2, o2, -d2 / h2, c2);
    return;
  }
  const u2 = h2 ** 2 - 4 * d2 * l2;
  if (u2 < 0) return;
  const p2 = Math.sqrt(u2), g2 = 2 * l2;
  __privateMethod(this, _Util_static, t_fn).call(this, t2, e2, i2, s2, n2, a2, r2, o2, (-h2 + p2) / g2, c2);
  __privateMethod(this, _Util_static, t_fn).call(this, t2, e2, i2, s2, n2, a2, r2, o2, (-h2 - p2) / g2, c2);
};
__privateAdd(Util, _Util_static);
var B = null;
var H = null;
function normalizeUnicode(t2) {
  if (!B) {
    B = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
    H = /* @__PURE__ */ new Map([["ﬅ", "ſt"]]);
  }
  return t2.replaceAll(B, (t3, e2, i2) => e2 ? e2.normalize("NFKC") : H.get(i2));
}
function getUuid() {
  if ("function" == typeof crypto.randomUUID) return crypto.randomUUID();
  const t2 = new Uint8Array(32);
  crypto.getRandomValues(t2);
  return bytesToString(t2);
}
var U = "pdfjs_internal_id_";
function MathClamp(t2, e2, i2) {
  return Math.min(Math.max(t2, e2), i2);
}
function toBase64Util(t2) {
  return Uint8Array.prototype.toBase64 ? t2.toBase64() : btoa(bytesToString(t2));
}
"function" != typeof Promise.try && (Promise.try = function(t2, ...e2) {
  return new Promise((i2) => {
    i2(t2(...e2));
  });
});
"function" != typeof Math.sumPrecise && (Math.sumPrecise = function(t2) {
  return t2.reduce((t3, e2) => t3 + e2, 0);
});
var z = "http://www.w3.org/2000/svg";
var _PixelsPerInch = class _PixelsPerInch {
};
__publicField(_PixelsPerInch, "CSS", 96);
__publicField(_PixelsPerInch, "PDF", 72);
__publicField(_PixelsPerInch, "PDF_TO_CSS_UNITS", _PixelsPerInch.CSS / _PixelsPerInch.PDF);
var PixelsPerInch = _PixelsPerInch;
async function fetchData(t2, e2 = "text") {
  if (isValidFetchUrl(t2, document.baseURI)) {
    const i2 = await fetch(t2);
    if (!i2.ok) throw new Error(i2.statusText);
    switch (e2) {
      case "arraybuffer":
        return i2.arrayBuffer();
      case "blob":
        return i2.blob();
      case "json":
        return i2.json();
    }
    return i2.text();
  }
  return new Promise((i2, s2) => {
    const n2 = new XMLHttpRequest();
    n2.open("GET", t2, true);
    n2.responseType = e2;
    n2.onreadystatechange = () => {
      if (n2.readyState === XMLHttpRequest.DONE) if (200 !== n2.status && 0 !== n2.status) s2(new Error(n2.statusText));
      else {
        switch (e2) {
          case "arraybuffer":
          case "blob":
          case "json":
            i2(n2.response);
            return;
        }
        i2(n2.responseText);
      }
    };
    n2.send(null);
  });
}
var PageViewport = class _PageViewport {
  constructor({ viewBox: t2, userUnit: e2, scale: i2, rotation: s2, offsetX: n2 = 0, offsetY: a2 = 0, dontFlip: r2 = false }) {
    this.viewBox = t2;
    this.userUnit = e2;
    this.scale = i2;
    this.rotation = s2;
    this.offsetX = n2;
    this.offsetY = a2;
    i2 *= e2;
    const o2 = (t2[2] + t2[0]) / 2, l2 = (t2[3] + t2[1]) / 2;
    let h2, d2, c2, u2, p2, g2, f2, m2;
    (s2 %= 360) < 0 && (s2 += 360);
    switch (s2) {
      case 180:
        h2 = -1;
        d2 = 0;
        c2 = 0;
        u2 = 1;
        break;
      case 90:
        h2 = 0;
        d2 = 1;
        c2 = 1;
        u2 = 0;
        break;
      case 270:
        h2 = 0;
        d2 = -1;
        c2 = -1;
        u2 = 0;
        break;
      case 0:
        h2 = 1;
        d2 = 0;
        c2 = 0;
        u2 = -1;
        break;
      default:
        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
    }
    if (r2) {
      c2 = -c2;
      u2 = -u2;
    }
    if (0 === h2) {
      p2 = Math.abs(l2 - t2[1]) * i2 + n2;
      g2 = Math.abs(o2 - t2[0]) * i2 + a2;
      f2 = (t2[3] - t2[1]) * i2;
      m2 = (t2[2] - t2[0]) * i2;
    } else {
      p2 = Math.abs(o2 - t2[0]) * i2 + n2;
      g2 = Math.abs(l2 - t2[1]) * i2 + a2;
      f2 = (t2[2] - t2[0]) * i2;
      m2 = (t2[3] - t2[1]) * i2;
    }
    this.transform = [h2 * i2, d2 * i2, c2 * i2, u2 * i2, p2 - h2 * i2 * o2 - c2 * i2 * l2, g2 - d2 * i2 * o2 - u2 * i2 * l2];
    this.width = f2;
    this.height = m2;
  }
  get rawDims() {
    const t2 = this.viewBox;
    return shadow(this, "rawDims", { pageWidth: t2[2] - t2[0], pageHeight: t2[3] - t2[1], pageX: t2[0], pageY: t2[1] });
  }
  clone({ scale: t2 = this.scale, rotation: e2 = this.rotation, offsetX: i2 = this.offsetX, offsetY: s2 = this.offsetY, dontFlip: n2 = false } = {}) {
    return new _PageViewport({ viewBox: this.viewBox.slice(), userUnit: this.userUnit, scale: t2, rotation: e2, offsetX: i2, offsetY: s2, dontFlip: n2 });
  }
  convertToViewportPoint(t2, e2) {
    const i2 = [t2, e2];
    Util.applyTransform(i2, this.transform);
    return i2;
  }
  convertToViewportRectangle(t2) {
    const e2 = [t2[0], t2[1]];
    Util.applyTransform(e2, this.transform);
    const i2 = [t2[2], t2[3]];
    Util.applyTransform(i2, this.transform);
    return [e2[0], e2[1], i2[0], i2[1]];
  }
  convertToPdfPoint(t2, e2) {
    const i2 = [t2, e2];
    Util.applyInverseTransform(i2, this.transform);
    return i2;
  }
};
var RenderingCancelledException = class extends O {
  constructor(t2, e2 = 0) {
    super(t2, "RenderingCancelledException");
    this.extraDelay = e2;
  }
};
function isDataScheme(t2) {
  const e2 = t2.length;
  let i2 = 0;
  for (; i2 < e2 && "" === t2[i2].trim(); ) i2++;
  return "data:" === t2.substring(i2, i2 + 5).toLowerCase();
}
function isPdfFile(t2) {
  return "string" == typeof t2 && /\.pdf$/i.test(t2);
}
function getFilenameFromUrl(t2) {
  [t2] = t2.split(/[#?]/, 1);
  return t2.substring(t2.lastIndexOf("/") + 1);
}
function getPdfFilenameFromUrl(t2, e2 = "document.pdf") {
  if ("string" != typeof t2) return e2;
  if (isDataScheme(t2)) {
    warn('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
    return e2;
  }
  const i2 = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, s2 = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/.exec(t2);
  let n2 = i2.exec(s2[1]) || i2.exec(s2[2]) || i2.exec(s2[3]);
  if (n2) {
    n2 = n2[0];
    if (n2.includes("%")) try {
      n2 = i2.exec(decodeURIComponent(n2))[0];
    } catch {
    }
  }
  return n2 || e2;
}
var StatTimer = class {
  constructor() {
    __publicField(this, "started", /* @__PURE__ */ Object.create(null));
    __publicField(this, "times", []);
  }
  time(t2) {
    t2 in this.started && warn(`Timer is already running for ${t2}`);
    this.started[t2] = Date.now();
  }
  timeEnd(t2) {
    t2 in this.started || warn(`Timer has not been started for ${t2}`);
    this.times.push({ name: t2, start: this.started[t2], end: Date.now() });
    delete this.started[t2];
  }
  toString() {
    const t2 = [];
    let e2 = 0;
    for (const { name: t3 } of this.times) e2 = Math.max(t3.length, e2);
    for (const { name: i2, start: s2, end: n2 } of this.times) t2.push(`${i2.padEnd(e2)} ${n2 - s2}ms
`);
    return t2.join("");
  }
};
function isValidFetchUrl(t2, e2) {
  const i2 = e2 ? URL.parse(t2, e2) : URL.parse(t2);
  return "http:" === (i2 == null ? void 0 : i2.protocol) || "https:" === (i2 == null ? void 0 : i2.protocol);
}
function noContextMenu(t2) {
  t2.preventDefault();
}
function stopEvent(t2) {
  t2.preventDefault();
  t2.stopPropagation();
}
var _i;
var PDFDateString = class {
  static toDateObject(t2) {
    if (!t2 || "string" != typeof t2) return null;
    __privateGet(this, _i) || __privateSet(this, _i, new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
    const e2 = __privateGet(this, _i).exec(t2);
    if (!e2) return null;
    const i2 = parseInt(e2[1], 10);
    let s2 = parseInt(e2[2], 10);
    s2 = s2 >= 1 && s2 <= 12 ? s2 - 1 : 0;
    let n2 = parseInt(e2[3], 10);
    n2 = n2 >= 1 && n2 <= 31 ? n2 : 1;
    let a2 = parseInt(e2[4], 10);
    a2 = a2 >= 0 && a2 <= 23 ? a2 : 0;
    let r2 = parseInt(e2[5], 10);
    r2 = r2 >= 0 && r2 <= 59 ? r2 : 0;
    let o2 = parseInt(e2[6], 10);
    o2 = o2 >= 0 && o2 <= 59 ? o2 : 0;
    const l2 = e2[7] || "Z";
    let h2 = parseInt(e2[8], 10);
    h2 = h2 >= 0 && h2 <= 23 ? h2 : 0;
    let d2 = parseInt(e2[9], 10) || 0;
    d2 = d2 >= 0 && d2 <= 59 ? d2 : 0;
    if ("-" === l2) {
      a2 += h2;
      r2 += d2;
    } else if ("+" === l2) {
      a2 -= h2;
      r2 -= d2;
    }
    return new Date(Date.UTC(i2, s2, n2, a2, r2, o2));
  }
};
_i = new WeakMap();
__privateAdd(PDFDateString, _i);
function getXfaPageViewport(t2, { scale: e2 = 1, rotation: i2 = 0 }) {
  const { width: s2, height: n2 } = t2.attributes.style, a2 = [0, 0, parseInt(s2), parseInt(n2)];
  return new PageViewport({ viewBox: a2, userUnit: 1, scale: e2, rotation: i2 });
}
function getRGB(t2) {
  if (t2.startsWith("#")) {
    const e2 = parseInt(t2.slice(1), 16);
    return [(16711680 & e2) >> 16, (65280 & e2) >> 8, 255 & e2];
  }
  if (t2.startsWith("rgb(")) return t2.slice(4, -1).split(",").map((t3) => parseInt(t3));
  if (t2.startsWith("rgba(")) return t2.slice(5, -1).split(",").map((t3) => parseInt(t3)).slice(0, 3);
  warn(`Not a valid color format: "${t2}"`);
  return [0, 0, 0];
}
function getCurrentTransform(t2) {
  const { a: e2, b: i2, c: s2, d: n2, e: a2, f: r2 } = t2.getTransform();
  return [e2, i2, s2, n2, a2, r2];
}
function getCurrentTransformInverse(t2) {
  const { a: e2, b: i2, c: s2, d: n2, e: a2, f: r2 } = t2.getTransform().invertSelf();
  return [e2, i2, s2, n2, a2, r2];
}
function setLayerDimensions(t2, e2, i2 = false, s2 = true) {
  if (e2 instanceof PageViewport) {
    const { pageWidth: s3, pageHeight: n2 } = e2.rawDims, { style: a2 } = t2, r2 = util_FeatureTest.isCSSRoundSupported, o2 = `var(--total-scale-factor) * ${s3}px`, l2 = `var(--total-scale-factor) * ${n2}px`, h2 = r2 ? `round(down, ${o2}, var(--scale-round-x))` : `calc(${o2})`, d2 = r2 ? `round(down, ${l2}, var(--scale-round-y))` : `calc(${l2})`;
    if (i2 && e2.rotation % 180 != 0) {
      a2.width = d2;
      a2.height = h2;
    } else {
      a2.width = h2;
      a2.height = d2;
    }
  }
  s2 && t2.setAttribute("data-main-rotation", e2.rotation);
}
var OutputScale = class _OutputScale {
  constructor() {
    const { pixelRatio: t2 } = _OutputScale;
    this.sx = t2;
    this.sy = t2;
  }
  get scaled() {
    return 1 !== this.sx || 1 !== this.sy;
  }
  get symmetric() {
    return this.sx === this.sy;
  }
  limitCanvas(t2, e2, i2, s2, n2 = -1) {
    let a2 = 1 / 0, r2 = 1 / 0, o2 = 1 / 0;
    (i2 = _OutputScale.capPixels(i2, n2)) > 0 && (a2 = Math.sqrt(i2 / (t2 * e2)));
    if (-1 !== s2) {
      r2 = s2 / t2;
      o2 = s2 / e2;
    }
    const l2 = Math.min(a2, r2, o2);
    if (this.sx > l2 || this.sy > l2) {
      this.sx = l2;
      this.sy = l2;
      return true;
    }
    return false;
  }
  static get pixelRatio() {
    return globalThis.devicePixelRatio || 1;
  }
  static capPixels(t2, e2) {
    if (e2 >= 0) {
      const i2 = Math.ceil(window.screen.availWidth * window.screen.availHeight * this.pixelRatio ** 2 * (1 + e2 / 100));
      return t2 > 0 ? Math.min(t2, i2) : i2;
    }
    return t2;
  }
};
var G = ["image/apng", "image/avif", "image/bmp", "image/gif", "image/jpeg", "image/png", "image/svg+xml", "image/webp", "image/x-icon"];
var _s, _n, _a, _r, _o, _l, _h, _EditorToolbar_static, d_fn, _EditorToolbar_instances, u_fn, p_fn, g_fn, c_fn, f_get;
var _EditorToolbar = class _EditorToolbar {
  constructor(t2) {
    __privateAdd(this, _EditorToolbar_instances);
    __privateAdd(this, _s, null);
    __privateAdd(this, _n, null);
    __privateAdd(this, _a);
    __privateAdd(this, _r, null);
    __privateAdd(this, _o, null);
    __privateAdd(this, _l, null);
    __privateSet(this, _a, t2);
    __privateGet(_EditorToolbar, _h) || __privateSet(_EditorToolbar, _h, Object.freeze({ freetext: "pdfjs-editor-remove-freetext-button", highlight: "pdfjs-editor-remove-highlight-button", ink: "pdfjs-editor-remove-ink-button", stamp: "pdfjs-editor-remove-stamp-button", signature: "pdfjs-editor-remove-signature-button" }));
  }
  render() {
    const t2 = __privateSet(this, _s, document.createElement("div"));
    t2.classList.add("editToolbar", "hidden");
    t2.setAttribute("role", "toolbar");
    const e2 = __privateGet(this, _a)._uiManager._signal;
    t2.addEventListener("contextmenu", noContextMenu, { signal: e2 });
    t2.addEventListener("pointerdown", __privateMethod(_EditorToolbar, _EditorToolbar_static, d_fn), { signal: e2 });
    const i2 = __privateSet(this, _r, document.createElement("div"));
    i2.className = "buttons";
    t2.append(i2);
    const s2 = __privateGet(this, _a).toolbarPosition;
    if (s2) {
      const { style: e3 } = t2, i3 = "ltr" === __privateGet(this, _a)._uiManager.direction ? 1 - s2[0] : s2[0];
      e3.insetInlineEnd = 100 * i3 + "%";
      e3.top = `calc(${100 * s2[1]}% + var(--editor-toolbar-vert-offset))`;
    }
    __privateMethod(this, _EditorToolbar_instances, c_fn).call(this);
    return t2;
  }
  get div() {
    return __privateGet(this, _s);
  }
  hide() {
    var _a5;
    __privateGet(this, _s).classList.add("hidden");
    (_a5 = __privateGet(this, _n)) == null ? void 0 : _a5.hideDropdown();
  }
  show() {
    var _a5;
    __privateGet(this, _s).classList.remove("hidden");
    (_a5 = __privateGet(this, _o)) == null ? void 0 : _a5.shown();
  }
  async addAltText(t2) {
    const e2 = await t2.render();
    __privateMethod(this, _EditorToolbar_instances, g_fn).call(this, e2);
    __privateGet(this, _r).prepend(e2, __privateGet(this, _EditorToolbar_instances, f_get));
    __privateSet(this, _o, t2);
  }
  addColorPicker(t2) {
    __privateSet(this, _n, t2);
    const e2 = t2.renderButton();
    __privateMethod(this, _EditorToolbar_instances, g_fn).call(this, e2);
    __privateGet(this, _r).prepend(e2, __privateGet(this, _EditorToolbar_instances, f_get));
  }
  async addEditSignatureButton(t2) {
    const e2 = __privateSet(this, _l, await t2.renderEditButton(__privateGet(this, _a)));
    __privateMethod(this, _EditorToolbar_instances, g_fn).call(this, e2);
    __privateGet(this, _r).prepend(e2, __privateGet(this, _EditorToolbar_instances, f_get));
  }
  updateEditSignatureButton(t2) {
    __privateGet(this, _l) && (__privateGet(this, _l).title = t2);
  }
  remove() {
    var _a5;
    __privateGet(this, _s).remove();
    (_a5 = __privateGet(this, _n)) == null ? void 0 : _a5.destroy();
    __privateSet(this, _n, null);
  }
};
_s = new WeakMap();
_n = new WeakMap();
_a = new WeakMap();
_r = new WeakMap();
_o = new WeakMap();
_l = new WeakMap();
_h = new WeakMap();
_EditorToolbar_static = new WeakSet();
d_fn = function(t2) {
  t2.stopPropagation();
};
_EditorToolbar_instances = new WeakSet();
u_fn = function(t2) {
  __privateGet(this, _a)._focusEventsAllowed = false;
  stopEvent(t2);
};
p_fn = function(t2) {
  __privateGet(this, _a)._focusEventsAllowed = true;
  stopEvent(t2);
};
g_fn = function(t2) {
  const e2 = __privateGet(this, _a)._uiManager._signal;
  t2.addEventListener("focusin", __privateMethod(this, _EditorToolbar_instances, u_fn).bind(this), { capture: true, signal: e2 });
  t2.addEventListener("focusout", __privateMethod(this, _EditorToolbar_instances, p_fn).bind(this), { capture: true, signal: e2 });
  t2.addEventListener("contextmenu", noContextMenu, { signal: e2 });
};
c_fn = function() {
  const { editorType: t2, _uiManager: e2 } = __privateGet(this, _a), i2 = document.createElement("button");
  i2.className = "delete";
  i2.tabIndex = 0;
  i2.setAttribute("data-l10n-id", __privateGet(_EditorToolbar, _h)[t2]);
  __privateMethod(this, _EditorToolbar_instances, g_fn).call(this, i2);
  i2.addEventListener("click", (t3) => {
    e2.delete();
  }, { signal: e2._signal });
  __privateGet(this, _r).append(i2);
};
f_get = function() {
  const t2 = document.createElement("div");
  t2.className = "divider";
  return t2;
};
__privateAdd(_EditorToolbar, _EditorToolbar_static);
__privateAdd(_EditorToolbar, _h, null);
var EditorToolbar = _EditorToolbar;
var _r2, _s2, _m, _HighlightToolbar_instances, b_fn, w_fn, A_fn;
var HighlightToolbar = class {
  constructor(t2) {
    __privateAdd(this, _HighlightToolbar_instances);
    __privateAdd(this, _r2, null);
    __privateAdd(this, _s2, null);
    __privateAdd(this, _m);
    __privateSet(this, _m, t2);
  }
  show(t2, e2, i2) {
    const [s2, n2] = __privateMethod(this, _HighlightToolbar_instances, w_fn).call(this, e2, i2), { style: a2 } = __privateGet(this, _s2) || __privateSet(this, _s2, __privateMethod(this, _HighlightToolbar_instances, b_fn).call(this));
    t2.append(__privateGet(this, _s2));
    a2.insetInlineEnd = 100 * s2 + "%";
    a2.top = `calc(${100 * n2}% + var(--editor-toolbar-vert-offset))`;
  }
  hide() {
    __privateGet(this, _s2).remove();
  }
};
_r2 = new WeakMap();
_s2 = new WeakMap();
_m = new WeakMap();
_HighlightToolbar_instances = new WeakSet();
b_fn = function() {
  const t2 = __privateSet(this, _s2, document.createElement("div"));
  t2.className = "editToolbar";
  t2.setAttribute("role", "toolbar");
  t2.addEventListener("contextmenu", noContextMenu, { signal: __privateGet(this, _m)._signal });
  const e2 = __privateSet(this, _r2, document.createElement("div"));
  e2.className = "buttons";
  t2.append(e2);
  __privateMethod(this, _HighlightToolbar_instances, A_fn).call(this);
  return t2;
};
w_fn = function(t2, e2) {
  let i2 = 0, s2 = 0;
  for (const n2 of t2) {
    const t3 = n2.y + n2.height;
    if (t3 < i2) continue;
    const a2 = n2.x + (e2 ? n2.width : 0);
    if (t3 > i2) {
      s2 = a2;
      i2 = t3;
    } else e2 ? a2 > s2 && (s2 = a2) : a2 < s2 && (s2 = a2);
  }
  return [e2 ? 1 - s2 : s2, i2];
};
A_fn = function() {
  const t2 = document.createElement("button");
  t2.className = "highlightButton";
  t2.tabIndex = 0;
  t2.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button1");
  const e2 = document.createElement("span");
  t2.append(e2);
  e2.className = "visuallyHidden";
  e2.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button-label");
  const i2 = __privateGet(this, _m)._signal;
  t2.addEventListener("contextmenu", noContextMenu, { signal: i2 });
  t2.addEventListener("click", () => {
    __privateGet(this, _m).highlightSelection("floating_button");
  }, { signal: i2 });
  __privateGet(this, _r2).append(t2);
};
function bindEvents(t2, e2, i2) {
  for (const s2 of i2) e2.addEventListener(s2, t2[s2].bind(t2));
}
var _y;
var IdManager = class {
  constructor() {
    __privateAdd(this, _y, 0);
  }
  get id() {
    return "pdfjs_internal_editor_" + __privateWrapper(this, _y)._++;
  }
};
_y = new WeakMap();
var _v, _y2, _x, _ImageManager_instances, E_fn;
var _ImageManager = class _ImageManager {
  constructor() {
    __privateAdd(this, _ImageManager_instances);
    __privateAdd(this, _v, getUuid());
    __privateAdd(this, _y2, 0);
    __privateAdd(this, _x, null);
  }
  static get _isSVGFittingCanvas() {
    const t2 = new OffscreenCanvas(1, 3).getContext("2d", { willReadFrequently: true }), e2 = new Image();
    e2.src = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>';
    return shadow(this, "_isSVGFittingCanvas", e2.decode().then(() => {
      t2.drawImage(e2, 0, 0, 1, 1, 0, 0, 1, 3);
      return 0 === new Uint32Array(t2.getImageData(0, 0, 1, 1).data.buffer)[0];
    }));
  }
  async getFromFile(t2) {
    const { lastModified: e2, name: i2, size: s2, type: n2 } = t2;
    return __privateMethod(this, _ImageManager_instances, E_fn).call(this, `${e2}_${i2}_${s2}_${n2}`, t2);
  }
  async getFromUrl(t2) {
    return __privateMethod(this, _ImageManager_instances, E_fn).call(this, t2, t2);
  }
  async getFromBlob(t2, e2) {
    const i2 = await e2;
    return __privateMethod(this, _ImageManager_instances, E_fn).call(this, t2, i2);
  }
  async getFromId(t2) {
    __privateGet(this, _x) || __privateSet(this, _x, /* @__PURE__ */ new Map());
    const e2 = __privateGet(this, _x).get(t2);
    if (!e2) return null;
    if (e2.bitmap) {
      e2.refCounter += 1;
      return e2;
    }
    if (e2.file) return this.getFromFile(e2.file);
    if (e2.blobPromise) {
      const { blobPromise: t3 } = e2;
      delete e2.blobPromise;
      return this.getFromBlob(e2.id, t3);
    }
    return this.getFromUrl(e2.url);
  }
  getFromCanvas(t2, e2) {
    __privateGet(this, _x) || __privateSet(this, _x, /* @__PURE__ */ new Map());
    let i2 = __privateGet(this, _x).get(t2);
    if (i2 == null ? void 0 : i2.bitmap) {
      i2.refCounter += 1;
      return i2;
    }
    const s2 = new OffscreenCanvas(e2.width, e2.height);
    s2.getContext("2d").drawImage(e2, 0, 0);
    i2 = { bitmap: s2.transferToImageBitmap(), id: `image_${__privateGet(this, _v)}_${__privateWrapper(this, _y2)._++}`, refCounter: 1, isSvg: false };
    __privateGet(this, _x).set(t2, i2);
    __privateGet(this, _x).set(i2.id, i2);
    return i2;
  }
  getSvgUrl(t2) {
    const e2 = __privateGet(this, _x).get(t2);
    return (e2 == null ? void 0 : e2.isSvg) ? e2.svgUrl : null;
  }
  deleteId(t2) {
    var _a5;
    __privateGet(this, _x) || __privateSet(this, _x, /* @__PURE__ */ new Map());
    const e2 = __privateGet(this, _x).get(t2);
    if (!e2) return;
    e2.refCounter -= 1;
    if (0 !== e2.refCounter) return;
    const { bitmap: i2 } = e2;
    if (!e2.url && !e2.file) {
      const t3 = new OffscreenCanvas(i2.width, i2.height);
      t3.getContext("bitmaprenderer").transferFromImageBitmap(i2);
      e2.blobPromise = t3.convertToBlob();
    }
    (_a5 = i2.close) == null ? void 0 : _a5.call(i2);
    e2.bitmap = null;
  }
  isValidId(t2) {
    return t2.startsWith(`image_${__privateGet(this, _v)}_`);
  }
};
_v = new WeakMap();
_y2 = new WeakMap();
_x = new WeakMap();
_ImageManager_instances = new WeakSet();
E_fn = async function(t2, e2) {
  __privateGet(this, _x) || __privateSet(this, _x, /* @__PURE__ */ new Map());
  let i2 = __privateGet(this, _x).get(t2);
  if (null === i2) return null;
  if (i2 == null ? void 0 : i2.bitmap) {
    i2.refCounter += 1;
    return i2;
  }
  try {
    i2 || (i2 = { bitmap: null, id: `image_${__privateGet(this, _v)}_${__privateWrapper(this, _y2)._++}`, refCounter: 0, isSvg: false });
    let t3;
    if ("string" == typeof e2) {
      i2.url = e2;
      t3 = await fetchData(e2, "blob");
    } else e2 instanceof File ? t3 = i2.file = e2 : e2 instanceof Blob && (t3 = e2);
    if ("image/svg+xml" === t3.type) {
      const e3 = _ImageManager._isSVGFittingCanvas, s2 = new FileReader(), n2 = new Image(), a2 = new Promise((t4, a3) => {
        n2.onload = () => {
          i2.bitmap = n2;
          i2.isSvg = true;
          t4();
        };
        s2.onload = async () => {
          const t5 = i2.svgUrl = s2.result;
          n2.src = await e3 ? `${t5}#svgView(preserveAspectRatio(none))` : t5;
        };
        n2.onerror = s2.onerror = a3;
      });
      s2.readAsDataURL(t3);
      await a2;
    } else i2.bitmap = await createImageBitmap(t3);
    i2.refCounter = 1;
  } catch (t3) {
    warn(t3);
    i2 = null;
  }
  __privateGet(this, _x).set(t2, i2);
  i2 && __privateGet(this, _x).set(i2.id, i2);
  return i2;
};
var ImageManager = _ImageManager;
var __, _S, _C, _T;
var CommandManager = class {
  constructor(t2 = 128) {
    __privateAdd(this, __, []);
    __privateAdd(this, _S, false);
    __privateAdd(this, _C);
    __privateAdd(this, _T, -1);
    __privateSet(this, _C, t2);
  }
  add({ cmd: t2, undo: e2, post: i2, mustExec: s2, type: n2 = NaN, overwriteIfSameType: a2 = false, keepUndo: r2 = false }) {
    s2 && t2();
    if (__privateGet(this, _S)) return;
    const o2 = { cmd: t2, undo: e2, post: i2, type: n2 };
    if (-1 === __privateGet(this, _T)) {
      __privateGet(this, __).length > 0 && (__privateGet(this, __).length = 0);
      __privateSet(this, _T, 0);
      __privateGet(this, __).push(o2);
      return;
    }
    if (a2 && __privateGet(this, __)[__privateGet(this, _T)].type === n2) {
      r2 && (o2.undo = __privateGet(this, __)[__privateGet(this, _T)].undo);
      __privateGet(this, __)[__privateGet(this, _T)] = o2;
      return;
    }
    const l2 = __privateGet(this, _T) + 1;
    if (l2 === __privateGet(this, _C)) __privateGet(this, __).splice(0, 1);
    else {
      __privateSet(this, _T, l2);
      l2 < __privateGet(this, __).length && __privateGet(this, __).splice(l2);
    }
    __privateGet(this, __).push(o2);
  }
  undo() {
    if (-1 === __privateGet(this, _T)) return;
    __privateSet(this, _S, true);
    const { undo: t2, post: e2 } = __privateGet(this, __)[__privateGet(this, _T)];
    t2();
    e2 == null ? void 0 : e2();
    __privateSet(this, _S, false);
    __privateSet(this, _T, __privateGet(this, _T) - 1);
  }
  redo() {
    if (__privateGet(this, _T) < __privateGet(this, __).length - 1) {
      __privateSet(this, _T, __privateGet(this, _T) + 1);
      __privateSet(this, _S, true);
      const { cmd: t2, post: e2 } = __privateGet(this, __)[__privateGet(this, _T)];
      t2();
      e2 == null ? void 0 : e2();
      __privateSet(this, _S, false);
    }
  }
  hasSomethingToUndo() {
    return -1 !== __privateGet(this, _T);
  }
  hasSomethingToRedo() {
    return __privateGet(this, _T) < __privateGet(this, __).length - 1;
  }
  cleanType(t2) {
    if (-1 !== __privateGet(this, _T)) {
      for (let e2 = __privateGet(this, _T); e2 >= 0; e2--) if (__privateGet(this, __)[e2].type !== t2) {
        __privateGet(this, __).splice(e2 + 1, __privateGet(this, _T) - e2);
        __privateSet(this, _T, e2);
        return;
      }
      __privateGet(this, __).length = 0;
      __privateSet(this, _T, -1);
    }
  }
  destroy() {
    __privateSet(this, __, null);
  }
};
__ = new WeakMap();
_S = new WeakMap();
_C = new WeakMap();
_T = new WeakMap();
var _KeyboardManager_instances, M_fn;
var KeyboardManager = class {
  constructor(t2) {
    __privateAdd(this, _KeyboardManager_instances);
    this.buffer = [];
    this.callbacks = /* @__PURE__ */ new Map();
    this.allKeys = /* @__PURE__ */ new Set();
    const { isMac: e2 } = util_FeatureTest.platform;
    for (const [i2, s2, n2 = {}] of t2) for (const t3 of i2) {
      const i3 = t3.startsWith("mac+");
      if (e2 && i3) {
        this.callbacks.set(t3.slice(4), { callback: s2, options: n2 });
        this.allKeys.add(t3.split("+").at(-1));
      } else if (!e2 && !i3) {
        this.callbacks.set(t3, { callback: s2, options: n2 });
        this.allKeys.add(t3.split("+").at(-1));
      }
    }
  }
  exec(t2, e2) {
    if (!this.allKeys.has(e2.key)) return;
    const i2 = this.callbacks.get(__privateMethod(this, _KeyboardManager_instances, M_fn).call(this, e2));
    if (!i2) return;
    const { callback: s2, options: { bubbles: n2 = false, args: a2 = [], checker: r2 = null } } = i2;
    if (!r2 || r2(t2, e2)) {
      s2.bind(t2, ...a2, e2)();
      n2 || stopEvent(e2);
    }
  }
};
_KeyboardManager_instances = new WeakSet();
M_fn = function(t2) {
  t2.altKey && this.buffer.push("alt");
  t2.ctrlKey && this.buffer.push("ctrl");
  t2.metaKey && this.buffer.push("meta");
  t2.shiftKey && this.buffer.push("shift");
  this.buffer.push(t2.key);
  const e2 = this.buffer.join("+");
  this.buffer.length = 0;
  return e2;
};
var _ColorManager = class _ColorManager {
  get _colors() {
    const t2 = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
    !function getColorValues(t3) {
      const e2 = document.createElement("span");
      e2.style.visibility = "hidden";
      e2.style.colorScheme = "only light";
      document.body.append(e2);
      for (const i2 of t3.keys()) {
        e2.style.color = i2;
        const s2 = window.getComputedStyle(e2).color;
        t3.set(i2, getRGB(s2));
      }
      e2.remove();
    }(t2);
    return shadow(this, "_colors", t2);
  }
  convert(t2) {
    const e2 = getRGB(t2);
    if (!window.matchMedia("(forced-colors: active)").matches) return e2;
    for (const [t3, i2] of this._colors) if (i2.every((t4, i3) => t4 === e2[i3])) return _ColorManager._colorsMapping.get(t3);
    return e2;
  }
  getHexCode(t2) {
    const e2 = this._colors.get(t2);
    return e2 ? Util.makeHexColor(...e2) : t2;
  }
};
__publicField(_ColorManager, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
var ColorManager = _ColorManager;
var _D, _P, _k, _I, _R, _F, _L, _O, _N, _B, _H, _U, _z, _G, _$, _W, _V, _j, _q, _X, _K, _Y, _Q, _J, _Z, _tt, _et, _it, _st, _nt, _at, _rt, _ot, _lt, _ht, _dt, _ct, _ut, _pt, _gt, _ft, _mt, _bt, _At, _AnnotationEditorUIManager_instances, xt_fn, Et_fn, _t_fn, St_fn, Tt_fn, wt_fn, Mt_fn, Dt_fn, vt_fn, Pt_fn, kt_fn, It_fn, yt_fn, Ct_fn, Lt_fn, Nt_fn, Bt_fn, Rt_fn, Ht_get, Ot_fn, Ft_fn;
var _AnnotationEditorUIManager = class _AnnotationEditorUIManager {
  constructor(t2, e2, i2, s2, n2, a2, r2, o2, l2, h2, d2, c2, u2, p2) {
    __privateAdd(this, _AnnotationEditorUIManager_instances);
    __privateAdd(this, _D, new AbortController());
    __privateAdd(this, _P, null);
    __privateAdd(this, _k, /* @__PURE__ */ new Map());
    __privateAdd(this, _I, /* @__PURE__ */ new Map());
    __privateAdd(this, _R, null);
    __privateAdd(this, _F, null);
    __privateAdd(this, _L, null);
    __privateAdd(this, _O, new CommandManager());
    __privateAdd(this, _N, null);
    __privateAdd(this, _B, null);
    __privateAdd(this, _H, 0);
    __privateAdd(this, _U, /* @__PURE__ */ new Set());
    __privateAdd(this, _z, null);
    __privateAdd(this, _G, null);
    __privateAdd(this, _$, /* @__PURE__ */ new Set());
    __publicField(this, "_editorUndoBar", null);
    __privateAdd(this, _W, false);
    __privateAdd(this, _V, false);
    __privateAdd(this, _j, false);
    __privateAdd(this, _q, null);
    __privateAdd(this, _X, null);
    __privateAdd(this, _K, null);
    __privateAdd(this, _Y, null);
    __privateAdd(this, _Q, false);
    __privateAdd(this, _J, null);
    __privateAdd(this, _Z, new IdManager());
    __privateAdd(this, _tt, false);
    __privateAdd(this, _et, false);
    __privateAdd(this, _it, null);
    __privateAdd(this, _st, null);
    __privateAdd(this, _nt, null);
    __privateAdd(this, _at, null);
    __privateAdd(this, _rt, null);
    __privateAdd(this, _ot, u.NONE);
    __privateAdd(this, _lt, /* @__PURE__ */ new Set());
    __privateAdd(this, _ht, null);
    __privateAdd(this, _dt, null);
    __privateAdd(this, _ct, null);
    __privateAdd(this, _ut, null);
    __privateAdd(this, _pt, { isEditing: false, isEmpty: true, hasSomethingToUndo: false, hasSomethingToRedo: false, hasSelectedEditor: false, hasSelectedText: false });
    __privateAdd(this, _gt, [0, 0]);
    __privateAdd(this, _ft, null);
    __privateAdd(this, _mt, null);
    __privateAdd(this, _bt, null);
    __privateAdd(this, _At, null);
    const g2 = this._signal = __privateGet(this, _D).signal;
    __privateSet(this, _mt, t2);
    __privateSet(this, _bt, e2);
    __privateSet(this, _R, i2);
    __privateSet(this, _dt, s2);
    this._eventBus = n2;
    n2._on("editingaction", this.onEditingAction.bind(this), { signal: g2 });
    n2._on("pagechanging", this.onPageChanging.bind(this), { signal: g2 });
    n2._on("scalechanging", this.onScaleChanging.bind(this), { signal: g2 });
    n2._on("rotationchanging", this.onRotationChanging.bind(this), { signal: g2 });
    n2._on("setpreference", this.onSetPreference.bind(this), { signal: g2 });
    n2._on("switchannotationeditorparams", (t3) => this.updateParams(t3.type, t3.value), { signal: g2 });
    __privateMethod(this, _AnnotationEditorUIManager_instances, wt_fn).call(this);
    __privateMethod(this, _AnnotationEditorUIManager_instances, yt_fn).call(this);
    __privateMethod(this, _AnnotationEditorUIManager_instances, vt_fn).call(this);
    __privateSet(this, _F, a2.annotationStorage);
    __privateSet(this, _q, a2.filterFactory);
    __privateSet(this, _ct, r2);
    __privateSet(this, _Y, o2 || null);
    __privateSet(this, _W, l2);
    __privateSet(this, _V, h2);
    __privateSet(this, _j, d2);
    __privateSet(this, _rt, c2 || null);
    this.viewParameters = { realScale: PixelsPerInch.PDF_TO_CSS_UNITS, rotation: 0 };
    this.isShiftKeyDown = false;
    this._editorUndoBar = u2 || null;
    this._supportsPinchToZoom = false !== p2;
  }
  static get _keyboardManager() {
    const t2 = _AnnotationEditorUIManager.prototype, arrowChecker = (t3) => __privateGet(t3, _mt).contains(document.activeElement) && "BUTTON" !== document.activeElement.tagName && t3.hasSomethingToControl(), textInputChecker = (t3, { target: e3 }) => {
      if (e3 instanceof HTMLInputElement) {
        const { type: t4 } = e3;
        return "text" !== t4 && "number" !== t4;
      }
      return true;
    }, e2 = this.TRANSLATE_SMALL, i2 = this.TRANSLATE_BIG;
    return shadow(this, "_keyboardManager", new KeyboardManager([[["ctrl+a", "mac+meta+a"], t2.selectAll, { checker: textInputChecker }], [["ctrl+z", "mac+meta+z"], t2.undo, { checker: textInputChecker }], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], t2.redo, { checker: textInputChecker }], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], t2.delete, { checker: textInputChecker }], [["Enter", "mac+Enter"], t2.addNewEditorFromKeyboard, { checker: (t3, { target: e3 }) => !(e3 instanceof HTMLButtonElement) && __privateGet(t3, _mt).contains(e3) && !t3.isEnterHandled }], [[" ", "mac+ "], t2.addNewEditorFromKeyboard, { checker: (t3, { target: e3 }) => !(e3 instanceof HTMLButtonElement) && __privateGet(t3, _mt).contains(document.activeElement) }], [["Escape", "mac+Escape"], t2.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], t2.translateSelectedEditors, { args: [-e2, 0], checker: arrowChecker }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], t2.translateSelectedEditors, { args: [-i2, 0], checker: arrowChecker }], [["ArrowRight", "mac+ArrowRight"], t2.translateSelectedEditors, { args: [e2, 0], checker: arrowChecker }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], t2.translateSelectedEditors, { args: [i2, 0], checker: arrowChecker }], [["ArrowUp", "mac+ArrowUp"], t2.translateSelectedEditors, { args: [0, -e2], checker: arrowChecker }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], t2.translateSelectedEditors, { args: [0, -i2], checker: arrowChecker }], [["ArrowDown", "mac+ArrowDown"], t2.translateSelectedEditors, { args: [0, e2], checker: arrowChecker }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], t2.translateSelectedEditors, { args: [0, i2], checker: arrowChecker }]]));
  }
  destroy() {
    var _a5, _b, _c, _d, _e, _f, _g, _h2;
    (_a5 = __privateGet(this, _At)) == null ? void 0 : _a5.resolve();
    __privateSet(this, _At, null);
    (_b = __privateGet(this, _D)) == null ? void 0 : _b.abort();
    __privateSet(this, _D, null);
    this._signal = null;
    for (const t2 of __privateGet(this, _I).values()) t2.destroy();
    __privateGet(this, _I).clear();
    __privateGet(this, _k).clear();
    __privateGet(this, _$).clear();
    (_c = __privateGet(this, _at)) == null ? void 0 : _c.clear();
    __privateSet(this, _P, null);
    __privateGet(this, _lt).clear();
    __privateGet(this, _O).destroy();
    (_d = __privateGet(this, _R)) == null ? void 0 : _d.destroy();
    (_e = __privateGet(this, _dt)) == null ? void 0 : _e.destroy();
    (_f = __privateGet(this, _J)) == null ? void 0 : _f.hide();
    __privateSet(this, _J, null);
    (_g = __privateGet(this, _nt)) == null ? void 0 : _g.destroy();
    __privateSet(this, _nt, null);
    if (__privateGet(this, _X)) {
      clearTimeout(__privateGet(this, _X));
      __privateSet(this, _X, null);
    }
    if (__privateGet(this, _ft)) {
      clearTimeout(__privateGet(this, _ft));
      __privateSet(this, _ft, null);
    }
    (_h2 = this._editorUndoBar) == null ? void 0 : _h2.destroy();
  }
  combinedSignal(t2) {
    return AbortSignal.any([this._signal, t2.signal]);
  }
  get mlManager() {
    return __privateGet(this, _rt);
  }
  get useNewAltTextFlow() {
    return __privateGet(this, _V);
  }
  get useNewAltTextWhenAddingImage() {
    return __privateGet(this, _j);
  }
  get hcmFilter() {
    return shadow(this, "hcmFilter", __privateGet(this, _ct) ? __privateGet(this, _q).addHCMFilter(__privateGet(this, _ct).foreground, __privateGet(this, _ct).background) : "none");
  }
  get direction() {
    return shadow(this, "direction", getComputedStyle(__privateGet(this, _mt)).direction);
  }
  get highlightColors() {
    return shadow(this, "highlightColors", __privateGet(this, _Y) ? new Map(__privateGet(this, _Y).split(",").map((t2) => t2.split("=").map((t3) => t3.trim()))) : null);
  }
  get highlightColorNames() {
    return shadow(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, (t2) => t2.reverse())) : null);
  }
  setCurrentDrawingSession(t2) {
    if (t2) {
      this.unselectAll();
      this.disableUserSelect(true);
    } else this.disableUserSelect(false);
    __privateSet(this, _B, t2);
  }
  setMainHighlightColorPicker(t2) {
    __privateSet(this, _nt, t2);
  }
  editAltText(t2, e2 = false) {
    var _a5;
    (_a5 = __privateGet(this, _R)) == null ? void 0 : _a5.editAltText(this, t2, e2);
  }
  getSignature(t2) {
    var _a5;
    (_a5 = __privateGet(this, _dt)) == null ? void 0 : _a5.getSignature({ uiManager: this, editor: t2 });
  }
  get signatureManager() {
    return __privateGet(this, _dt);
  }
  switchToMode(t2, e2) {
    this._eventBus.on("annotationeditormodechanged", e2, { once: true, signal: this._signal });
    this._eventBus.dispatch("showannotationeditorui", { source: this, mode: t2 });
  }
  setPreference(t2, e2) {
    this._eventBus.dispatch("setpreference", { source: this, name: t2, value: e2 });
  }
  onSetPreference({ name: t2, value: e2 }) {
    if ("enableNewAltTextWhenAddingImage" === t2) __privateSet(this, _j, e2);
  }
  onPageChanging({ pageNumber: t2 }) {
    __privateSet(this, _H, t2 - 1);
  }
  focusMainContainer() {
    __privateGet(this, _mt).focus();
  }
  findParent(t2, e2) {
    for (const i2 of __privateGet(this, _I).values()) {
      const { x: s2, y: n2, width: a2, height: r2 } = i2.div.getBoundingClientRect();
      if (t2 >= s2 && t2 <= s2 + a2 && e2 >= n2 && e2 <= n2 + r2) return i2;
    }
    return null;
  }
  disableUserSelect(t2 = false) {
    __privateGet(this, _bt).classList.toggle("noUserSelect", t2);
  }
  addShouldRescale(t2) {
    __privateGet(this, _$).add(t2);
  }
  removeShouldRescale(t2) {
    __privateGet(this, _$).delete(t2);
  }
  onScaleChanging({ scale: t2 }) {
    var _a5;
    this.commitOrRemove();
    this.viewParameters.realScale = t2 * PixelsPerInch.PDF_TO_CSS_UNITS;
    for (const t3 of __privateGet(this, _$)) t3.onScaleChanging();
    (_a5 = __privateGet(this, _B)) == null ? void 0 : _a5.onScaleChanging();
  }
  onRotationChanging({ pagesRotation: t2 }) {
    this.commitOrRemove();
    this.viewParameters.rotation = t2;
  }
  highlightSelection(t2 = "") {
    const e2 = document.getSelection();
    if (!e2 || e2.isCollapsed) return;
    const { anchorNode: i2, anchorOffset: s2, focusNode: n2, focusOffset: a2 } = e2, r2 = e2.toString(), o2 = __privateMethod(this, _AnnotationEditorUIManager_instances, xt_fn).call(this, e2).closest(".textLayer"), l2 = this.getSelectionBoxes(o2);
    if (!l2) return;
    e2.empty();
    const h2 = __privateMethod(this, _AnnotationEditorUIManager_instances, Et_fn).call(this, o2), d2 = __privateGet(this, _ot) === u.NONE, callback = () => {
      h2 == null ? void 0 : h2.createAndAddNewEditor({ x: 0, y: 0 }, false, { methodOfCreation: t2, boxes: l2, anchorNode: i2, anchorOffset: s2, focusNode: n2, focusOffset: a2, text: r2 });
      d2 && this.showAllEditors("highlight", true, true);
    };
    d2 ? this.switchToMode(u.HIGHLIGHT, callback) : callback();
  }
  addToAnnotationStorage(t2) {
    t2.isEmpty() || !__privateGet(this, _F) || __privateGet(this, _F).has(t2.id) || __privateGet(this, _F).setValue(t2.id, t2);
  }
  blur() {
    this.isShiftKeyDown = false;
    if (__privateGet(this, _Q)) {
      __privateSet(this, _Q, false);
      __privateMethod(this, _AnnotationEditorUIManager_instances, Tt_fn).call(this, "main_toolbar");
    }
    if (!this.hasSelection) return;
    const { activeElement: t2 } = document;
    for (const e2 of __privateGet(this, _lt)) if (e2.div.contains(t2)) {
      __privateSet(this, _st, [e2, t2]);
      e2._focusEventsAllowed = false;
      break;
    }
  }
  focus() {
    if (!__privateGet(this, _st)) return;
    const [t2, e2] = __privateGet(this, _st);
    __privateSet(this, _st, null);
    e2.addEventListener("focusin", () => {
      t2._focusEventsAllowed = true;
    }, { once: true, signal: this._signal });
    e2.focus();
  }
  addEditListeners() {
    __privateMethod(this, _AnnotationEditorUIManager_instances, vt_fn).call(this);
    __privateMethod(this, _AnnotationEditorUIManager_instances, kt_fn).call(this);
  }
  removeEditListeners() {
    __privateMethod(this, _AnnotationEditorUIManager_instances, Pt_fn).call(this);
    __privateMethod(this, _AnnotationEditorUIManager_instances, It_fn).call(this);
  }
  dragOver(t2) {
    for (const { type: e2 } of t2.dataTransfer.items) for (const i2 of __privateGet(this, _G)) if (i2.isHandlingMimeForPasting(e2)) {
      t2.dataTransfer.dropEffect = "copy";
      t2.preventDefault();
      return;
    }
  }
  drop(t2) {
    for (const e2 of t2.dataTransfer.items) for (const i2 of __privateGet(this, _G)) if (i2.isHandlingMimeForPasting(e2.type)) {
      i2.paste(e2, this.currentLayer);
      t2.preventDefault();
      return;
    }
  }
  copy(t2) {
    var _a5;
    t2.preventDefault();
    (_a5 = __privateGet(this, _P)) == null ? void 0 : _a5.commitOrRemove();
    if (!this.hasSelection) return;
    const e2 = [];
    for (const t3 of __privateGet(this, _lt)) {
      const i2 = t3.serialize(true);
      i2 && e2.push(i2);
    }
    0 !== e2.length && t2.clipboardData.setData("application/pdfjs", JSON.stringify(e2));
  }
  cut(t2) {
    this.copy(t2);
    this.delete();
  }
  async paste(t2) {
    t2.preventDefault();
    const { clipboardData: e2 } = t2;
    for (const t3 of e2.items) for (const e3 of __privateGet(this, _G)) if (e3.isHandlingMimeForPasting(t3.type)) {
      e3.paste(t3, this.currentLayer);
      return;
    }
    let i2 = e2.getData("application/pdfjs");
    if (!i2) return;
    try {
      i2 = JSON.parse(i2);
    } catch (t3) {
      warn(`paste: "${t3.message}".`);
      return;
    }
    if (!Array.isArray(i2)) return;
    this.unselectAll();
    const s2 = this.currentLayer;
    try {
      const t3 = [];
      for (const e3 of i2) {
        const i3 = await s2.deserialize(e3);
        if (!i3) return;
        t3.push(i3);
      }
      const cmd = () => {
        for (const e3 of t3) __privateMethod(this, _AnnotationEditorUIManager_instances, Rt_fn).call(this, e3);
        __privateMethod(this, _AnnotationEditorUIManager_instances, Ft_fn).call(this, t3);
      }, undo = () => {
        for (const e3 of t3) e3.remove();
      };
      this.addCommands({ cmd, undo, mustExec: true });
    } catch (t3) {
      warn(`paste: "${t3.message}".`);
    }
  }
  keydown(t2) {
    this.isShiftKeyDown || "Shift" !== t2.key || (this.isShiftKeyDown = true);
    __privateGet(this, _ot) === u.NONE || this.isEditorHandlingKeyboard || _AnnotationEditorUIManager._keyboardManager.exec(this, t2);
  }
  keyup(t2) {
    if (this.isShiftKeyDown && "Shift" === t2.key) {
      this.isShiftKeyDown = false;
      if (__privateGet(this, _Q)) {
        __privateSet(this, _Q, false);
        __privateMethod(this, _AnnotationEditorUIManager_instances, Tt_fn).call(this, "main_toolbar");
      }
    }
  }
  onEditingAction({ name: t2 }) {
    switch (t2) {
      case "undo":
      case "redo":
      case "delete":
      case "selectAll":
        this[t2]();
        break;
      case "highlightSelection":
        this.highlightSelection("context_menu");
    }
  }
  setEditingState(t2) {
    if (t2) {
      __privateMethod(this, _AnnotationEditorUIManager_instances, Mt_fn).call(this);
      __privateMethod(this, _AnnotationEditorUIManager_instances, kt_fn).call(this);
      __privateMethod(this, _AnnotationEditorUIManager_instances, Ct_fn).call(this, { isEditing: __privateGet(this, _ot) !== u.NONE, isEmpty: __privateMethod(this, _AnnotationEditorUIManager_instances, Ot_fn).call(this), hasSomethingToUndo: __privateGet(this, _O).hasSomethingToUndo(), hasSomethingToRedo: __privateGet(this, _O).hasSomethingToRedo(), hasSelectedEditor: false });
    } else {
      __privateMethod(this, _AnnotationEditorUIManager_instances, Dt_fn).call(this);
      __privateMethod(this, _AnnotationEditorUIManager_instances, It_fn).call(this);
      __privateMethod(this, _AnnotationEditorUIManager_instances, Ct_fn).call(this, { isEditing: false });
      this.disableUserSelect(false);
    }
  }
  registerEditorTypes(t2) {
    if (!__privateGet(this, _G)) {
      __privateSet(this, _G, t2);
      for (const t3 of __privateGet(this, _G)) __privateMethod(this, _AnnotationEditorUIManager_instances, Lt_fn).call(this, t3.defaultPropertiesToUpdate);
    }
  }
  getId() {
    return __privateGet(this, _Z).id;
  }
  get currentLayer() {
    return __privateGet(this, _I).get(__privateGet(this, _H));
  }
  getLayer(t2) {
    return __privateGet(this, _I).get(t2);
  }
  get currentPageIndex() {
    return __privateGet(this, _H);
  }
  addLayer(t2) {
    __privateGet(this, _I).set(t2.pageIndex, t2);
    __privateGet(this, _tt) ? t2.enable() : t2.disable();
  }
  removeLayer(t2) {
    __privateGet(this, _I).delete(t2.pageIndex);
  }
  async updateMode(t2, e2 = null, i2 = false) {
    var _a5, _b, _c;
    if (__privateGet(this, _ot) !== t2) {
      if (__privateGet(this, _At)) {
        await __privateGet(this, _At).promise;
        if (!__privateGet(this, _At)) return;
      }
      __privateSet(this, _At, Promise.withResolvers());
      (_a5 = __privateGet(this, _B)) == null ? void 0 : _a5.commitOrRemove();
      __privateSet(this, _ot, t2);
      if (t2 !== u.NONE) {
        t2 === u.SIGNATURE && await ((_b = __privateGet(this, _dt)) == null ? void 0 : _b.loadSignatures());
        this.setEditingState(true);
        await __privateMethod(this, _AnnotationEditorUIManager_instances, Nt_fn).call(this);
        this.unselectAll();
        for (const e3 of __privateGet(this, _I).values()) e3.updateMode(t2);
        if (e2) {
          for (const t3 of __privateGet(this, _k).values()) if (t3.annotationElementId === e2 || t3.id === e2) {
            this.setSelected(t3);
            t3.enterInEditMode();
          } else t3.unselect();
          __privateGet(this, _At).resolve();
        } else {
          i2 && this.addNewEditorFromKeyboard();
          __privateGet(this, _At).resolve();
        }
      } else {
        this.setEditingState(false);
        __privateMethod(this, _AnnotationEditorUIManager_instances, Bt_fn).call(this);
        (_c = this._editorUndoBar) == null ? void 0 : _c.hide();
        __privateGet(this, _At).resolve();
      }
    }
  }
  addNewEditorFromKeyboard() {
    this.currentLayer.canCreateNewEmptyEditor() && this.currentLayer.addNewEditor();
  }
  updateToolbar(t2) {
    t2.mode !== __privateGet(this, _ot) && this._eventBus.dispatch("switchannotationeditormode", { source: this, ...t2 });
  }
  updateParams(t2, e2) {
    var _a5;
    if (__privateGet(this, _G)) {
      switch (t2) {
        case p.CREATE:
          this.currentLayer.addNewEditor(e2);
          return;
        case p.HIGHLIGHT_DEFAULT_COLOR:
          (_a5 = __privateGet(this, _nt)) == null ? void 0 : _a5.updateColor(e2);
          break;
        case p.HIGHLIGHT_SHOW_ALL:
          this._eventBus.dispatch("reporttelemetry", { source: this, details: { type: "editing", data: { type: "highlight", action: "toggle_visibility" } } });
          (__privateGet(this, _ut) || __privateSet(this, _ut, /* @__PURE__ */ new Map())).set(t2, e2);
          this.showAllEditors("highlight", e2);
      }
      for (const i2 of __privateGet(this, _lt)) i2.updateParams(t2, e2);
      for (const i2 of __privateGet(this, _G)) i2.updateDefaultParams(t2, e2);
    }
  }
  showAllEditors(t2, e2, i2 = false) {
    var _a5;
    for (const i3 of __privateGet(this, _k).values()) i3.editorType === t2 && i3.show(e2);
    (((_a5 = __privateGet(this, _ut)) == null ? void 0 : _a5.get(p.HIGHLIGHT_SHOW_ALL)) ?? true) !== e2 && __privateMethod(this, _AnnotationEditorUIManager_instances, Lt_fn).call(this, [[p.HIGHLIGHT_SHOW_ALL, e2]]);
  }
  enableWaiting(t2 = false) {
    if (__privateGet(this, _et) !== t2) {
      __privateSet(this, _et, t2);
      for (const e2 of __privateGet(this, _I).values()) {
        t2 ? e2.disableClick() : e2.enableClick();
        e2.div.classList.toggle("waiting", t2);
      }
    }
  }
  getEditors(t2) {
    const e2 = [];
    for (const i2 of __privateGet(this, _k).values()) i2.pageIndex === t2 && e2.push(i2);
    return e2;
  }
  getEditor(t2) {
    return __privateGet(this, _k).get(t2);
  }
  addEditor(t2) {
    __privateGet(this, _k).set(t2.id, t2);
  }
  removeEditor(t2) {
    var _a5, _b;
    if (t2.div.contains(document.activeElement)) {
      __privateGet(this, _X) && clearTimeout(__privateGet(this, _X));
      __privateSet(this, _X, setTimeout(() => {
        this.focusMainContainer();
        __privateSet(this, _X, null);
      }, 0));
    }
    __privateGet(this, _k).delete(t2.id);
    t2.annotationElementId && ((_a5 = __privateGet(this, _at)) == null ? void 0 : _a5.delete(t2.annotationElementId));
    this.unselect(t2);
    t2.annotationElementId && __privateGet(this, _U).has(t2.annotationElementId) || ((_b = __privateGet(this, _F)) == null ? void 0 : _b.remove(t2.id));
  }
  addDeletedAnnotationElement(t2) {
    __privateGet(this, _U).add(t2.annotationElementId);
    this.addChangedExistingAnnotation(t2);
    t2.deleted = true;
  }
  isDeletedAnnotationElement(t2) {
    return __privateGet(this, _U).has(t2);
  }
  removeDeletedAnnotationElement(t2) {
    __privateGet(this, _U).delete(t2.annotationElementId);
    this.removeChangedExistingAnnotation(t2);
    t2.deleted = false;
  }
  setActiveEditor(t2) {
    if (__privateGet(this, _P) !== t2) {
      __privateSet(this, _P, t2);
      t2 && __privateMethod(this, _AnnotationEditorUIManager_instances, Lt_fn).call(this, t2.propertiesToUpdate);
    }
  }
  updateUI(t2) {
    __privateGet(this, _AnnotationEditorUIManager_instances, Ht_get) === t2 && __privateMethod(this, _AnnotationEditorUIManager_instances, Lt_fn).call(this, t2.propertiesToUpdate);
  }
  updateUIForDefaultProperties(t2) {
    __privateMethod(this, _AnnotationEditorUIManager_instances, Lt_fn).call(this, t2.defaultPropertiesToUpdate);
  }
  toggleSelected(t2) {
    if (__privateGet(this, _lt).has(t2)) {
      __privateGet(this, _lt).delete(t2);
      t2.unselect();
      __privateMethod(this, _AnnotationEditorUIManager_instances, Ct_fn).call(this, { hasSelectedEditor: this.hasSelection });
    } else {
      __privateGet(this, _lt).add(t2);
      t2.select();
      __privateMethod(this, _AnnotationEditorUIManager_instances, Lt_fn).call(this, t2.propertiesToUpdate);
      __privateMethod(this, _AnnotationEditorUIManager_instances, Ct_fn).call(this, { hasSelectedEditor: true });
    }
  }
  setSelected(t2) {
    var _a5;
    (_a5 = __privateGet(this, _B)) == null ? void 0 : _a5.commitOrRemove();
    for (const e2 of __privateGet(this, _lt)) e2 !== t2 && e2.unselect();
    __privateGet(this, _lt).clear();
    __privateGet(this, _lt).add(t2);
    t2.select();
    __privateMethod(this, _AnnotationEditorUIManager_instances, Lt_fn).call(this, t2.propertiesToUpdate);
    __privateMethod(this, _AnnotationEditorUIManager_instances, Ct_fn).call(this, { hasSelectedEditor: true });
  }
  isSelected(t2) {
    return __privateGet(this, _lt).has(t2);
  }
  get firstSelectedEditor() {
    return __privateGet(this, _lt).values().next().value;
  }
  unselect(t2) {
    t2.unselect();
    __privateGet(this, _lt).delete(t2);
    __privateMethod(this, _AnnotationEditorUIManager_instances, Ct_fn).call(this, { hasSelectedEditor: this.hasSelection });
  }
  get hasSelection() {
    return 0 !== __privateGet(this, _lt).size;
  }
  get isEnterHandled() {
    return 1 === __privateGet(this, _lt).size && this.firstSelectedEditor.isEnterHandled;
  }
  undo() {
    var _a5;
    __privateGet(this, _O).undo();
    __privateMethod(this, _AnnotationEditorUIManager_instances, Ct_fn).call(this, { hasSomethingToUndo: __privateGet(this, _O).hasSomethingToUndo(), hasSomethingToRedo: true, isEmpty: __privateMethod(this, _AnnotationEditorUIManager_instances, Ot_fn).call(this) });
    (_a5 = this._editorUndoBar) == null ? void 0 : _a5.hide();
  }
  redo() {
    __privateGet(this, _O).redo();
    __privateMethod(this, _AnnotationEditorUIManager_instances, Ct_fn).call(this, { hasSomethingToUndo: true, hasSomethingToRedo: __privateGet(this, _O).hasSomethingToRedo(), isEmpty: __privateMethod(this, _AnnotationEditorUIManager_instances, Ot_fn).call(this) });
  }
  addCommands(t2) {
    __privateGet(this, _O).add(t2);
    __privateMethod(this, _AnnotationEditorUIManager_instances, Ct_fn).call(this, { hasSomethingToUndo: true, hasSomethingToRedo: false, isEmpty: __privateMethod(this, _AnnotationEditorUIManager_instances, Ot_fn).call(this) });
  }
  cleanUndoStack(t2) {
    __privateGet(this, _O).cleanType(t2);
  }
  delete() {
    var _a5;
    this.commitOrRemove();
    const t2 = (_a5 = this.currentLayer) == null ? void 0 : _a5.endDrawingSession(true);
    if (!this.hasSelection && !t2) return;
    const e2 = t2 ? [t2] : [...__privateGet(this, _lt)], undo = () => {
      for (const t3 of e2) __privateMethod(this, _AnnotationEditorUIManager_instances, Rt_fn).call(this, t3);
    };
    this.addCommands({ cmd: () => {
      var _a6;
      (_a6 = this._editorUndoBar) == null ? void 0 : _a6.show(undo, 1 === e2.length ? e2[0].editorType : e2.length);
      for (const t3 of e2) t3.remove();
    }, undo, mustExec: true });
  }
  commitOrRemove() {
    var _a5;
    (_a5 = __privateGet(this, _P)) == null ? void 0 : _a5.commitOrRemove();
  }
  hasSomethingToControl() {
    return __privateGet(this, _P) || this.hasSelection;
  }
  selectAll() {
    for (const t2 of __privateGet(this, _lt)) t2.commit();
    __privateMethod(this, _AnnotationEditorUIManager_instances, Ft_fn).call(this, __privateGet(this, _k).values());
  }
  unselectAll() {
    var _a5;
    if (__privateGet(this, _P)) {
      __privateGet(this, _P).commitOrRemove();
      if (__privateGet(this, _ot) !== u.NONE) return;
    }
    if (!((_a5 = __privateGet(this, _B)) == null ? void 0 : _a5.commitOrRemove()) && this.hasSelection) {
      for (const t2 of __privateGet(this, _lt)) t2.unselect();
      __privateGet(this, _lt).clear();
      __privateMethod(this, _AnnotationEditorUIManager_instances, Ct_fn).call(this, { hasSelectedEditor: false });
    }
  }
  translateSelectedEditors(t2, e2, i2 = false) {
    i2 || this.commitOrRemove();
    if (!this.hasSelection) return;
    __privateGet(this, _gt)[0] += t2;
    __privateGet(this, _gt)[1] += e2;
    const [s2, n2] = __privateGet(this, _gt), a2 = [...__privateGet(this, _lt)];
    __privateGet(this, _ft) && clearTimeout(__privateGet(this, _ft));
    __privateSet(this, _ft, setTimeout(() => {
      __privateSet(this, _ft, null);
      __privateGet(this, _gt)[0] = __privateGet(this, _gt)[1] = 0;
      this.addCommands({ cmd: () => {
        for (const t3 of a2) if (__privateGet(this, _k).has(t3.id)) {
          t3.translateInPage(s2, n2);
          t3.translationDone();
        }
      }, undo: () => {
        for (const t3 of a2) if (__privateGet(this, _k).has(t3.id)) {
          t3.translateInPage(-s2, -n2);
          t3.translationDone();
        }
      }, mustExec: false });
    }, 1e3));
    for (const i3 of a2) {
      i3.translateInPage(t2, e2);
      i3.translationDone();
    }
  }
  setUpDragSession() {
    if (this.hasSelection) {
      this.disableUserSelect(true);
      __privateSet(this, _z, /* @__PURE__ */ new Map());
      for (const t2 of __privateGet(this, _lt)) __privateGet(this, _z).set(t2, { savedX: t2.x, savedY: t2.y, savedPageIndex: t2.pageIndex, newX: 0, newY: 0, newPageIndex: -1 });
    }
  }
  endDragSession() {
    if (!__privateGet(this, _z)) return false;
    this.disableUserSelect(false);
    const t2 = __privateGet(this, _z);
    __privateSet(this, _z, null);
    let e2 = false;
    for (const [{ x: i2, y: s2, pageIndex: n2 }, a2] of t2) {
      a2.newX = i2;
      a2.newY = s2;
      a2.newPageIndex = n2;
      e2 || (e2 = i2 !== a2.savedX || s2 !== a2.savedY || n2 !== a2.savedPageIndex);
    }
    if (!e2) return false;
    const move = (t3, e3, i2, s2) => {
      if (__privateGet(this, _k).has(t3.id)) {
        const n2 = __privateGet(this, _I).get(s2);
        if (n2) t3._setParentAndPosition(n2, e3, i2);
        else {
          t3.pageIndex = s2;
          t3.x = e3;
          t3.y = i2;
        }
      }
    };
    this.addCommands({ cmd: () => {
      for (const [e3, { newX: i2, newY: s2, newPageIndex: n2 }] of t2) move(e3, i2, s2, n2);
    }, undo: () => {
      for (const [e3, { savedX: i2, savedY: s2, savedPageIndex: n2 }] of t2) move(e3, i2, s2, n2);
    }, mustExec: true });
    return true;
  }
  dragSelectedEditors(t2, e2) {
    if (__privateGet(this, _z)) for (const i2 of __privateGet(this, _z).keys()) i2.drag(t2, e2);
  }
  rebuild(t2) {
    if (null === t2.parent) {
      const e2 = this.getLayer(t2.pageIndex);
      if (e2) {
        e2.changeParent(t2);
        e2.addOrRebuild(t2);
      } else {
        this.addEditor(t2);
        this.addToAnnotationStorage(t2);
        t2.rebuild();
      }
    } else t2.parent.addOrRebuild(t2);
  }
  get isEditorHandlingKeyboard() {
    var _a5;
    return ((_a5 = this.getActive()) == null ? void 0 : _a5.shouldGetKeyboardEvents()) || 1 === __privateGet(this, _lt).size && this.firstSelectedEditor.shouldGetKeyboardEvents();
  }
  isActive(t2) {
    return __privateGet(this, _P) === t2;
  }
  getActive() {
    return __privateGet(this, _P);
  }
  getMode() {
    return __privateGet(this, _ot);
  }
  get imageManager() {
    return shadow(this, "imageManager", new ImageManager());
  }
  getSelectionBoxes(t2) {
    if (!t2) return null;
    const e2 = document.getSelection();
    for (let i3 = 0, s3 = e2.rangeCount; i3 < s3; i3++) if (!t2.contains(e2.getRangeAt(i3).commonAncestorContainer)) return null;
    const { x: i2, y: s2, width: n2, height: a2 } = t2.getBoundingClientRect();
    let r2;
    switch (t2.getAttribute("data-main-rotation")) {
      case "90":
        r2 = (t3, e3, r3, o3) => ({ x: (e3 - s2) / a2, y: 1 - (t3 + r3 - i2) / n2, width: o3 / a2, height: r3 / n2 });
        break;
      case "180":
        r2 = (t3, e3, r3, o3) => ({ x: 1 - (t3 + r3 - i2) / n2, y: 1 - (e3 + o3 - s2) / a2, width: r3 / n2, height: o3 / a2 });
        break;
      case "270":
        r2 = (t3, e3, r3, o3) => ({ x: 1 - (e3 + o3 - s2) / a2, y: (t3 - i2) / n2, width: o3 / a2, height: r3 / n2 });
        break;
      default:
        r2 = (t3, e3, r3, o3) => ({ x: (t3 - i2) / n2, y: (e3 - s2) / a2, width: r3 / n2, height: o3 / a2 });
    }
    const o2 = [];
    for (let t3 = 0, i3 = e2.rangeCount; t3 < i3; t3++) {
      const i4 = e2.getRangeAt(t3);
      if (!i4.collapsed) for (const { x: t4, y: e3, width: s3, height: n3 } of i4.getClientRects()) 0 !== s3 && 0 !== n3 && o2.push(r2(t4, e3, s3, n3));
    }
    return 0 === o2.length ? null : o2;
  }
  addChangedExistingAnnotation({ annotationElementId: t2, id: e2 }) {
    (__privateGet(this, _L) || __privateSet(this, _L, /* @__PURE__ */ new Map())).set(t2, e2);
  }
  removeChangedExistingAnnotation({ annotationElementId: t2 }) {
    var _a5;
    (_a5 = __privateGet(this, _L)) == null ? void 0 : _a5.delete(t2);
  }
  renderAnnotationElement(t2) {
    var _a5;
    const e2 = (_a5 = __privateGet(this, _L)) == null ? void 0 : _a5.get(t2.data.id);
    if (!e2) return;
    const i2 = __privateGet(this, _F).getRawValue(e2);
    i2 && (__privateGet(this, _ot) !== u.NONE || i2.hasBeenModified) && i2.renderAnnotationElement(t2);
  }
  setMissingCanvas(t2, e2, i2) {
    var _a5;
    const s2 = (_a5 = __privateGet(this, _at)) == null ? void 0 : _a5.get(t2);
    if (s2) {
      s2.setCanvas(e2, i2);
      __privateGet(this, _at).delete(t2);
    }
  }
  addMissingCanvas(t2, e2) {
    (__privateGet(this, _at) || __privateSet(this, _at, /* @__PURE__ */ new Map())).set(t2, e2);
  }
};
_D = new WeakMap();
_P = new WeakMap();
_k = new WeakMap();
_I = new WeakMap();
_R = new WeakMap();
_F = new WeakMap();
_L = new WeakMap();
_O = new WeakMap();
_N = new WeakMap();
_B = new WeakMap();
_H = new WeakMap();
_U = new WeakMap();
_z = new WeakMap();
_G = new WeakMap();
_$ = new WeakMap();
_W = new WeakMap();
_V = new WeakMap();
_j = new WeakMap();
_q = new WeakMap();
_X = new WeakMap();
_K = new WeakMap();
_Y = new WeakMap();
_Q = new WeakMap();
_J = new WeakMap();
_Z = new WeakMap();
_tt = new WeakMap();
_et = new WeakMap();
_it = new WeakMap();
_st = new WeakMap();
_nt = new WeakMap();
_at = new WeakMap();
_rt = new WeakMap();
_ot = new WeakMap();
_lt = new WeakMap();
_ht = new WeakMap();
_dt = new WeakMap();
_ct = new WeakMap();
_ut = new WeakMap();
_pt = new WeakMap();
_gt = new WeakMap();
_ft = new WeakMap();
_mt = new WeakMap();
_bt = new WeakMap();
_At = new WeakMap();
_AnnotationEditorUIManager_instances = new WeakSet();
xt_fn = function({ anchorNode: t2 }) {
  return t2.nodeType === Node.TEXT_NODE ? t2.parentElement : t2;
};
Et_fn = function(t2) {
  const { currentLayer: e2 } = this;
  if (e2.hasTextLayer(t2)) return e2;
  for (const e3 of __privateGet(this, _I).values()) if (e3.hasTextLayer(t2)) return e3;
  return null;
};
_t_fn = function() {
  const t2 = document.getSelection();
  if (!t2 || t2.isCollapsed) return;
  const e2 = __privateMethod(this, _AnnotationEditorUIManager_instances, xt_fn).call(this, t2).closest(".textLayer"), i2 = this.getSelectionBoxes(e2);
  if (i2) {
    __privateGet(this, _J) || __privateSet(this, _J, new HighlightToolbar(this));
    __privateGet(this, _J).show(e2, i2, "ltr" === this.direction);
  }
};
St_fn = function() {
  var _a5, _b, _c;
  const t2 = document.getSelection();
  if (!t2 || t2.isCollapsed) {
    if (__privateGet(this, _ht)) {
      (_a5 = __privateGet(this, _J)) == null ? void 0 : _a5.hide();
      __privateSet(this, _ht, null);
      __privateMethod(this, _AnnotationEditorUIManager_instances, Ct_fn).call(this, { hasSelectedText: false });
    }
    return;
  }
  const { anchorNode: e2 } = t2;
  if (e2 === __privateGet(this, _ht)) return;
  const i2 = __privateMethod(this, _AnnotationEditorUIManager_instances, xt_fn).call(this, t2).closest(".textLayer");
  if (i2) {
    (_b = __privateGet(this, _J)) == null ? void 0 : _b.hide();
    __privateSet(this, _ht, e2);
    __privateMethod(this, _AnnotationEditorUIManager_instances, Ct_fn).call(this, { hasSelectedText: true });
    if (__privateGet(this, _ot) === u.HIGHLIGHT || __privateGet(this, _ot) === u.NONE) {
      __privateGet(this, _ot) === u.HIGHLIGHT && this.showAllEditors("highlight", true, true);
      __privateSet(this, _Q, this.isShiftKeyDown);
      if (!this.isShiftKeyDown) {
        const t3 = __privateGet(this, _ot) === u.HIGHLIGHT ? __privateMethod(this, _AnnotationEditorUIManager_instances, Et_fn).call(this, i2) : null;
        t3 == null ? void 0 : t3.toggleDrawing();
        const e3 = new AbortController(), s2 = this.combinedSignal(e3), pointerup = (i3) => {
          if ("pointerup" !== i3.type || 0 === i3.button) {
            e3.abort();
            t3 == null ? void 0 : t3.toggleDrawing(true);
            "pointerup" === i3.type && __privateMethod(this, _AnnotationEditorUIManager_instances, Tt_fn).call(this, "main_toolbar");
          }
        };
        window.addEventListener("pointerup", pointerup, { signal: s2 });
        window.addEventListener("blur", pointerup, { signal: s2 });
      }
    }
  } else if (__privateGet(this, _ht)) {
    (_c = __privateGet(this, _J)) == null ? void 0 : _c.hide();
    __privateSet(this, _ht, null);
    __privateMethod(this, _AnnotationEditorUIManager_instances, Ct_fn).call(this, { hasSelectedText: false });
  }
};
Tt_fn = function(t2 = "") {
  __privateGet(this, _ot) === u.HIGHLIGHT ? this.highlightSelection(t2) : __privateGet(this, _W) && __privateMethod(this, _AnnotationEditorUIManager_instances, _t_fn).call(this);
};
wt_fn = function() {
  document.addEventListener("selectionchange", __privateMethod(this, _AnnotationEditorUIManager_instances, St_fn).bind(this), { signal: this._signal });
};
Mt_fn = function() {
  if (__privateGet(this, _K)) return;
  __privateSet(this, _K, new AbortController());
  const t2 = this.combinedSignal(__privateGet(this, _K));
  window.addEventListener("focus", this.focus.bind(this), { signal: t2 });
  window.addEventListener("blur", this.blur.bind(this), { signal: t2 });
};
Dt_fn = function() {
  var _a5;
  (_a5 = __privateGet(this, _K)) == null ? void 0 : _a5.abort();
  __privateSet(this, _K, null);
};
vt_fn = function() {
  if (__privateGet(this, _it)) return;
  __privateSet(this, _it, new AbortController());
  const t2 = this.combinedSignal(__privateGet(this, _it));
  window.addEventListener("keydown", this.keydown.bind(this), { signal: t2 });
  window.addEventListener("keyup", this.keyup.bind(this), { signal: t2 });
};
Pt_fn = function() {
  var _a5;
  (_a5 = __privateGet(this, _it)) == null ? void 0 : _a5.abort();
  __privateSet(this, _it, null);
};
kt_fn = function() {
  if (__privateGet(this, _N)) return;
  __privateSet(this, _N, new AbortController());
  const t2 = this.combinedSignal(__privateGet(this, _N));
  document.addEventListener("copy", this.copy.bind(this), { signal: t2 });
  document.addEventListener("cut", this.cut.bind(this), { signal: t2 });
  document.addEventListener("paste", this.paste.bind(this), { signal: t2 });
};
It_fn = function() {
  var _a5;
  (_a5 = __privateGet(this, _N)) == null ? void 0 : _a5.abort();
  __privateSet(this, _N, null);
};
yt_fn = function() {
  const t2 = this._signal;
  document.addEventListener("dragover", this.dragOver.bind(this), { signal: t2 });
  document.addEventListener("drop", this.drop.bind(this), { signal: t2 });
};
Ct_fn = function(t2) {
  if (Object.entries(t2).some(([t3, e2]) => __privateGet(this, _pt)[t3] !== e2)) {
    this._eventBus.dispatch("annotationeditorstateschanged", { source: this, details: Object.assign(__privateGet(this, _pt), t2) });
    __privateGet(this, _ot) === u.HIGHLIGHT && false === t2.hasSelectedEditor && __privateMethod(this, _AnnotationEditorUIManager_instances, Lt_fn).call(this, [[p.HIGHLIGHT_FREE, true]]);
  }
};
Lt_fn = function(t2) {
  this._eventBus.dispatch("annotationeditorparamschanged", { source: this, details: t2 });
};
Nt_fn = async function() {
  if (!__privateGet(this, _tt)) {
    __privateSet(this, _tt, true);
    const t2 = [];
    for (const e2 of __privateGet(this, _I).values()) t2.push(e2.enable());
    await Promise.all(t2);
    for (const t3 of __privateGet(this, _k).values()) t3.enable();
  }
};
Bt_fn = function() {
  this.unselectAll();
  if (__privateGet(this, _tt)) {
    __privateSet(this, _tt, false);
    for (const t2 of __privateGet(this, _I).values()) t2.disable();
    for (const t2 of __privateGet(this, _k).values()) t2.disable();
  }
};
Rt_fn = function(t2) {
  const e2 = __privateGet(this, _I).get(t2.pageIndex);
  if (e2) e2.addOrRebuild(t2);
  else {
    this.addEditor(t2);
    this.addToAnnotationStorage(t2);
  }
};
Ht_get = function() {
  let t2 = null;
  for (t2 of __privateGet(this, _lt)) ;
  return t2;
};
Ot_fn = function() {
  if (0 === __privateGet(this, _k).size) return true;
  if (1 === __privateGet(this, _k).size) for (const t2 of __privateGet(this, _k).values()) return t2.isEmpty();
  return false;
};
Ft_fn = function(t2) {
  for (const t3 of __privateGet(this, _lt)) t3.unselect();
  __privateGet(this, _lt).clear();
  for (const e2 of t2) if (!e2.isEmpty()) {
    __privateGet(this, _lt).add(e2);
    e2.select();
  }
  __privateMethod(this, _AnnotationEditorUIManager_instances, Ct_fn).call(this, { hasSelectedEditor: this.hasSelection });
};
__publicField(_AnnotationEditorUIManager, "TRANSLATE_SMALL", 1);
__publicField(_AnnotationEditorUIManager, "TRANSLATE_BIG", 10);
var AnnotationEditorUIManager = _AnnotationEditorUIManager;
var _o2, _Ut, _zt, _Gt, _$t, _Wt, _Vt, _jt, _a2, _qt, _Xt, _Kt, _Yt, _AltText_instances, Qt_get, Jt_fn;
var _AltText = class _AltText {
  constructor(t2) {
    __privateAdd(this, _AltText_instances);
    __privateAdd(this, _o2, null);
    __privateAdd(this, _Ut, false);
    __privateAdd(this, _zt, null);
    __privateAdd(this, _Gt, null);
    __privateAdd(this, _$t, null);
    __privateAdd(this, _Wt, null);
    __privateAdd(this, _Vt, false);
    __privateAdd(this, _jt, null);
    __privateAdd(this, _a2, null);
    __privateAdd(this, _qt, null);
    __privateAdd(this, _Xt, null);
    __privateAdd(this, _Kt, false);
    __privateSet(this, _a2, t2);
    __privateSet(this, _Kt, t2._uiManager.useNewAltTextFlow);
    __privateGet(_AltText, _Yt) || __privateSet(_AltText, _Yt, Object.freeze({ added: "pdfjs-editor-new-alt-text-added-button", "added-label": "pdfjs-editor-new-alt-text-added-button-label", missing: "pdfjs-editor-new-alt-text-missing-button", "missing-label": "pdfjs-editor-new-alt-text-missing-button-label", review: "pdfjs-editor-new-alt-text-to-review-button", "review-label": "pdfjs-editor-new-alt-text-to-review-button-label" }));
  }
  static initialize(t2) {
    _AltText._l10n ?? (_AltText._l10n = t2);
  }
  async render() {
    const t2 = __privateSet(this, _zt, document.createElement("button"));
    t2.className = "altText";
    t2.tabIndex = "0";
    const e2 = __privateSet(this, _Gt, document.createElement("span"));
    t2.append(e2);
    if (__privateGet(this, _Kt)) {
      t2.classList.add("new");
      t2.setAttribute("data-l10n-id", __privateGet(_AltText, _Yt).missing);
      e2.setAttribute("data-l10n-id", __privateGet(_AltText, _Yt)["missing-label"]);
    } else {
      t2.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button");
      e2.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button-label");
    }
    const i2 = __privateGet(this, _a2)._uiManager._signal;
    t2.addEventListener("contextmenu", noContextMenu, { signal: i2 });
    t2.addEventListener("pointerdown", (t3) => t3.stopPropagation(), { signal: i2 });
    const onClick = (t3) => {
      t3.preventDefault();
      __privateGet(this, _a2)._uiManager.editAltText(__privateGet(this, _a2));
      __privateGet(this, _Kt) && __privateGet(this, _a2)._reportTelemetry({ action: "pdfjs.image.alt_text.image_status_label_clicked", data: { label: __privateGet(this, _AltText_instances, Qt_get) } });
    };
    t2.addEventListener("click", onClick, { capture: true, signal: i2 });
    t2.addEventListener("keydown", (e3) => {
      if (e3.target === t2 && "Enter" === e3.key) {
        __privateSet(this, _Vt, true);
        onClick(e3);
      }
    }, { signal: i2 });
    await __privateMethod(this, _AltText_instances, Jt_fn).call(this);
    return t2;
  }
  finish() {
    if (__privateGet(this, _zt)) {
      __privateGet(this, _zt).focus({ focusVisible: __privateGet(this, _Vt) });
      __privateSet(this, _Vt, false);
    }
  }
  isEmpty() {
    return __privateGet(this, _Kt) ? null === __privateGet(this, _o2) : !__privateGet(this, _o2) && !__privateGet(this, _Ut);
  }
  hasData() {
    return __privateGet(this, _Kt) ? null !== __privateGet(this, _o2) || !!__privateGet(this, _qt) : this.isEmpty();
  }
  get guessedText() {
    return __privateGet(this, _qt);
  }
  async setGuessedText(t2) {
    if (null === __privateGet(this, _o2)) {
      __privateSet(this, _qt, t2);
      __privateSet(this, _Xt, await _AltText._l10n.get("pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer", { generatedAltText: t2 }));
      __privateMethod(this, _AltText_instances, Jt_fn).call(this);
    }
  }
  toggleAltTextBadge(t2 = false) {
    var _a5;
    if (__privateGet(this, _Kt) && !__privateGet(this, _o2)) {
      if (!__privateGet(this, _jt)) {
        const t3 = __privateSet(this, _jt, document.createElement("div"));
        t3.className = "noAltTextBadge";
        __privateGet(this, _a2).div.append(t3);
      }
      __privateGet(this, _jt).classList.toggle("hidden", !t2);
    } else {
      (_a5 = __privateGet(this, _jt)) == null ? void 0 : _a5.remove();
      __privateSet(this, _jt, null);
    }
  }
  serialize(t2) {
    let e2 = __privateGet(this, _o2);
    t2 || __privateGet(this, _qt) !== e2 || (e2 = __privateGet(this, _Xt));
    return { altText: e2, decorative: __privateGet(this, _Ut), guessedText: __privateGet(this, _qt), textWithDisclaimer: __privateGet(this, _Xt) };
  }
  get data() {
    return { altText: __privateGet(this, _o2), decorative: __privateGet(this, _Ut) };
  }
  set data({ altText: t2, decorative: e2, guessedText: i2, textWithDisclaimer: s2, cancel: n2 = false }) {
    if (i2) {
      __privateSet(this, _qt, i2);
      __privateSet(this, _Xt, s2);
    }
    if (__privateGet(this, _o2) !== t2 || __privateGet(this, _Ut) !== e2) {
      if (!n2) {
        __privateSet(this, _o2, t2);
        __privateSet(this, _Ut, e2);
      }
      __privateMethod(this, _AltText_instances, Jt_fn).call(this);
    }
  }
  toggle(t2 = false) {
    if (__privateGet(this, _zt)) {
      if (!t2 && __privateGet(this, _Wt)) {
        clearTimeout(__privateGet(this, _Wt));
        __privateSet(this, _Wt, null);
      }
      __privateGet(this, _zt).disabled = !t2;
    }
  }
  shown() {
    __privateGet(this, _a2)._reportTelemetry({ action: "pdfjs.image.alt_text.image_status_label_displayed", data: { label: __privateGet(this, _AltText_instances, Qt_get) } });
  }
  destroy() {
    var _a5, _b;
    (_a5 = __privateGet(this, _zt)) == null ? void 0 : _a5.remove();
    __privateSet(this, _zt, null);
    __privateSet(this, _Gt, null);
    __privateSet(this, _$t, null);
    (_b = __privateGet(this, _jt)) == null ? void 0 : _b.remove();
    __privateSet(this, _jt, null);
  }
};
_o2 = new WeakMap();
_Ut = new WeakMap();
_zt = new WeakMap();
_Gt = new WeakMap();
_$t = new WeakMap();
_Wt = new WeakMap();
_Vt = new WeakMap();
_jt = new WeakMap();
_a2 = new WeakMap();
_qt = new WeakMap();
_Xt = new WeakMap();
_Kt = new WeakMap();
_Yt = new WeakMap();
_AltText_instances = new WeakSet();
Qt_get = function() {
  return (__privateGet(this, _o2) ? "added" : null === __privateGet(this, _o2) && this.guessedText && "review") || "missing";
};
Jt_fn = async function() {
  var _a5, _b, _c;
  const t2 = __privateGet(this, _zt);
  if (!t2) return;
  if (__privateGet(this, _Kt)) {
    t2.classList.toggle("done", !!__privateGet(this, _o2));
    t2.setAttribute("data-l10n-id", __privateGet(_AltText, _Yt)[__privateGet(this, _AltText_instances, Qt_get)]);
    (_a5 = __privateGet(this, _Gt)) == null ? void 0 : _a5.setAttribute("data-l10n-id", __privateGet(_AltText, _Yt)[`${__privateGet(this, _AltText_instances, Qt_get)}-label`]);
    if (!__privateGet(this, _o2)) {
      (_b = __privateGet(this, _$t)) == null ? void 0 : _b.remove();
      return;
    }
  } else {
    if (!__privateGet(this, _o2) && !__privateGet(this, _Ut)) {
      t2.classList.remove("done");
      (_c = __privateGet(this, _$t)) == null ? void 0 : _c.remove();
      return;
    }
    t2.classList.add("done");
    t2.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-edit-button");
  }
  let e2 = __privateGet(this, _$t);
  if (!e2) {
    __privateSet(this, _$t, e2 = document.createElement("span"));
    e2.className = "tooltip";
    e2.setAttribute("role", "tooltip");
    e2.id = `alt-text-tooltip-${__privateGet(this, _a2).id}`;
    const i3 = 100, s2 = __privateGet(this, _a2)._uiManager._signal;
    s2.addEventListener("abort", () => {
      clearTimeout(__privateGet(this, _Wt));
      __privateSet(this, _Wt, null);
    }, { once: true });
    t2.addEventListener("mouseenter", () => {
      __privateSet(this, _Wt, setTimeout(() => {
        __privateSet(this, _Wt, null);
        __privateGet(this, _$t).classList.add("show");
        __privateGet(this, _a2)._reportTelemetry({ action: "alt_text_tooltip" });
      }, i3));
    }, { signal: s2 });
    t2.addEventListener("mouseleave", () => {
      var _a6;
      if (__privateGet(this, _Wt)) {
        clearTimeout(__privateGet(this, _Wt));
        __privateSet(this, _Wt, null);
      }
      (_a6 = __privateGet(this, _$t)) == null ? void 0 : _a6.classList.remove("show");
    }, { signal: s2 });
  }
  if (__privateGet(this, _Ut)) e2.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-decorative-tooltip");
  else {
    e2.removeAttribute("data-l10n-id");
    e2.textContent = __privateGet(this, _o2);
  }
  e2.parentNode || t2.append(e2);
  const i2 = __privateGet(this, _a2).getElementForAltText();
  i2 == null ? void 0 : i2.setAttribute("aria-describedby", e2.id);
};
__privateAdd(_AltText, _Yt, null);
__publicField(_AltText, "_l10n", null);
var AltText = _AltText;
var _mt2, _Zt, _te, _ee, _ie, _se, _ne, _ae, _re, _oe, _le, _he, _TouchManager_instances, de_fn, ce_fn, ue_fn;
var _TouchManager = class _TouchManager {
  constructor({ container: t2, isPinchingDisabled: e2 = null, isPinchingStopped: i2 = null, onPinchStart: s2 = null, onPinching: n2 = null, onPinchEnd: a2 = null, signal: r2 }) {
    __privateAdd(this, _TouchManager_instances);
    __privateAdd(this, _mt2);
    __privateAdd(this, _Zt, false);
    __privateAdd(this, _te, null);
    __privateAdd(this, _ee);
    __privateAdd(this, _ie);
    __privateAdd(this, _se);
    __privateAdd(this, _ne);
    __privateAdd(this, _ae, null);
    __privateAdd(this, _re);
    __privateAdd(this, _oe, null);
    __privateAdd(this, _le);
    __privateAdd(this, _he, null);
    __privateSet(this, _mt2, t2);
    __privateSet(this, _te, i2);
    __privateSet(this, _ee, e2);
    __privateSet(this, _ie, s2);
    __privateSet(this, _se, n2);
    __privateSet(this, _ne, a2);
    __privateSet(this, _le, new AbortController());
    __privateSet(this, _re, AbortSignal.any([r2, __privateGet(this, _le).signal]));
    t2.addEventListener("touchstart", __privateMethod(this, _TouchManager_instances, de_fn).bind(this), { passive: false, signal: __privateGet(this, _re) });
  }
  get MIN_TOUCH_DISTANCE_TO_PINCH() {
    return 35 / OutputScale.pixelRatio;
  }
  destroy() {
    var _a5, _b;
    (_a5 = __privateGet(this, _le)) == null ? void 0 : _a5.abort();
    __privateSet(this, _le, null);
    (_b = __privateGet(this, _ae)) == null ? void 0 : _b.abort();
    __privateSet(this, _ae, null);
  }
};
_mt2 = new WeakMap();
_Zt = new WeakMap();
_te = new WeakMap();
_ee = new WeakMap();
_ie = new WeakMap();
_se = new WeakMap();
_ne = new WeakMap();
_ae = new WeakMap();
_re = new WeakMap();
_oe = new WeakMap();
_le = new WeakMap();
_he = new WeakMap();
_TouchManager_instances = new WeakSet();
de_fn = function(t2) {
  var _a5, _b, _c;
  if ((_a5 = __privateGet(this, _ee)) == null ? void 0 : _a5.call(this)) return;
  if (1 === t2.touches.length) {
    if (__privateGet(this, _ae)) return;
    const t3 = __privateSet(this, _ae, new AbortController()), e3 = AbortSignal.any([__privateGet(this, _re), t3.signal]), i3 = __privateGet(this, _mt2), s2 = { capture: true, signal: e3, passive: false }, cancelPointerDown = (t4) => {
      var _a6;
      if ("touch" === t4.pointerType) {
        (_a6 = __privateGet(this, _ae)) == null ? void 0 : _a6.abort();
        __privateSet(this, _ae, null);
      }
    };
    i3.addEventListener("pointerdown", (t4) => {
      if ("touch" === t4.pointerType) {
        stopEvent(t4);
        cancelPointerDown(t4);
      }
    }, s2);
    i3.addEventListener("pointerup", cancelPointerDown, s2);
    i3.addEventListener("pointercancel", cancelPointerDown, s2);
    return;
  }
  if (!__privateGet(this, _he)) {
    __privateSet(this, _he, new AbortController());
    const t3 = AbortSignal.any([__privateGet(this, _re), __privateGet(this, _he).signal]), e3 = __privateGet(this, _mt2), i3 = { signal: t3, capture: false, passive: false };
    e3.addEventListener("touchmove", __privateMethod(this, _TouchManager_instances, ce_fn).bind(this), i3);
    const s2 = __privateMethod(this, _TouchManager_instances, ue_fn).bind(this);
    e3.addEventListener("touchend", s2, i3);
    e3.addEventListener("touchcancel", s2, i3);
    i3.capture = true;
    e3.addEventListener("pointerdown", stopEvent, i3);
    e3.addEventListener("pointermove", stopEvent, i3);
    e3.addEventListener("pointercancel", stopEvent, i3);
    e3.addEventListener("pointerup", stopEvent, i3);
    (_b = __privateGet(this, _ie)) == null ? void 0 : _b.call(this);
  }
  stopEvent(t2);
  if (2 !== t2.touches.length || ((_c = __privateGet(this, _te)) == null ? void 0 : _c.call(this))) {
    __privateSet(this, _oe, null);
    return;
  }
  let [e2, i2] = t2.touches;
  e2.identifier > i2.identifier && ([e2, i2] = [i2, e2]);
  __privateSet(this, _oe, { touch0X: e2.screenX, touch0Y: e2.screenY, touch1X: i2.screenX, touch1Y: i2.screenY });
};
ce_fn = function(t2) {
  var _a5;
  if (!__privateGet(this, _oe) || 2 !== t2.touches.length) return;
  stopEvent(t2);
  let [e2, i2] = t2.touches;
  e2.identifier > i2.identifier && ([e2, i2] = [i2, e2]);
  const { screenX: s2, screenY: n2 } = e2, { screenX: a2, screenY: r2 } = i2, o2 = __privateGet(this, _oe), { touch0X: l2, touch0Y: h2, touch1X: d2, touch1Y: c2 } = o2, u2 = d2 - l2, p2 = c2 - h2, g2 = a2 - s2, f2 = r2 - n2, m2 = Math.hypot(g2, f2) || 1, b2 = Math.hypot(u2, p2) || 1;
  if (!__privateGet(this, _Zt) && Math.abs(b2 - m2) <= _TouchManager.MIN_TOUCH_DISTANCE_TO_PINCH) return;
  o2.touch0X = s2;
  o2.touch0Y = n2;
  o2.touch1X = a2;
  o2.touch1Y = r2;
  if (!__privateGet(this, _Zt)) {
    __privateSet(this, _Zt, true);
    return;
  }
  const A2 = [(s2 + a2) / 2, (n2 + r2) / 2];
  (_a5 = __privateGet(this, _se)) == null ? void 0 : _a5.call(this, A2, b2, m2);
};
ue_fn = function(t2) {
  var _a5;
  if (!(t2.touches.length >= 2)) {
    if (__privateGet(this, _he)) {
      __privateGet(this, _he).abort();
      __privateSet(this, _he, null);
      (_a5 = __privateGet(this, _ne)) == null ? void 0 : _a5.call(this);
    }
    if (__privateGet(this, _oe)) {
      stopEvent(t2);
      __privateSet(this, _oe, null);
      __privateSet(this, _Zt, false);
    }
  }
};
var TouchManager = _TouchManager;
var _pe, _ge, _o3, _fe, _me, _be, _Ae, _we, _ye, _ve, _xe, _Ee, __e, _Se, _Ce, _Te, _Me, _De, _Pe, _ke, _Ie, _Re, _Fe, _Le, _AnnotationEditor_instances, Ne_fn, _AnnotationEditor_static, Be_fn, He_fn, Ue_fn, ze_fn, We_fn, $e_fn, Ge_fn, je_fn, qe_fn, Xe_fn, Ye_fn, Ke_fn, Ve_fn, Qe_fn, Je_fn, Ze_fn, ti_fn, Oe_fn;
var _AnnotationEditor = class _AnnotationEditor {
  constructor(t2) {
    __privateAdd(this, _AnnotationEditor_instances);
    __privateAdd(this, _pe, null);
    __privateAdd(this, _ge, null);
    __privateAdd(this, _o3, null);
    __privateAdd(this, _fe, false);
    __privateAdd(this, _me, null);
    __privateAdd(this, _be, "");
    __privateAdd(this, _Ae, false);
    __privateAdd(this, _we, null);
    __privateAdd(this, _ye, null);
    __privateAdd(this, _ve, null);
    __privateAdd(this, _xe, null);
    __privateAdd(this, _Ee, "");
    __privateAdd(this, __e, false);
    __privateAdd(this, _Se, null);
    __privateAdd(this, _Ce, false);
    __privateAdd(this, _Te, false);
    __privateAdd(this, _Me, false);
    __privateAdd(this, _De, null);
    __privateAdd(this, _Pe, 0);
    __privateAdd(this, _ke, 0);
    __privateAdd(this, _Ie, null);
    __privateAdd(this, _Re, null);
    __publicField(this, "isSelected", false);
    __publicField(this, "_isCopy", false);
    __publicField(this, "_editToolbar", null);
    __publicField(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
    __publicField(this, "_initialData", null);
    __publicField(this, "_isVisible", true);
    __publicField(this, "_uiManager", null);
    __publicField(this, "_focusEventsAllowed", true);
    __privateAdd(this, _Fe, false);
    __privateAdd(this, _Le, _AnnotationEditor._zIndex++);
    this.parent = t2.parent;
    this.id = t2.id;
    this.width = this.height = null;
    this.pageIndex = t2.parent.pageIndex;
    this.name = t2.name;
    this.div = null;
    this._uiManager = t2.uiManager;
    this.annotationElementId = null;
    this._willKeepAspectRatio = false;
    this._initialOptions.isCentered = t2.isCentered;
    this._structTreeParentId = null;
    const { rotation: e2, rawDims: { pageWidth: i2, pageHeight: s2, pageX: n2, pageY: a2 } } = this.parent.viewport;
    this.rotation = e2;
    this.pageRotation = (360 + e2 - this._uiManager.viewParameters.rotation) % 360;
    this.pageDimensions = [i2, s2];
    this.pageTranslation = [n2, a2];
    const [r2, o2] = this.parentDimensions;
    this.x = t2.x / r2;
    this.y = t2.y / o2;
    this.isAttachedToDOM = false;
    this.deleted = false;
  }
  static get _resizerKeyboardManager() {
    const t2 = _AnnotationEditor.prototype._resizeWithKeyboard, e2 = AnnotationEditorUIManager.TRANSLATE_SMALL, i2 = AnnotationEditorUIManager.TRANSLATE_BIG;
    return shadow(this, "_resizerKeyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], t2, { args: [-e2, 0] }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], t2, { args: [-i2, 0] }], [["ArrowRight", "mac+ArrowRight"], t2, { args: [e2, 0] }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], t2, { args: [i2, 0] }], [["ArrowUp", "mac+ArrowUp"], t2, { args: [0, -e2] }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], t2, { args: [0, -i2] }], [["ArrowDown", "mac+ArrowDown"], t2, { args: [0, e2] }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], t2, { args: [0, i2] }], [["Escape", "mac+Escape"], _AnnotationEditor.prototype._stopResizingWithKeyboard]]));
  }
  get editorType() {
    return Object.getPrototypeOf(this).constructor._type;
  }
  static get isDrawer() {
    return false;
  }
  static get _defaultLineColor() {
    return shadow(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
  }
  static deleteAnnotationElement(t2) {
    const e2 = new FakeEditor({ id: t2.parent.getNextId(), parent: t2.parent, uiManager: t2._uiManager });
    e2.annotationElementId = t2.annotationElementId;
    e2.deleted = true;
    e2._uiManager.addToAnnotationStorage(e2);
  }
  static initialize(t2, e2) {
    _AnnotationEditor._l10n ?? (_AnnotationEditor._l10n = t2);
    _AnnotationEditor._l10nResizer || (_AnnotationEditor._l10nResizer = Object.freeze({ topLeft: "pdfjs-editor-resizer-top-left", topMiddle: "pdfjs-editor-resizer-top-middle", topRight: "pdfjs-editor-resizer-top-right", middleRight: "pdfjs-editor-resizer-middle-right", bottomRight: "pdfjs-editor-resizer-bottom-right", bottomMiddle: "pdfjs-editor-resizer-bottom-middle", bottomLeft: "pdfjs-editor-resizer-bottom-left", middleLeft: "pdfjs-editor-resizer-middle-left" }));
    if (-1 !== _AnnotationEditor._borderLineWidth) return;
    const i2 = getComputedStyle(document.documentElement);
    _AnnotationEditor._borderLineWidth = parseFloat(i2.getPropertyValue("--outline-width")) || 0;
  }
  static updateDefaultParams(t2, e2) {
  }
  static get defaultPropertiesToUpdate() {
    return [];
  }
  static isHandlingMimeForPasting(t2) {
    return false;
  }
  static paste(t2, e2) {
    unreachable("Not implemented");
  }
  get propertiesToUpdate() {
    return [];
  }
  get _isDraggable() {
    return __privateGet(this, _Fe);
  }
  set _isDraggable(t2) {
    var _a5;
    __privateSet(this, _Fe, t2);
    (_a5 = this.div) == null ? void 0 : _a5.classList.toggle("draggable", t2);
  }
  get isEnterHandled() {
    return true;
  }
  center() {
    const [t2, e2] = this.pageDimensions;
    switch (this.parentRotation) {
      case 90:
        this.x -= this.height * e2 / (2 * t2);
        this.y += this.width * t2 / (2 * e2);
        break;
      case 180:
        this.x += this.width / 2;
        this.y += this.height / 2;
        break;
      case 270:
        this.x += this.height * e2 / (2 * t2);
        this.y -= this.width * t2 / (2 * e2);
        break;
      default:
        this.x -= this.width / 2;
        this.y -= this.height / 2;
    }
    this.fixAndSetPosition();
  }
  addCommands(t2) {
    this._uiManager.addCommands(t2);
  }
  get currentLayer() {
    return this._uiManager.currentLayer;
  }
  setInBackground() {
    this.div.style.zIndex = 0;
  }
  setInForeground() {
    this.div.style.zIndex = __privateGet(this, _Le);
  }
  setParent(t2) {
    if (null !== t2) {
      this.pageIndex = t2.pageIndex;
      this.pageDimensions = t2.pageDimensions;
    } else __privateMethod(this, _AnnotationEditor_instances, Oe_fn).call(this);
    this.parent = t2;
  }
  focusin(t2) {
    this._focusEventsAllowed && (__privateGet(this, __e) ? __privateSet(this, __e, false) : this.parent.setSelected(this));
  }
  focusout(t2) {
    var _a5;
    if (!this._focusEventsAllowed) return;
    if (!this.isAttachedToDOM) return;
    const e2 = t2.relatedTarget;
    if (!(e2 == null ? void 0 : e2.closest(`#${this.id}`))) {
      t2.preventDefault();
      ((_a5 = this.parent) == null ? void 0 : _a5.isMultipleSelection) || this.commitOrRemove();
    }
  }
  commitOrRemove() {
    this.isEmpty() ? this.remove() : this.commit();
  }
  commit() {
    this.addToAnnotationStorage();
  }
  addToAnnotationStorage() {
    this._uiManager.addToAnnotationStorage(this);
  }
  setAt(t2, e2, i2, s2) {
    const [n2, a2] = this.parentDimensions;
    [i2, s2] = this.screenToPageTranslation(i2, s2);
    this.x = (t2 + i2) / n2;
    this.y = (e2 + s2) / a2;
    this.fixAndSetPosition();
  }
  _moveAfterPaste(t2, e2) {
    const [i2, s2] = this.parentDimensions;
    this.setAt(t2 * i2, e2 * s2, this.width * i2, this.height * s2);
    this._onTranslated();
  }
  translate(t2, e2) {
    __privateMethod(this, _AnnotationEditor_instances, Ne_fn).call(this, this.parentDimensions, t2, e2);
  }
  translateInPage(t2, e2) {
    __privateGet(this, _Se) || __privateSet(this, _Se, [this.x, this.y, this.width, this.height]);
    __privateMethod(this, _AnnotationEditor_instances, Ne_fn).call(this, this.pageDimensions, t2, e2);
    this.div.scrollIntoView({ block: "nearest" });
  }
  translationDone() {
    this._onTranslated(this.x, this.y);
  }
  drag(t2, e2) {
    __privateGet(this, _Se) || __privateSet(this, _Se, [this.x, this.y, this.width, this.height]);
    const { div: i2, parentDimensions: [s2, n2] } = this;
    this.x += t2 / s2;
    this.y += e2 / n2;
    if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
      const { x: t3, y: e3 } = this.div.getBoundingClientRect();
      if (this.parent.findNewParent(this, t3, e3)) {
        this.x -= Math.floor(this.x);
        this.y -= Math.floor(this.y);
      }
    }
    let { x: a2, y: r2 } = this;
    const [o2, l2] = this.getBaseTranslation();
    a2 += o2;
    r2 += l2;
    const { style: h2 } = i2;
    h2.left = `${(100 * a2).toFixed(2)}%`;
    h2.top = `${(100 * r2).toFixed(2)}%`;
    this._onTranslating(a2, r2);
    i2.scrollIntoView({ block: "nearest" });
  }
  _onTranslating(t2, e2) {
  }
  _onTranslated(t2, e2) {
  }
  get _hasBeenMoved() {
    return !!__privateGet(this, _Se) && (__privateGet(this, _Se)[0] !== this.x || __privateGet(this, _Se)[1] !== this.y);
  }
  get _hasBeenResized() {
    return !!__privateGet(this, _Se) && (__privateGet(this, _Se)[2] !== this.width || __privateGet(this, _Se)[3] !== this.height);
  }
  getBaseTranslation() {
    const [t2, e2] = this.parentDimensions, { _borderLineWidth: i2 } = _AnnotationEditor, s2 = i2 / t2, n2 = i2 / e2;
    switch (this.rotation) {
      case 90:
        return [-s2, n2];
      case 180:
        return [s2, n2];
      case 270:
        return [s2, -n2];
      default:
        return [-s2, -n2];
    }
  }
  get _mustFixPosition() {
    return true;
  }
  fixAndSetPosition(t2 = this.rotation) {
    const { div: { style: e2 }, pageDimensions: [i2, s2] } = this;
    let { x: n2, y: a2, width: r2, height: o2 } = this;
    r2 *= i2;
    o2 *= s2;
    n2 *= i2;
    a2 *= s2;
    if (this._mustFixPosition) switch (t2) {
      case 0:
        n2 = MathClamp(n2, 0, i2 - r2);
        a2 = MathClamp(a2, 0, s2 - o2);
        break;
      case 90:
        n2 = MathClamp(n2, 0, i2 - o2);
        a2 = MathClamp(a2, r2, s2);
        break;
      case 180:
        n2 = MathClamp(n2, r2, i2);
        a2 = MathClamp(a2, o2, s2);
        break;
      case 270:
        n2 = MathClamp(n2, o2, i2);
        a2 = MathClamp(a2, 0, s2 - r2);
    }
    this.x = n2 /= i2;
    this.y = a2 /= s2;
    const [l2, h2] = this.getBaseTranslation();
    n2 += l2;
    a2 += h2;
    e2.left = `${(100 * n2).toFixed(2)}%`;
    e2.top = `${(100 * a2).toFixed(2)}%`;
    this.moveInDOM();
  }
  screenToPageTranslation(t2, e2) {
    var _a5;
    return __privateMethod(_a5 = _AnnotationEditor, _AnnotationEditor_static, Be_fn).call(_a5, t2, e2, this.parentRotation);
  }
  pageTranslationToScreen(t2, e2) {
    var _a5;
    return __privateMethod(_a5 = _AnnotationEditor, _AnnotationEditor_static, Be_fn).call(_a5, t2, e2, 360 - this.parentRotation);
  }
  get parentScale() {
    return this._uiManager.viewParameters.realScale;
  }
  get parentRotation() {
    return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
  }
  get parentDimensions() {
    const { parentScale: t2, pageDimensions: [e2, i2] } = this;
    return [e2 * t2, i2 * t2];
  }
  setDims(t2, e2) {
    const [i2, s2] = this.parentDimensions, { style: n2 } = this.div;
    n2.width = `${(100 * t2 / i2).toFixed(2)}%`;
    __privateGet(this, _Ae) || (n2.height = `${(100 * e2 / s2).toFixed(2)}%`);
  }
  fixDims() {
    const { style: t2 } = this.div, { height: e2, width: i2 } = t2, s2 = i2.endsWith("%"), n2 = !__privateGet(this, _Ae) && e2.endsWith("%");
    if (s2 && n2) return;
    const [a2, r2] = this.parentDimensions;
    s2 || (t2.width = `${(100 * parseFloat(i2) / a2).toFixed(2)}%`);
    __privateGet(this, _Ae) || n2 || (t2.height = `${(100 * parseFloat(e2) / r2).toFixed(2)}%`);
  }
  getInitialTranslation() {
    return [0, 0];
  }
  _onResized() {
  }
  static _round(t2) {
    return Math.round(1e4 * t2) / 1e4;
  }
  _onResizing() {
  }
  altTextFinish() {
    var _a5;
    (_a5 = __privateGet(this, _o3)) == null ? void 0 : _a5.finish();
  }
  async addEditToolbar() {
    if (this._editToolbar || __privateGet(this, _Te)) return this._editToolbar;
    this._editToolbar = new EditorToolbar(this);
    this.div.append(this._editToolbar.render());
    __privateGet(this, _o3) && await this._editToolbar.addAltText(__privateGet(this, _o3));
    return this._editToolbar;
  }
  removeEditToolbar() {
    var _a5;
    if (this._editToolbar) {
      this._editToolbar.remove();
      this._editToolbar = null;
      (_a5 = __privateGet(this, _o3)) == null ? void 0 : _a5.destroy();
    }
  }
  addContainer(t2) {
    var _a5;
    const e2 = (_a5 = this._editToolbar) == null ? void 0 : _a5.div;
    e2 ? e2.before(t2) : this.div.append(t2);
  }
  getClientDimensions() {
    return this.div.getBoundingClientRect();
  }
  async addAltTextButton() {
    if (!__privateGet(this, _o3)) {
      AltText.initialize(_AnnotationEditor._l10n);
      __privateSet(this, _o3, new AltText(this));
      if (__privateGet(this, _pe)) {
        __privateGet(this, _o3).data = __privateGet(this, _pe);
        __privateSet(this, _pe, null);
      }
      await this.addEditToolbar();
    }
  }
  get altTextData() {
    var _a5;
    return (_a5 = __privateGet(this, _o3)) == null ? void 0 : _a5.data;
  }
  set altTextData(t2) {
    __privateGet(this, _o3) && (__privateGet(this, _o3).data = t2);
  }
  get guessedAltText() {
    var _a5;
    return (_a5 = __privateGet(this, _o3)) == null ? void 0 : _a5.guessedText;
  }
  async setGuessedAltText(t2) {
    var _a5;
    await ((_a5 = __privateGet(this, _o3)) == null ? void 0 : _a5.setGuessedText(t2));
  }
  serializeAltText(t2) {
    var _a5;
    return (_a5 = __privateGet(this, _o3)) == null ? void 0 : _a5.serialize(t2);
  }
  hasAltText() {
    return !!__privateGet(this, _o3) && !__privateGet(this, _o3).isEmpty();
  }
  hasAltTextData() {
    var _a5;
    return ((_a5 = __privateGet(this, _o3)) == null ? void 0 : _a5.hasData()) ?? false;
  }
  render() {
    var _a5;
    const t2 = this.div = document.createElement("div");
    t2.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
    t2.className = this.name;
    t2.setAttribute("id", this.id);
    t2.tabIndex = __privateGet(this, _fe) ? -1 : 0;
    t2.setAttribute("role", "application");
    this.defaultL10nId && t2.setAttribute("data-l10n-id", this.defaultL10nId);
    this._isVisible || t2.classList.add("hidden");
    this.setInForeground();
    __privateMethod(this, _AnnotationEditor_instances, Ve_fn).call(this);
    const [e2, i2] = this.parentDimensions;
    if (this.parentRotation % 180 != 0) {
      t2.style.maxWidth = `${(100 * i2 / e2).toFixed(2)}%`;
      t2.style.maxHeight = `${(100 * e2 / i2).toFixed(2)}%`;
    }
    const [s2, n2] = this.getInitialTranslation();
    this.translate(s2, n2);
    bindEvents(this, t2, ["keydown", "pointerdown", "dblclick"]);
    this.isResizable && this._uiManager._supportsPinchToZoom && (__privateGet(this, _Re) || __privateSet(this, _Re, new TouchManager({ container: t2, isPinchingDisabled: () => !this.isSelected, onPinchStart: __privateMethod(this, _AnnotationEditor_instances, je_fn).bind(this), onPinching: __privateMethod(this, _AnnotationEditor_instances, qe_fn).bind(this), onPinchEnd: __privateMethod(this, _AnnotationEditor_instances, Xe_fn).bind(this), signal: this._uiManager._signal })));
    (_a5 = this._uiManager._editorUndoBar) == null ? void 0 : _a5.hide();
    return t2;
  }
  pointerdown(t2) {
    const { isMac: e2 } = util_FeatureTest.platform;
    if (0 !== t2.button || t2.ctrlKey && e2) t2.preventDefault();
    else {
      __privateSet(this, __e, true);
      this._isDraggable ? __privateMethod(this, _AnnotationEditor_instances, Ke_fn).call(this, t2) : __privateMethod(this, _AnnotationEditor_instances, Ye_fn).call(this, t2);
    }
  }
  _onStartDragging() {
  }
  _onStopDragging() {
  }
  moveInDOM() {
    __privateGet(this, _De) && clearTimeout(__privateGet(this, _De));
    __privateSet(this, _De, setTimeout(() => {
      var _a5;
      __privateSet(this, _De, null);
      (_a5 = this.parent) == null ? void 0 : _a5.moveEditorInDOM(this);
    }, 0));
  }
  _setParentAndPosition(t2, e2, i2) {
    t2.changeParent(this);
    this.x = e2;
    this.y = i2;
    this.fixAndSetPosition();
    this._onTranslated();
  }
  getRect(t2, e2, i2 = this.rotation) {
    const s2 = this.parentScale, [n2, a2] = this.pageDimensions, [r2, o2] = this.pageTranslation, l2 = t2 / s2, h2 = e2 / s2, d2 = this.x * n2, c2 = this.y * a2, u2 = this.width * n2, p2 = this.height * a2;
    switch (i2) {
      case 0:
        return [d2 + l2 + r2, a2 - c2 - h2 - p2 + o2, d2 + l2 + u2 + r2, a2 - c2 - h2 + o2];
      case 90:
        return [d2 + h2 + r2, a2 - c2 + l2 + o2, d2 + h2 + p2 + r2, a2 - c2 + l2 + u2 + o2];
      case 180:
        return [d2 - l2 - u2 + r2, a2 - c2 + h2 + o2, d2 - l2 + r2, a2 - c2 + h2 + p2 + o2];
      case 270:
        return [d2 - h2 - p2 + r2, a2 - c2 - l2 - u2 + o2, d2 - h2 + r2, a2 - c2 - l2 + o2];
      default:
        throw new Error("Invalid rotation");
    }
  }
  getRectInCurrentCoords(t2, e2) {
    const [i2, s2, n2, a2] = t2, r2 = n2 - i2, o2 = a2 - s2;
    switch (this.rotation) {
      case 0:
        return [i2, e2 - a2, r2, o2];
      case 90:
        return [i2, e2 - s2, o2, r2];
      case 180:
        return [n2, e2 - s2, r2, o2];
      case 270:
        return [n2, e2 - a2, o2, r2];
      default:
        throw new Error("Invalid rotation");
    }
  }
  onceAdded(t2) {
  }
  isEmpty() {
    return false;
  }
  enableEditMode() {
    if (this.isInEditMode()) return false;
    this.parent.setEditingState(false);
    __privateSet(this, _Te, true);
    return true;
  }
  disableEditMode() {
    if (!this.isInEditMode()) return false;
    this.parent.setEditingState(true);
    __privateSet(this, _Te, false);
    return true;
  }
  isInEditMode() {
    return __privateGet(this, _Te);
  }
  shouldGetKeyboardEvents() {
    return __privateGet(this, _Me);
  }
  needsToBeRebuilt() {
    return this.div && !this.isAttachedToDOM;
  }
  get isOnScreen() {
    const { top: t2, left: e2, bottom: i2, right: s2 } = this.getClientDimensions(), { innerHeight: n2, innerWidth: a2 } = window;
    return e2 < a2 && s2 > 0 && t2 < n2 && i2 > 0;
  }
  rebuild() {
    __privateMethod(this, _AnnotationEditor_instances, Ve_fn).call(this);
  }
  rotate(t2) {
  }
  resize() {
  }
  serializeDeleted() {
    var _a5;
    return { id: this.annotationElementId, deleted: true, pageIndex: this.pageIndex, popupRef: ((_a5 = this._initialData) == null ? void 0 : _a5.popupRef) || "" };
  }
  serialize(t2 = false, e2 = null) {
    unreachable("An editor must be serializable");
  }
  static async deserialize(t2, e2, i2) {
    const s2 = new this.prototype.constructor({ parent: e2, id: e2.getNextId(), uiManager: i2 });
    s2.rotation = t2.rotation;
    __privateSet(s2, _pe, t2.accessibilityData);
    s2._isCopy = t2.isCopy || false;
    const [n2, a2] = s2.pageDimensions, [r2, o2, l2, h2] = s2.getRectInCurrentCoords(t2.rect, a2);
    s2.x = r2 / n2;
    s2.y = o2 / a2;
    s2.width = l2 / n2;
    s2.height = h2 / a2;
    return s2;
  }
  get hasBeenModified() {
    return !!this.annotationElementId && (this.deleted || null !== this.serialize());
  }
  remove() {
    var _a5, _b;
    (_a5 = __privateGet(this, _xe)) == null ? void 0 : _a5.abort();
    __privateSet(this, _xe, null);
    this.isEmpty() || this.commit();
    this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this);
    if (__privateGet(this, _De)) {
      clearTimeout(__privateGet(this, _De));
      __privateSet(this, _De, null);
    }
    __privateMethod(this, _AnnotationEditor_instances, Oe_fn).call(this);
    this.removeEditToolbar();
    if (__privateGet(this, _Ie)) {
      for (const t2 of __privateGet(this, _Ie).values()) clearTimeout(t2);
      __privateSet(this, _Ie, null);
    }
    this.parent = null;
    (_b = __privateGet(this, _Re)) == null ? void 0 : _b.destroy();
    __privateSet(this, _Re, null);
  }
  get isResizable() {
    return false;
  }
  makeResizable() {
    if (this.isResizable) {
      __privateMethod(this, _AnnotationEditor_instances, Ue_fn).call(this);
      __privateGet(this, _we).classList.remove("hidden");
    }
  }
  get toolbarPosition() {
    return null;
  }
  keydown(t2) {
    if (!this.isResizable || t2.target !== this.div || "Enter" !== t2.key) return;
    this._uiManager.setSelected(this);
    __privateSet(this, _ve, { savedX: this.x, savedY: this.y, savedWidth: this.width, savedHeight: this.height });
    const e2 = __privateGet(this, _we).children;
    if (!__privateGet(this, _ge)) {
      __privateSet(this, _ge, Array.from(e2));
      const t3 = __privateMethod(this, _AnnotationEditor_instances, Qe_fn).bind(this), i3 = __privateMethod(this, _AnnotationEditor_instances, Je_fn).bind(this), s3 = this._uiManager._signal;
      for (const e3 of __privateGet(this, _ge)) {
        const n3 = e3.getAttribute("data-resizer-name");
        e3.setAttribute("role", "spinbutton");
        e3.addEventListener("keydown", t3, { signal: s3 });
        e3.addEventListener("blur", i3, { signal: s3 });
        e3.addEventListener("focus", __privateMethod(this, _AnnotationEditor_instances, Ze_fn).bind(this, n3), { signal: s3 });
        e3.setAttribute("data-l10n-id", _AnnotationEditor._l10nResizer[n3]);
      }
    }
    const i2 = __privateGet(this, _ge)[0];
    let s2 = 0;
    for (const t3 of e2) {
      if (t3 === i2) break;
      s2++;
    }
    const n2 = (360 - this.rotation + this.parentRotation) % 360 / 90 * (__privateGet(this, _ge).length / 4);
    if (n2 !== s2) {
      if (n2 < s2) for (let t4 = 0; t4 < s2 - n2; t4++) __privateGet(this, _we).append(__privateGet(this, _we).firstChild);
      else if (n2 > s2) for (let t4 = 0; t4 < n2 - s2; t4++) __privateGet(this, _we).firstChild.before(__privateGet(this, _we).lastChild);
      let t3 = 0;
      for (const i3 of e2) {
        const e3 = __privateGet(this, _ge)[t3++].getAttribute("data-resizer-name");
        i3.setAttribute("data-l10n-id", _AnnotationEditor._l10nResizer[e3]);
      }
    }
    __privateMethod(this, _AnnotationEditor_instances, ti_fn).call(this, 0);
    __privateSet(this, _Me, true);
    __privateGet(this, _we).firstChild.focus({ focusVisible: true });
    t2.preventDefault();
    t2.stopImmediatePropagation();
  }
  _resizeWithKeyboard(t2, e2) {
    __privateGet(this, _Me) && __privateMethod(this, _AnnotationEditor_instances, Ge_fn).call(this, __privateGet(this, _Ee), { deltaX: t2, deltaY: e2, fromKeyboard: true });
  }
  _stopResizingWithKeyboard() {
    __privateMethod(this, _AnnotationEditor_instances, Oe_fn).call(this);
    this.div.focus();
  }
  select() {
    var _a5, _b, _c;
    if (!this.isSelected || !this._editToolbar) {
      this.isSelected = true;
      this.makeResizable();
      (_a5 = this.div) == null ? void 0 : _a5.classList.add("selectedEditor");
      if (this._editToolbar) {
        (_b = this._editToolbar) == null ? void 0 : _b.show();
        (_c = __privateGet(this, _o3)) == null ? void 0 : _c.toggleAltTextBadge(false);
      } else this.addEditToolbar().then(() => {
        var _a6, _b2;
        ((_a6 = this.div) == null ? void 0 : _a6.classList.contains("selectedEditor")) && ((_b2 = this._editToolbar) == null ? void 0 : _b2.show());
      });
    }
  }
  unselect() {
    var _a5, _b, _c, _d, _e;
    if (this.isSelected) {
      this.isSelected = false;
      (_a5 = __privateGet(this, _we)) == null ? void 0 : _a5.classList.add("hidden");
      (_b = this.div) == null ? void 0 : _b.classList.remove("selectedEditor");
      ((_c = this.div) == null ? void 0 : _c.contains(document.activeElement)) && this._uiManager.currentLayer.div.focus({ preventScroll: true });
      (_d = this._editToolbar) == null ? void 0 : _d.hide();
      (_e = __privateGet(this, _o3)) == null ? void 0 : _e.toggleAltTextBadge(true);
    }
  }
  updateParams(t2, e2) {
  }
  disableEditing() {
  }
  enableEditing() {
  }
  get canChangeContent() {
    return false;
  }
  enterInEditMode() {
    if (this.canChangeContent) {
      this.enableEditMode();
      this.div.focus();
    }
  }
  dblclick(t2) {
    this.enterInEditMode();
    this.parent.updateToolbar({ mode: this.constructor._editorType, editId: this.id });
  }
  getElementForAltText() {
    return this.div;
  }
  get contentDiv() {
    return this.div;
  }
  get isEditing() {
    return __privateGet(this, _Ce);
  }
  set isEditing(t2) {
    __privateSet(this, _Ce, t2);
    if (this.parent) if (t2) {
      this.parent.setSelected(this);
      this.parent.setActiveEditor(this);
    } else this.parent.setActiveEditor(null);
  }
  setAspectRatio(t2, e2) {
    __privateSet(this, _Ae, true);
    const i2 = t2 / e2, { style: s2 } = this.div;
    s2.aspectRatio = i2;
    s2.height = "auto";
  }
  static get MIN_SIZE() {
    return 16;
  }
  static canCreateNewEmptyEditor() {
    return true;
  }
  get telemetryInitialData() {
    return { action: "added" };
  }
  get telemetryFinalData() {
    return null;
  }
  _reportTelemetry(t2, e2 = false) {
    if (e2) {
      __privateGet(this, _Ie) || __privateSet(this, _Ie, /* @__PURE__ */ new Map());
      const { action: e3 } = t2;
      let i2 = __privateGet(this, _Ie).get(e3);
      i2 && clearTimeout(i2);
      i2 = setTimeout(() => {
        this._reportTelemetry(t2);
        __privateGet(this, _Ie).delete(e3);
        0 === __privateGet(this, _Ie).size && __privateSet(this, _Ie, null);
      }, _AnnotationEditor._telemetryTimeout);
      __privateGet(this, _Ie).set(e3, i2);
    } else {
      t2.type || (t2.type = this.editorType);
      this._uiManager._eventBus.dispatch("reporttelemetry", { source: this, details: { type: "editing", data: t2 } });
    }
  }
  show(t2 = this._isVisible) {
    this.div.classList.toggle("hidden", !t2);
    this._isVisible = t2;
  }
  enable() {
    this.div && (this.div.tabIndex = 0);
    __privateSet(this, _fe, false);
  }
  disable() {
    this.div && (this.div.tabIndex = -1);
    __privateSet(this, _fe, true);
  }
  renderAnnotationElement(t2) {
    let e2 = t2.container.querySelector(".annotationContent");
    if (e2) {
      if ("CANVAS" === e2.nodeName) {
        const t3 = e2;
        e2 = document.createElement("div");
        e2.classList.add("annotationContent", this.editorType);
        t3.before(e2);
      }
    } else {
      e2 = document.createElement("div");
      e2.classList.add("annotationContent", this.editorType);
      t2.container.prepend(e2);
    }
    return e2;
  }
  resetAnnotationElement(t2) {
    const { firstChild: e2 } = t2.container;
    "DIV" === (e2 == null ? void 0 : e2.nodeName) && e2.classList.contains("annotationContent") && e2.remove();
  }
};
_pe = new WeakMap();
_ge = new WeakMap();
_o3 = new WeakMap();
_fe = new WeakMap();
_me = new WeakMap();
_be = new WeakMap();
_Ae = new WeakMap();
_we = new WeakMap();
_ye = new WeakMap();
_ve = new WeakMap();
_xe = new WeakMap();
_Ee = new WeakMap();
__e = new WeakMap();
_Se = new WeakMap();
_Ce = new WeakMap();
_Te = new WeakMap();
_Me = new WeakMap();
_De = new WeakMap();
_Pe = new WeakMap();
_ke = new WeakMap();
_Ie = new WeakMap();
_Re = new WeakMap();
_Fe = new WeakMap();
_Le = new WeakMap();
_AnnotationEditor_instances = new WeakSet();
Ne_fn = function([t2, e2], i2, s2) {
  [i2, s2] = this.screenToPageTranslation(i2, s2);
  this.x += i2 / t2;
  this.y += s2 / e2;
  this._onTranslating(this.x, this.y);
  this.fixAndSetPosition();
};
_AnnotationEditor_static = new WeakSet();
Be_fn = function(t2, e2, i2) {
  switch (i2) {
    case 90:
      return [e2, -t2];
    case 180:
      return [-t2, -e2];
    case 270:
      return [-e2, t2];
    default:
      return [t2, e2];
  }
};
He_fn = function(t2) {
  switch (t2) {
    case 90: {
      const [t3, e2] = this.pageDimensions;
      return [0, -t3 / e2, e2 / t3, 0];
    }
    case 180:
      return [-1, 0, 0, -1];
    case 270: {
      const [t3, e2] = this.pageDimensions;
      return [0, t3 / e2, -e2 / t3, 0];
    }
    default:
      return [1, 0, 0, 1];
  }
};
Ue_fn = function() {
  if (__privateGet(this, _we)) return;
  __privateSet(this, _we, document.createElement("div"));
  __privateGet(this, _we).classList.add("resizers");
  const t2 = this._willKeepAspectRatio ? ["topLeft", "topRight", "bottomRight", "bottomLeft"] : ["topLeft", "topMiddle", "topRight", "middleRight", "bottomRight", "bottomMiddle", "bottomLeft", "middleLeft"], e2 = this._uiManager._signal;
  for (const i2 of t2) {
    const t3 = document.createElement("div");
    __privateGet(this, _we).append(t3);
    t3.classList.add("resizer", i2);
    t3.setAttribute("data-resizer-name", i2);
    t3.addEventListener("pointerdown", __privateMethod(this, _AnnotationEditor_instances, ze_fn).bind(this, i2), { signal: e2 });
    t3.addEventListener("contextmenu", noContextMenu, { signal: e2 });
    t3.tabIndex = -1;
  }
  this.div.prepend(__privateGet(this, _we));
};
ze_fn = function(t2, e2) {
  var _a5;
  e2.preventDefault();
  const { isMac: i2 } = util_FeatureTest.platform;
  if (0 !== e2.button || e2.ctrlKey && i2) return;
  (_a5 = __privateGet(this, _o3)) == null ? void 0 : _a5.toggle(false);
  const s2 = this._isDraggable;
  this._isDraggable = false;
  __privateSet(this, _ye, [e2.screenX, e2.screenY]);
  const n2 = new AbortController(), a2 = this._uiManager.combinedSignal(n2);
  this.parent.togglePointerEvents(false);
  window.addEventListener("pointermove", __privateMethod(this, _AnnotationEditor_instances, Ge_fn).bind(this, t2), { passive: true, capture: true, signal: a2 });
  window.addEventListener("touchmove", stopEvent, { passive: false, signal: a2 });
  window.addEventListener("contextmenu", noContextMenu, { signal: a2 });
  __privateSet(this, _ve, { savedX: this.x, savedY: this.y, savedWidth: this.width, savedHeight: this.height });
  const r2 = this.parent.div.style.cursor, o2 = this.div.style.cursor;
  this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(e2.target).cursor;
  const pointerUpCallback = () => {
    var _a6;
    n2.abort();
    this.parent.togglePointerEvents(true);
    (_a6 = __privateGet(this, _o3)) == null ? void 0 : _a6.toggle(true);
    this._isDraggable = s2;
    this.parent.div.style.cursor = r2;
    this.div.style.cursor = o2;
    __privateMethod(this, _AnnotationEditor_instances, $e_fn).call(this);
  };
  window.addEventListener("pointerup", pointerUpCallback, { signal: a2 });
  window.addEventListener("blur", pointerUpCallback, { signal: a2 });
};
We_fn = function(t2, e2, i2, s2) {
  this.width = i2;
  this.height = s2;
  this.x = t2;
  this.y = e2;
  const [n2, a2] = this.parentDimensions;
  this.setDims(n2 * i2, a2 * s2);
  this.fixAndSetPosition();
  this._onResized();
};
$e_fn = function() {
  if (!__privateGet(this, _ve)) return;
  const { savedX: t2, savedY: e2, savedWidth: i2, savedHeight: s2 } = __privateGet(this, _ve);
  __privateSet(this, _ve, null);
  const n2 = this.x, a2 = this.y, r2 = this.width, o2 = this.height;
  n2 === t2 && a2 === e2 && r2 === i2 && o2 === s2 || this.addCommands({ cmd: __privateMethod(this, _AnnotationEditor_instances, We_fn).bind(this, n2, a2, r2, o2), undo: __privateMethod(this, _AnnotationEditor_instances, We_fn).bind(this, t2, e2, i2, s2), mustExec: true });
};
Ge_fn = function(t2, e2) {
  const [i2, s2] = this.parentDimensions, n2 = this.x, a2 = this.y, r2 = this.width, o2 = this.height, l2 = _AnnotationEditor.MIN_SIZE / i2, h2 = _AnnotationEditor.MIN_SIZE / s2, d2 = __privateMethod(this, _AnnotationEditor_instances, He_fn).call(this, this.rotation), transf = (t3, e3) => [d2[0] * t3 + d2[2] * e3, d2[1] * t3 + d2[3] * e3], c2 = __privateMethod(this, _AnnotationEditor_instances, He_fn).call(this, 360 - this.rotation);
  let u2, p2, g2 = false, f2 = false;
  switch (t2) {
    case "topLeft":
      g2 = true;
      u2 = (t3, e3) => [0, 0];
      p2 = (t3, e3) => [t3, e3];
      break;
    case "topMiddle":
      u2 = (t3, e3) => [t3 / 2, 0];
      p2 = (t3, e3) => [t3 / 2, e3];
      break;
    case "topRight":
      g2 = true;
      u2 = (t3, e3) => [t3, 0];
      p2 = (t3, e3) => [0, e3];
      break;
    case "middleRight":
      f2 = true;
      u2 = (t3, e3) => [t3, e3 / 2];
      p2 = (t3, e3) => [0, e3 / 2];
      break;
    case "bottomRight":
      g2 = true;
      u2 = (t3, e3) => [t3, e3];
      p2 = (t3, e3) => [0, 0];
      break;
    case "bottomMiddle":
      u2 = (t3, e3) => [t3 / 2, e3];
      p2 = (t3, e3) => [t3 / 2, 0];
      break;
    case "bottomLeft":
      g2 = true;
      u2 = (t3, e3) => [0, e3];
      p2 = (t3, e3) => [t3, 0];
      break;
    case "middleLeft":
      f2 = true;
      u2 = (t3, e3) => [0, e3 / 2];
      p2 = (t3, e3) => [t3, e3 / 2];
  }
  const m2 = u2(r2, o2), b2 = p2(r2, o2);
  let A2 = transf(...b2);
  const w2 = _AnnotationEditor._round(n2 + A2[0]), y2 = _AnnotationEditor._round(a2 + A2[1]);
  let v2, x2, E2 = 1, _2 = 1;
  if (e2.fromKeyboard) ({ deltaX: v2, deltaY: x2 } = e2);
  else {
    const { screenX: t3, screenY: i3 } = e2, [s3, n3] = __privateGet(this, _ye);
    [v2, x2] = this.screenToPageTranslation(t3 - s3, i3 - n3);
    __privateGet(this, _ye)[0] = t3;
    __privateGet(this, _ye)[1] = i3;
  }
  [v2, x2] = (S2 = v2 / i2, C2 = x2 / s2, [c2[0] * S2 + c2[2] * C2, c2[1] * S2 + c2[3] * C2]);
  var S2, C2;
  if (g2) {
    const t3 = Math.hypot(r2, o2);
    E2 = _2 = Math.max(Math.min(Math.hypot(b2[0] - m2[0] - v2, b2[1] - m2[1] - x2) / t3, 1 / r2, 1 / o2), l2 / r2, h2 / o2);
  } else f2 ? E2 = MathClamp(Math.abs(b2[0] - m2[0] - v2), l2, 1) / r2 : _2 = MathClamp(Math.abs(b2[1] - m2[1] - x2), h2, 1) / o2;
  const T2 = _AnnotationEditor._round(r2 * E2), M2 = _AnnotationEditor._round(o2 * _2);
  A2 = transf(...p2(T2, M2));
  const D2 = w2 - A2[0], P2 = y2 - A2[1];
  __privateGet(this, _Se) || __privateSet(this, _Se, [this.x, this.y, this.width, this.height]);
  this.width = T2;
  this.height = M2;
  this.x = D2;
  this.y = P2;
  this.setDims(i2 * T2, s2 * M2);
  this.fixAndSetPosition();
  this._onResizing();
};
je_fn = function() {
  var _a5;
  __privateSet(this, _ve, { savedX: this.x, savedY: this.y, savedWidth: this.width, savedHeight: this.height });
  (_a5 = __privateGet(this, _o3)) == null ? void 0 : _a5.toggle(false);
  this.parent.togglePointerEvents(false);
};
qe_fn = function(t2, e2, i2) {
  let s2 = i2 / e2 * 0.7 + 1 - 0.7;
  if (1 === s2) return;
  const n2 = __privateMethod(this, _AnnotationEditor_instances, He_fn).call(this, this.rotation), transf = (t3, e3) => [n2[0] * t3 + n2[2] * e3, n2[1] * t3 + n2[3] * e3], [a2, r2] = this.parentDimensions, o2 = this.x, l2 = this.y, h2 = this.width, d2 = this.height, c2 = _AnnotationEditor.MIN_SIZE / a2, u2 = _AnnotationEditor.MIN_SIZE / r2;
  s2 = Math.max(Math.min(s2, 1 / h2, 1 / d2), c2 / h2, u2 / d2);
  const p2 = _AnnotationEditor._round(h2 * s2), g2 = _AnnotationEditor._round(d2 * s2);
  if (p2 === h2 && g2 === d2) return;
  __privateGet(this, _Se) || __privateSet(this, _Se, [o2, l2, h2, d2]);
  const f2 = transf(h2 / 2, d2 / 2), m2 = _AnnotationEditor._round(o2 + f2[0]), b2 = _AnnotationEditor._round(l2 + f2[1]), A2 = transf(p2 / 2, g2 / 2);
  this.x = m2 - A2[0];
  this.y = b2 - A2[1];
  this.width = p2;
  this.height = g2;
  this.setDims(a2 * p2, r2 * g2);
  this.fixAndSetPosition();
  this._onResizing();
};
Xe_fn = function() {
  var _a5;
  (_a5 = __privateGet(this, _o3)) == null ? void 0 : _a5.toggle(true);
  this.parent.togglePointerEvents(true);
  __privateMethod(this, _AnnotationEditor_instances, $e_fn).call(this);
};
Ye_fn = function(t2) {
  const { isMac: e2 } = util_FeatureTest.platform;
  t2.ctrlKey && !e2 || t2.shiftKey || t2.metaKey && e2 ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
};
Ke_fn = function(t2) {
  const { isSelected: e2 } = this;
  this._uiManager.setUpDragSession();
  let i2 = false;
  const s2 = new AbortController(), n2 = this._uiManager.combinedSignal(s2), a2 = { capture: true, passive: false, signal: n2 }, cancelDrag = (t3) => {
    s2.abort();
    __privateSet(this, _me, null);
    __privateSet(this, __e, false);
    this._uiManager.endDragSession() || __privateMethod(this, _AnnotationEditor_instances, Ye_fn).call(this, t3);
    i2 && this._onStopDragging();
  };
  if (e2) {
    __privateSet(this, _Pe, t2.clientX);
    __privateSet(this, _ke, t2.clientY);
    __privateSet(this, _me, t2.pointerId);
    __privateSet(this, _be, t2.pointerType);
    window.addEventListener("pointermove", (t3) => {
      if (!i2) {
        i2 = true;
        this._onStartDragging();
      }
      const { clientX: e3, clientY: s3, pointerId: n3 } = t3;
      if (n3 !== __privateGet(this, _me)) {
        stopEvent(t3);
        return;
      }
      const [a3, r2] = this.screenToPageTranslation(e3 - __privateGet(this, _Pe), s3 - __privateGet(this, _ke));
      __privateSet(this, _Pe, e3);
      __privateSet(this, _ke, s3);
      this._uiManager.dragSelectedEditors(a3, r2);
    }, a2);
    window.addEventListener("touchmove", stopEvent, a2);
    window.addEventListener("pointerdown", (t3) => {
      t3.pointerType === __privateGet(this, _be) && (__privateGet(this, _Re) || t3.isPrimary) && cancelDrag(t3);
      stopEvent(t3);
    }, a2);
  }
  const pointerUpCallback = (t3) => {
    __privateGet(this, _me) && __privateGet(this, _me) !== t3.pointerId ? stopEvent(t3) : cancelDrag(t3);
  };
  window.addEventListener("pointerup", pointerUpCallback, { signal: n2 });
  window.addEventListener("blur", pointerUpCallback, { signal: n2 });
};
Ve_fn = function() {
  if (__privateGet(this, _xe) || !this.div) return;
  __privateSet(this, _xe, new AbortController());
  const t2 = this._uiManager.combinedSignal(__privateGet(this, _xe));
  this.div.addEventListener("focusin", this.focusin.bind(this), { signal: t2 });
  this.div.addEventListener("focusout", this.focusout.bind(this), { signal: t2 });
};
Qe_fn = function(t2) {
  _AnnotationEditor._resizerKeyboardManager.exec(this, t2);
};
Je_fn = function(t2) {
  var _a5;
  __privateGet(this, _Me) && ((_a5 = t2.relatedTarget) == null ? void 0 : _a5.parentNode) !== __privateGet(this, _we) && __privateMethod(this, _AnnotationEditor_instances, Oe_fn).call(this);
};
Ze_fn = function(t2) {
  __privateSet(this, _Ee, __privateGet(this, _Me) ? t2 : "");
};
ti_fn = function(t2) {
  if (__privateGet(this, _ge)) for (const e2 of __privateGet(this, _ge)) e2.tabIndex = t2;
};
Oe_fn = function() {
  __privateSet(this, _Me, false);
  __privateMethod(this, _AnnotationEditor_instances, ti_fn).call(this, -1);
  __privateMethod(this, _AnnotationEditor_instances, $e_fn).call(this);
};
__privateAdd(_AnnotationEditor, _AnnotationEditor_static);
__publicField(_AnnotationEditor, "_l10n", null);
__publicField(_AnnotationEditor, "_l10nResizer", null);
__publicField(_AnnotationEditor, "_borderLineWidth", -1);
__publicField(_AnnotationEditor, "_colorManager", new ColorManager());
__publicField(_AnnotationEditor, "_zIndex", 1);
__publicField(_AnnotationEditor, "_telemetryTimeout", 1e3);
var AnnotationEditor = _AnnotationEditor;
var FakeEditor = class extends AnnotationEditor {
  constructor(t2) {
    super(t2);
    this.annotationElementId = t2.annotationElementId;
    this.deleted = true;
  }
  serialize() {
    return this.serializeDeleted();
  }
};
var $ = 3285377520;
var W = 4294901760;
var V = 65535;
var MurmurHash3_64 = class {
  constructor(t2) {
    this.h1 = t2 ? 4294967295 & t2 : $;
    this.h2 = t2 ? 4294967295 & t2 : $;
  }
  update(t2) {
    let e2, i2;
    if ("string" == typeof t2) {
      e2 = new Uint8Array(2 * t2.length);
      i2 = 0;
      for (let s3 = 0, n3 = t2.length; s3 < n3; s3++) {
        const n4 = t2.charCodeAt(s3);
        if (n4 <= 255) e2[i2++] = n4;
        else {
          e2[i2++] = n4 >>> 8;
          e2[i2++] = 255 & n4;
        }
      }
    } else {
      if (!ArrayBuffer.isView(t2)) throw new Error("Invalid data format, must be a string or TypedArray.");
      e2 = t2.slice();
      i2 = e2.byteLength;
    }
    const s2 = i2 >> 2, n2 = i2 - 4 * s2, a2 = new Uint32Array(e2.buffer, 0, s2);
    let r2 = 0, o2 = 0, l2 = this.h1, h2 = this.h2;
    const d2 = 3432918353, c2 = 461845907, u2 = 11601, p2 = 13715;
    for (let t3 = 0; t3 < s2; t3++) if (1 & t3) {
      r2 = a2[t3];
      r2 = r2 * d2 & W | r2 * u2 & V;
      r2 = r2 << 15 | r2 >>> 17;
      r2 = r2 * c2 & W | r2 * p2 & V;
      l2 ^= r2;
      l2 = l2 << 13 | l2 >>> 19;
      l2 = 5 * l2 + 3864292196;
    } else {
      o2 = a2[t3];
      o2 = o2 * d2 & W | o2 * u2 & V;
      o2 = o2 << 15 | o2 >>> 17;
      o2 = o2 * c2 & W | o2 * p2 & V;
      h2 ^= o2;
      h2 = h2 << 13 | h2 >>> 19;
      h2 = 5 * h2 + 3864292196;
    }
    r2 = 0;
    switch (n2) {
      case 3:
        r2 ^= e2[4 * s2 + 2] << 16;
      case 2:
        r2 ^= e2[4 * s2 + 1] << 8;
      case 1:
        r2 ^= e2[4 * s2];
        r2 = r2 * d2 & W | r2 * u2 & V;
        r2 = r2 << 15 | r2 >>> 17;
        r2 = r2 * c2 & W | r2 * p2 & V;
        1 & s2 ? l2 ^= r2 : h2 ^= r2;
    }
    this.h1 = l2;
    this.h2 = h2;
  }
  hexdigest() {
    let t2 = this.h1, e2 = this.h2;
    t2 ^= e2 >>> 1;
    t2 = 3981806797 * t2 & W | 36045 * t2 & V;
    e2 = 4283543511 * e2 & W | (2950163797 * (e2 << 16 | t2 >>> 16) & W) >>> 16;
    t2 ^= e2 >>> 1;
    t2 = 444984403 * t2 & W | 60499 * t2 & V;
    e2 = 3301882366 * e2 & W | (3120437893 * (e2 << 16 | t2 >>> 16) & W) >>> 16;
    t2 ^= e2 >>> 1;
    return (t2 >>> 0).toString(16).padStart(8, "0") + (e2 >>> 0).toString(16).padStart(8, "0");
  }
};
var j = Object.freeze({ map: null, hash: "", transfer: void 0 });
var _ei, _ii, _si, _AnnotationStorage_instances, ni_fn;
var AnnotationStorage = class {
  constructor() {
    __privateAdd(this, _AnnotationStorage_instances);
    __privateAdd(this, _ei, false);
    __privateAdd(this, _ii, null);
    __privateAdd(this, _si, /* @__PURE__ */ new Map());
    this.onSetModified = null;
    this.onResetModified = null;
    this.onAnnotationEditor = null;
  }
  getValue(t2, e2) {
    const i2 = __privateGet(this, _si).get(t2);
    return void 0 === i2 ? e2 : Object.assign(e2, i2);
  }
  getRawValue(t2) {
    return __privateGet(this, _si).get(t2);
  }
  remove(t2) {
    __privateGet(this, _si).delete(t2);
    0 === __privateGet(this, _si).size && this.resetModified();
    if ("function" == typeof this.onAnnotationEditor) {
      for (const t3 of __privateGet(this, _si).values()) if (t3 instanceof AnnotationEditor) return;
      this.onAnnotationEditor(null);
    }
  }
  setValue(t2, e2) {
    const i2 = __privateGet(this, _si).get(t2);
    let s2 = false;
    if (void 0 !== i2) {
      for (const [t3, n2] of Object.entries(e2)) if (i2[t3] !== n2) {
        s2 = true;
        i2[t3] = n2;
      }
    } else {
      s2 = true;
      __privateGet(this, _si).set(t2, e2);
    }
    s2 && __privateMethod(this, _AnnotationStorage_instances, ni_fn).call(this);
    e2 instanceof AnnotationEditor && "function" == typeof this.onAnnotationEditor && this.onAnnotationEditor(e2.constructor._type);
  }
  has(t2) {
    return __privateGet(this, _si).has(t2);
  }
  get size() {
    return __privateGet(this, _si).size;
  }
  resetModified() {
    if (__privateGet(this, _ei)) {
      __privateSet(this, _ei, false);
      "function" == typeof this.onResetModified && this.onResetModified();
    }
  }
  get print() {
    return new PrintAnnotationStorage(this);
  }
  get serializable() {
    if (0 === __privateGet(this, _si).size) return j;
    const t2 = /* @__PURE__ */ new Map(), e2 = new MurmurHash3_64(), i2 = [], s2 = /* @__PURE__ */ Object.create(null);
    let n2 = false;
    for (const [i3, a2] of __privateGet(this, _si)) {
      const r2 = a2 instanceof AnnotationEditor ? a2.serialize(false, s2) : a2;
      if (r2) {
        t2.set(i3, r2);
        e2.update(`${i3}:${JSON.stringify(r2)}`);
        n2 || (n2 = !!r2.bitmap);
      }
    }
    if (n2) for (const e3 of t2.values()) e3.bitmap && i2.push(e3.bitmap);
    return t2.size > 0 ? { map: t2, hash: e2.hexdigest(), transfer: i2 } : j;
  }
  get editorStats() {
    let t2 = null;
    const e2 = /* @__PURE__ */ new Map();
    for (const i2 of __privateGet(this, _si).values()) {
      if (!(i2 instanceof AnnotationEditor)) continue;
      const s2 = i2.telemetryFinalData;
      if (!s2) continue;
      const { type: n2 } = s2;
      e2.has(n2) || e2.set(n2, Object.getPrototypeOf(i2).constructor);
      t2 || (t2 = /* @__PURE__ */ Object.create(null));
      const a2 = t2[n2] || (t2[n2] = /* @__PURE__ */ new Map());
      for (const [t3, e3] of Object.entries(s2)) {
        if ("type" === t3) continue;
        let i3 = a2.get(t3);
        if (!i3) {
          i3 = /* @__PURE__ */ new Map();
          a2.set(t3, i3);
        }
        const s3 = i3.get(e3) ?? 0;
        i3.set(e3, s3 + 1);
      }
    }
    for (const [i2, s2] of e2) t2[i2] = s2.computeTelemetryFinalData(t2[i2]);
    return t2;
  }
  resetModifiedIds() {
    __privateSet(this, _ii, null);
  }
  get modifiedIds() {
    if (__privateGet(this, _ii)) return __privateGet(this, _ii);
    const t2 = [];
    for (const e2 of __privateGet(this, _si).values()) e2 instanceof AnnotationEditor && e2.annotationElementId && e2.serialize() && t2.push(e2.annotationElementId);
    return __privateSet(this, _ii, { ids: new Set(t2), hash: t2.join(",") });
  }
  [Symbol.iterator]() {
    return __privateGet(this, _si).entries();
  }
};
_ei = new WeakMap();
_ii = new WeakMap();
_si = new WeakMap();
_AnnotationStorage_instances = new WeakSet();
ni_fn = function() {
  if (!__privateGet(this, _ei)) {
    __privateSet(this, _ei, true);
    "function" == typeof this.onSetModified && this.onSetModified();
  }
};
var _ai;
var PrintAnnotationStorage = class extends AnnotationStorage {
  constructor(t2) {
    super();
    __privateAdd(this, _ai);
    const { map: e2, hash: i2, transfer: s2 } = t2.serializable, n2 = structuredClone(e2, s2 ? { transfer: s2 } : null);
    __privateSet(this, _ai, { map: n2, hash: i2, transfer: s2 });
  }
  get print() {
    unreachable("Should not call PrintAnnotationStorage.print");
  }
  get serializable() {
    return __privateGet(this, _ai);
  }
  get modifiedIds() {
    return shadow(this, "modifiedIds", { ids: /* @__PURE__ */ new Set(), hash: "" });
  }
};
_ai = new WeakMap();
var _ri;
var FontLoader = class {
  constructor({ ownerDocument: t2 = globalThis.document, styleElement: e2 = null }) {
    __privateAdd(this, _ri, /* @__PURE__ */ new Set());
    this._document = t2;
    this.nativeFontFaces = /* @__PURE__ */ new Set();
    this.styleElement = null;
    this.loadingRequests = [];
    this.loadTestFontId = 0;
  }
  addNativeFontFace(t2) {
    this.nativeFontFaces.add(t2);
    this._document.fonts.add(t2);
  }
  removeNativeFontFace(t2) {
    this.nativeFontFaces.delete(t2);
    this._document.fonts.delete(t2);
  }
  insertRule(t2) {
    if (!this.styleElement) {
      this.styleElement = this._document.createElement("style");
      this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement);
    }
    const e2 = this.styleElement.sheet;
    e2.insertRule(t2, e2.cssRules.length);
  }
  clear() {
    for (const t2 of this.nativeFontFaces) this._document.fonts.delete(t2);
    this.nativeFontFaces.clear();
    __privateGet(this, _ri).clear();
    if (this.styleElement) {
      this.styleElement.remove();
      this.styleElement = null;
    }
  }
  async loadSystemFont({ systemFontInfo: t2, disableFontFace: e2, _inspectFont: i2 }) {
    if (t2 && !__privateGet(this, _ri).has(t2.loadedName)) {
      assert(!e2, "loadSystemFont shouldn't be called when `disableFontFace` is set.");
      if (this.isFontLoadingAPISupported) {
        const { loadedName: e3, src: s2, style: n2 } = t2, a2 = new FontFace(e3, s2, n2);
        this.addNativeFontFace(a2);
        try {
          await a2.load();
          __privateGet(this, _ri).add(e3);
          i2 == null ? void 0 : i2(t2);
        } catch {
          warn(`Cannot load system font: ${t2.baseFontName}, installing it could help to improve PDF rendering.`);
          this.removeNativeFontFace(a2);
        }
      } else unreachable("Not implemented: loadSystemFont without the Font Loading API.");
    }
  }
  async bind(t2) {
    if (t2.attached || t2.missingFile && !t2.systemFontInfo) return;
    t2.attached = true;
    if (t2.systemFontInfo) {
      await this.loadSystemFont(t2);
      return;
    }
    if (this.isFontLoadingAPISupported) {
      const e3 = t2.createNativeFontFace();
      if (e3) {
        this.addNativeFontFace(e3);
        try {
          await e3.loaded;
        } catch (i2) {
          warn(`Failed to load font '${e3.family}': '${i2}'.`);
          t2.disableFontFace = true;
          throw i2;
        }
      }
      return;
    }
    const e2 = t2.createFontFaceRule();
    if (e2) {
      this.insertRule(e2);
      if (this.isSyncFontLoadingSupported) return;
      await new Promise((e3) => {
        const i2 = this._queueLoadingCallback(e3);
        this._prepareFontLoadEvent(t2, i2);
      });
    }
  }
  get isFontLoadingAPISupported() {
    var _a5;
    return shadow(this, "isFontLoadingAPISupported", !!((_a5 = this._document) == null ? void 0 : _a5.fonts));
  }
  get isSyncFontLoadingSupported() {
    return shadow(this, "isSyncFontLoadingSupported", t || util_FeatureTest.platform.isFirefox);
  }
  _queueLoadingCallback(t2) {
    const { loadingRequests: e2 } = this, i2 = { done: false, complete: function completeRequest() {
      assert(!i2.done, "completeRequest() cannot be called twice.");
      i2.done = true;
      for (; e2.length > 0 && e2[0].done; ) {
        const t3 = e2.shift();
        setTimeout(t3.callback, 0);
      }
    }, callback: t2 };
    e2.push(i2);
    return i2;
  }
  get _loadTestFont() {
    return shadow(this, "_loadTestFont", atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA=="));
  }
  _prepareFontLoadEvent(t2, e2) {
    function int32(t3, e3) {
      return t3.charCodeAt(e3) << 24 | t3.charCodeAt(e3 + 1) << 16 | t3.charCodeAt(e3 + 2) << 8 | 255 & t3.charCodeAt(e3 + 3);
    }
    function spliceString(t3, e3, i3, s3) {
      return t3.substring(0, e3) + s3 + t3.substring(e3 + i3);
    }
    let i2, s2;
    const n2 = this._document.createElement("canvas");
    n2.width = 1;
    n2.height = 1;
    const a2 = n2.getContext("2d");
    let r2 = 0;
    const o2 = `lt${Date.now()}${this.loadTestFontId++}`;
    let l2 = this._loadTestFont;
    l2 = spliceString(l2, 976, o2.length, o2);
    const h2 = 1482184792;
    let d2 = int32(l2, 16);
    for (i2 = 0, s2 = o2.length - 3; i2 < s2; i2 += 4) d2 = d2 - h2 + int32(o2, i2) | 0;
    i2 < o2.length && (d2 = d2 - h2 + int32(o2 + "XXX", i2) | 0);
    l2 = spliceString(l2, 16, 4, function string32(t3) {
      return String.fromCharCode(t3 >> 24 & 255, t3 >> 16 & 255, t3 >> 8 & 255, 255 & t3);
    }(d2));
    const c2 = `@font-face {font-family:"${o2}";src:${`url(data:font/opentype;base64,${btoa(l2)});`}}`;
    this.insertRule(c2);
    const u2 = this._document.createElement("div");
    u2.style.visibility = "hidden";
    u2.style.width = u2.style.height = "10px";
    u2.style.position = "absolute";
    u2.style.top = u2.style.left = "0px";
    for (const e3 of [t2.loadedName, o2]) {
      const t3 = this._document.createElement("span");
      t3.textContent = "Hi";
      t3.style.fontFamily = e3;
      u2.append(t3);
    }
    this._document.body.append(u2);
    !function isFontReady(t3, e3) {
      if (++r2 > 30) {
        warn("Load test font never loaded.");
        e3();
        return;
      }
      a2.font = "30px " + t3;
      a2.fillText(".", 0, 20);
      a2.getImageData(0, 0, 1, 1).data[3] > 0 ? e3() : setTimeout(isFontReady.bind(null, t3, e3));
    }(o2, () => {
      u2.remove();
      e2.complete();
    });
  }
};
_ri = new WeakMap();
var FontFaceObject = class {
  constructor(t2, e2 = null) {
    this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
    for (const e3 in t2) this[e3] = t2[e3];
    this._inspectFont = e2;
  }
  createNativeFontFace() {
    var _a5;
    if (!this.data || this.disableFontFace) return null;
    let t2;
    if (this.cssFontInfo) {
      const e2 = { weight: this.cssFontInfo.fontWeight };
      this.cssFontInfo.italicAngle && (e2.style = `oblique ${this.cssFontInfo.italicAngle}deg`);
      t2 = new FontFace(this.cssFontInfo.fontFamily, this.data, e2);
    } else t2 = new FontFace(this.loadedName, this.data, {});
    (_a5 = this._inspectFont) == null ? void 0 : _a5.call(this, this);
    return t2;
  }
  createFontFaceRule() {
    var _a5;
    if (!this.data || this.disableFontFace) return null;
    const t2 = `url(data:${this.mimetype};base64,${toBase64Util(this.data)});`;
    let e2;
    if (this.cssFontInfo) {
      let i2 = `font-weight: ${this.cssFontInfo.fontWeight};`;
      this.cssFontInfo.italicAngle && (i2 += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`);
      e2 = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${i2}src:${t2}}`;
    } else e2 = `@font-face {font-family:"${this.loadedName}";src:${t2}}`;
    (_a5 = this._inspectFont) == null ? void 0 : _a5.call(this, this, t2);
    return e2;
  }
  getPathGenerator(t2, e2) {
    if (void 0 !== this.compiledGlyphs[e2]) return this.compiledGlyphs[e2];
    const i2 = this.loadedName + "_path_" + e2;
    let s2;
    try {
      s2 = t2.get(i2);
    } catch (t3) {
      warn(`getPathGenerator - ignoring character: "${t3}".`);
    }
    const n2 = new Path2D(s2 || "");
    this.fontExtraProperties || t2.delete(i2);
    return this.compiledGlyphs[e2] = n2;
  }
};
function getFactoryUrlProp(t2) {
  if ("string" != typeof t2) return null;
  if (t2.endsWith("/")) return t2;
  throw new Error(`Invalid factory url: "${t2}" must include trailing slash.`);
}
var isRefProxy = (t2) => "object" == typeof t2 && Number.isInteger(t2 == null ? void 0 : t2.num) && t2.num >= 0 && Number.isInteger(t2 == null ? void 0 : t2.gen) && t2.gen >= 0;
var q = (function _isValidExplicitDest(t2, e2, i2) {
  if (!Array.isArray(i2) || i2.length < 2) return false;
  const [s2, n2, ...a2] = i2;
  if (!t2(s2) && !Number.isInteger(s2)) return false;
  if (!e2(n2)) return false;
  const r2 = a2.length;
  let o2 = true;
  switch (n2.name) {
    case "XYZ":
      if (r2 < 2 || r2 > 3) return false;
      break;
    case "Fit":
    case "FitB":
      return 0 === r2;
    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (r2 > 1) return false;
      break;
    case "FitR":
      if (4 !== r2) return false;
      o2 = false;
      break;
    default:
      return false;
  }
  for (const t3 of a2) if (!("number" == typeof t3 || o2 && null === t3)) return false;
  return true;
}).bind(null, isRefProxy, (t2) => "object" == typeof t2 && "string" == typeof (t2 == null ? void 0 : t2.name));
var _oi, _li;
var LoopbackPort = class {
  constructor() {
    __privateAdd(this, _oi, /* @__PURE__ */ new Map());
    __privateAdd(this, _li, Promise.resolve());
  }
  postMessage(t2, e2) {
    const i2 = { data: structuredClone(t2, e2 ? { transfer: e2 } : null) };
    __privateGet(this, _li).then(() => {
      for (const [t3] of __privateGet(this, _oi)) t3.call(this, i2);
    });
  }
  addEventListener(t2, e2, i2 = null) {
    let s2 = null;
    if ((i2 == null ? void 0 : i2.signal) instanceof AbortSignal) {
      const { signal: n2 } = i2;
      if (n2.aborted) {
        warn("LoopbackPort - cannot use an `aborted` signal.");
        return;
      }
      const onAbort = () => this.removeEventListener(t2, e2);
      s2 = () => n2.removeEventListener("abort", onAbort);
      n2.addEventListener("abort", onAbort);
    }
    __privateGet(this, _oi).set(e2, s2);
  }
  removeEventListener(t2, e2) {
    const i2 = __privateGet(this, _oi).get(e2);
    i2 == null ? void 0 : i2();
    __privateGet(this, _oi).delete(e2);
  }
  terminate() {
    for (const [, t2] of __privateGet(this, _oi)) t2 == null ? void 0 : t2();
    __privateGet(this, _oi).clear();
  }
};
_oi = new WeakMap();
_li = new WeakMap();
var X = 1;
var K = 2;
var Y = 1;
var Q = 2;
var J = 3;
var Z = 4;
var tt = 5;
var et = 6;
var it = 7;
var st = 8;
function onFn() {
}
function wrapReason(t2) {
  if (t2 instanceof AbortException || t2 instanceof InvalidPDFException || t2 instanceof PasswordException || t2 instanceof ResponseException || t2 instanceof UnknownErrorException) return t2;
  t2 instanceof Error || "object" == typeof t2 && null !== t2 || unreachable('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
  switch (t2.name) {
    case "AbortException":
      return new AbortException(t2.message);
    case "InvalidPDFException":
      return new InvalidPDFException(t2.message);
    case "PasswordException":
      return new PasswordException(t2.message, t2.code);
    case "ResponseException":
      return new ResponseException(t2.message, t2.status, t2.missing);
    case "UnknownErrorException":
      return new UnknownErrorException(t2.message, t2.details);
  }
  return new UnknownErrorException(t2.message, t2.toString());
}
var _hi, _MessageHandler_instances, di_fn, ui_fn, ci_fn, pi_fn;
var MessageHandler = class {
  constructor(t2, e2, i2) {
    __privateAdd(this, _MessageHandler_instances);
    __privateAdd(this, _hi, new AbortController());
    this.sourceName = t2;
    this.targetName = e2;
    this.comObj = i2;
    this.callbackId = 1;
    this.streamId = 1;
    this.streamSinks = /* @__PURE__ */ Object.create(null);
    this.streamControllers = /* @__PURE__ */ Object.create(null);
    this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
    this.actionHandler = /* @__PURE__ */ Object.create(null);
    i2.addEventListener("message", __privateMethod(this, _MessageHandler_instances, di_fn).bind(this), { signal: __privateGet(this, _hi).signal });
  }
  on(t2, e2) {
    const i2 = this.actionHandler;
    if (i2[t2]) throw new Error(`There is already an actionName called "${t2}"`);
    i2[t2] = e2;
  }
  send(t2, e2, i2) {
    this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: t2, data: e2 }, i2);
  }
  sendWithPromise(t2, e2, i2) {
    const s2 = this.callbackId++, n2 = Promise.withResolvers();
    this.callbackCapabilities[s2] = n2;
    try {
      this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: t2, callbackId: s2, data: e2 }, i2);
    } catch (t3) {
      n2.reject(t3);
    }
    return n2.promise;
  }
  sendWithStream(t2, e2, i2, s2) {
    const n2 = this.streamId++, a2 = this.sourceName, r2 = this.targetName, o2 = this.comObj;
    return new ReadableStream({ start: (i3) => {
      const l2 = Promise.withResolvers();
      this.streamControllers[n2] = { controller: i3, startCall: l2, pullCall: null, cancelCall: null, isClosed: false };
      o2.postMessage({ sourceName: a2, targetName: r2, action: t2, streamId: n2, data: e2, desiredSize: i3.desiredSize }, s2);
      return l2.promise;
    }, pull: (t3) => {
      const e3 = Promise.withResolvers();
      this.streamControllers[n2].pullCall = e3;
      o2.postMessage({ sourceName: a2, targetName: r2, stream: et, streamId: n2, desiredSize: t3.desiredSize });
      return e3.promise;
    }, cancel: (t3) => {
      assert(t3 instanceof Error, "cancel must have a valid reason");
      const e3 = Promise.withResolvers();
      this.streamControllers[n2].cancelCall = e3;
      this.streamControllers[n2].isClosed = true;
      o2.postMessage({ sourceName: a2, targetName: r2, stream: Y, streamId: n2, reason: wrapReason(t3) });
      return e3.promise;
    } }, i2);
  }
  destroy() {
    var _a5;
    (_a5 = __privateGet(this, _hi)) == null ? void 0 : _a5.abort();
    __privateSet(this, _hi, null);
  }
};
_hi = new WeakMap();
_MessageHandler_instances = new WeakSet();
di_fn = function({ data: t2 }) {
  if (t2.targetName !== this.sourceName) return;
  if (t2.stream) {
    __privateMethod(this, _MessageHandler_instances, ci_fn).call(this, t2);
    return;
  }
  if (t2.callback) {
    const e3 = t2.callbackId, i2 = this.callbackCapabilities[e3];
    if (!i2) throw new Error(`Cannot resolve callback ${e3}`);
    delete this.callbackCapabilities[e3];
    if (t2.callback === X) i2.resolve(t2.data);
    else {
      if (t2.callback !== K) throw new Error("Unexpected callback case");
      i2.reject(wrapReason(t2.reason));
    }
    return;
  }
  const e2 = this.actionHandler[t2.action];
  if (!e2) throw new Error(`Unknown action from worker: ${t2.action}`);
  if (t2.callbackId) {
    const i2 = this.sourceName, s2 = t2.sourceName, n2 = this.comObj;
    Promise.try(e2, t2.data).then(function(e3) {
      n2.postMessage({ sourceName: i2, targetName: s2, callback: X, callbackId: t2.callbackId, data: e3 });
    }, function(e3) {
      n2.postMessage({ sourceName: i2, targetName: s2, callback: K, callbackId: t2.callbackId, reason: wrapReason(e3) });
    });
  } else t2.streamId ? __privateMethod(this, _MessageHandler_instances, ui_fn).call(this, t2) : e2(t2.data);
};
ui_fn = function(t2) {
  const e2 = t2.streamId, i2 = this.sourceName, s2 = t2.sourceName, n2 = this.comObj, a2 = this, r2 = this.actionHandler[t2.action], o2 = { enqueue(t3, a3 = 1, r3) {
    if (this.isCancelled) return;
    const o3 = this.desiredSize;
    this.desiredSize -= a3;
    if (o3 > 0 && this.desiredSize <= 0) {
      this.sinkCapability = Promise.withResolvers();
      this.ready = this.sinkCapability.promise;
    }
    n2.postMessage({ sourceName: i2, targetName: s2, stream: Z, streamId: e2, chunk: t3 }, r3);
  }, close() {
    if (!this.isCancelled) {
      this.isCancelled = true;
      n2.postMessage({ sourceName: i2, targetName: s2, stream: J, streamId: e2 });
      delete a2.streamSinks[e2];
    }
  }, error(t3) {
    assert(t3 instanceof Error, "error must have a valid reason");
    if (!this.isCancelled) {
      this.isCancelled = true;
      n2.postMessage({ sourceName: i2, targetName: s2, stream: tt, streamId: e2, reason: wrapReason(t3) });
    }
  }, sinkCapability: Promise.withResolvers(), onPull: null, onCancel: null, isCancelled: false, desiredSize: t2.desiredSize, ready: null };
  o2.sinkCapability.resolve();
  o2.ready = o2.sinkCapability.promise;
  this.streamSinks[e2] = o2;
  Promise.try(r2, t2.data, o2).then(function() {
    n2.postMessage({ sourceName: i2, targetName: s2, stream: st, streamId: e2, success: true });
  }, function(t3) {
    n2.postMessage({ sourceName: i2, targetName: s2, stream: st, streamId: e2, reason: wrapReason(t3) });
  });
};
ci_fn = function(t2) {
  const e2 = t2.streamId, i2 = this.sourceName, s2 = t2.sourceName, n2 = this.comObj, a2 = this.streamControllers[e2], r2 = this.streamSinks[e2];
  switch (t2.stream) {
    case st:
      t2.success ? a2.startCall.resolve() : a2.startCall.reject(wrapReason(t2.reason));
      break;
    case it:
      t2.success ? a2.pullCall.resolve() : a2.pullCall.reject(wrapReason(t2.reason));
      break;
    case et:
      if (!r2) {
        n2.postMessage({ sourceName: i2, targetName: s2, stream: it, streamId: e2, success: true });
        break;
      }
      r2.desiredSize <= 0 && t2.desiredSize > 0 && r2.sinkCapability.resolve();
      r2.desiredSize = t2.desiredSize;
      Promise.try(r2.onPull || onFn).then(function() {
        n2.postMessage({ sourceName: i2, targetName: s2, stream: it, streamId: e2, success: true });
      }, function(t3) {
        n2.postMessage({ sourceName: i2, targetName: s2, stream: it, streamId: e2, reason: wrapReason(t3) });
      });
      break;
    case Z:
      assert(a2, "enqueue should have stream controller");
      if (a2.isClosed) break;
      a2.controller.enqueue(t2.chunk);
      break;
    case J:
      assert(a2, "close should have stream controller");
      if (a2.isClosed) break;
      a2.isClosed = true;
      a2.controller.close();
      __privateMethod(this, _MessageHandler_instances, pi_fn).call(this, a2, e2);
      break;
    case tt:
      assert(a2, "error should have stream controller");
      a2.controller.error(wrapReason(t2.reason));
      __privateMethod(this, _MessageHandler_instances, pi_fn).call(this, a2, e2);
      break;
    case Q:
      t2.success ? a2.cancelCall.resolve() : a2.cancelCall.reject(wrapReason(t2.reason));
      __privateMethod(this, _MessageHandler_instances, pi_fn).call(this, a2, e2);
      break;
    case Y:
      if (!r2) break;
      const o2 = wrapReason(t2.reason);
      Promise.try(r2.onCancel || onFn, o2).then(function() {
        n2.postMessage({ sourceName: i2, targetName: s2, stream: Q, streamId: e2, success: true });
      }, function(t3) {
        n2.postMessage({ sourceName: i2, targetName: s2, stream: Q, streamId: e2, reason: wrapReason(t3) });
      });
      r2.sinkCapability.reject(o2);
      r2.isCancelled = true;
      delete this.streamSinks[e2];
      break;
    default:
      throw new Error("Unexpected stream case");
  }
};
pi_fn = async function(t2, e2) {
  var _a5, _b, _c;
  await Promise.allSettled([(_a5 = t2.startCall) == null ? void 0 : _a5.promise, (_b = t2.pullCall) == null ? void 0 : _b.promise, (_c = t2.cancelCall) == null ? void 0 : _c.promise]);
  delete this.streamControllers[e2];
};
var _gi;
var BaseCanvasFactory = class {
  constructor({ enableHWA: t2 = false }) {
    __privateAdd(this, _gi, false);
    __privateSet(this, _gi, t2);
  }
  create(t2, e2) {
    if (t2 <= 0 || e2 <= 0) throw new Error("Invalid canvas size");
    const i2 = this._createCanvas(t2, e2);
    return { canvas: i2, context: i2.getContext("2d", { willReadFrequently: !__privateGet(this, _gi) }) };
  }
  reset(t2, e2, i2) {
    if (!t2.canvas) throw new Error("Canvas is not specified");
    if (e2 <= 0 || i2 <= 0) throw new Error("Invalid canvas size");
    t2.canvas.width = e2;
    t2.canvas.height = i2;
  }
  destroy(t2) {
    if (!t2.canvas) throw new Error("Canvas is not specified");
    t2.canvas.width = 0;
    t2.canvas.height = 0;
    t2.canvas = null;
    t2.context = null;
  }
  _createCanvas(t2, e2) {
    unreachable("Abstract method `_createCanvas` called.");
  }
};
_gi = new WeakMap();
var DOMCanvasFactory = class extends BaseCanvasFactory {
  constructor({ ownerDocument: t2 = globalThis.document, enableHWA: e2 = false }) {
    super({ enableHWA: e2 });
    this._document = t2;
  }
  _createCanvas(t2, e2) {
    const i2 = this._document.createElement("canvas");
    i2.width = t2;
    i2.height = e2;
    return i2;
  }
};
var BaseCMapReaderFactory = class {
  constructor({ baseUrl: t2 = null, isCompressed: e2 = true }) {
    this.baseUrl = t2;
    this.isCompressed = e2;
  }
  async fetch({ name: t2 }) {
    if (!this.baseUrl) throw new Error("Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.");
    if (!t2) throw new Error("CMap name must be specified.");
    const e2 = this.baseUrl + t2 + (this.isCompressed ? ".bcmap" : "");
    return this._fetch(e2).then((t3) => ({ cMapData: t3, isCompressed: this.isCompressed })).catch((t3) => {
      throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${e2}`);
    });
  }
  async _fetch(t2) {
    unreachable("Abstract method `_fetch` called.");
  }
};
var DOMCMapReaderFactory = class extends BaseCMapReaderFactory {
  async _fetch(t2) {
    const e2 = await fetchData(t2, this.isCompressed ? "arraybuffer" : "text");
    return e2 instanceof ArrayBuffer ? new Uint8Array(e2) : stringToBytes(e2);
  }
};
var BaseFilterFactory = class {
  addFilter(t2) {
    return "none";
  }
  addHCMFilter(t2, e2) {
    return "none";
  }
  addAlphaFilter(t2) {
    return "none";
  }
  addLuminosityFilter(t2) {
    return "none";
  }
  addHighlightHCMFilter(t2, e2, i2, s2, n2) {
    return "none";
  }
  destroy(t2 = false) {
  }
};
var _fi, _mi, _bi, _Ai, _wi, _yi, _y3, _DOMFilterFactory_instances, x_get, vi_get, xi_get, Ei_fn, _i_fn, Pi_fn, Mi_fn, Si_fn, ki_fn, Ci_fn, Di_fn, Ti_fn;
var DOMFilterFactory = class extends BaseFilterFactory {
  constructor({ docId: t2, ownerDocument: e2 = globalThis.document }) {
    super();
    __privateAdd(this, _DOMFilterFactory_instances);
    __privateAdd(this, _fi);
    __privateAdd(this, _mi);
    __privateAdd(this, _bi);
    __privateAdd(this, _Ai);
    __privateAdd(this, _wi);
    __privateAdd(this, _yi);
    __privateAdd(this, _y3, 0);
    __privateSet(this, _Ai, t2);
    __privateSet(this, _wi, e2);
  }
  addFilter(t2) {
    if (!t2) return "none";
    let e2 = __privateGet(this, _DOMFilterFactory_instances, x_get).get(t2);
    if (e2) return e2;
    const [i2, s2, n2] = __privateMethod(this, _DOMFilterFactory_instances, Ei_fn).call(this, t2), a2 = 1 === t2.length ? i2 : `${i2}${s2}${n2}`;
    e2 = __privateGet(this, _DOMFilterFactory_instances, x_get).get(a2);
    if (e2) {
      __privateGet(this, _DOMFilterFactory_instances, x_get).set(t2, e2);
      return e2;
    }
    const r2 = `g_${__privateGet(this, _Ai)}_transfer_map_${__privateWrapper(this, _y3)._++}`, o2 = __privateMethod(this, _DOMFilterFactory_instances, _i_fn).call(this, r2);
    __privateGet(this, _DOMFilterFactory_instances, x_get).set(t2, o2);
    __privateGet(this, _DOMFilterFactory_instances, x_get).set(a2, o2);
    const l2 = __privateMethod(this, _DOMFilterFactory_instances, Si_fn).call(this, r2);
    __privateMethod(this, _DOMFilterFactory_instances, Ci_fn).call(this, i2, s2, n2, l2);
    return o2;
  }
  addHCMFilter(t2, e2) {
    var _a5;
    const i2 = `${t2}-${e2}`, s2 = "base";
    let n2 = __privateGet(this, _DOMFilterFactory_instances, vi_get).get(s2);
    if ((n2 == null ? void 0 : n2.key) === i2) return n2.url;
    if (n2) {
      (_a5 = n2.filter) == null ? void 0 : _a5.remove();
      n2.key = i2;
      n2.url = "none";
      n2.filter = null;
    } else {
      n2 = { key: i2, url: "none", filter: null };
      __privateGet(this, _DOMFilterFactory_instances, vi_get).set(s2, n2);
    }
    if (!t2 || !e2) return n2.url;
    const a2 = __privateMethod(this, _DOMFilterFactory_instances, Ti_fn).call(this, t2);
    t2 = Util.makeHexColor(...a2);
    const r2 = __privateMethod(this, _DOMFilterFactory_instances, Ti_fn).call(this, e2);
    e2 = Util.makeHexColor(...r2);
    __privateGet(this, _DOMFilterFactory_instances, xi_get).style.color = "";
    if ("#000000" === t2 && "#ffffff" === e2 || t2 === e2) return n2.url;
    const o2 = new Array(256);
    for (let t3 = 0; t3 <= 255; t3++) {
      const e3 = t3 / 255;
      o2[t3] = e3 <= 0.03928 ? e3 / 12.92 : ((e3 + 0.055) / 1.055) ** 2.4;
    }
    const l2 = o2.join(","), h2 = `g_${__privateGet(this, _Ai)}_hcm_filter`, d2 = n2.filter = __privateMethod(this, _DOMFilterFactory_instances, Si_fn).call(this, h2);
    __privateMethod(this, _DOMFilterFactory_instances, Ci_fn).call(this, l2, l2, l2, d2);
    __privateMethod(this, _DOMFilterFactory_instances, Mi_fn).call(this, d2);
    const getSteps = (t3, e3) => {
      const i3 = a2[t3] / 255, s3 = r2[t3] / 255, n3 = new Array(e3 + 1);
      for (let t4 = 0; t4 <= e3; t4++) n3[t4] = i3 + t4 / e3 * (s3 - i3);
      return n3.join(",");
    };
    __privateMethod(this, _DOMFilterFactory_instances, Ci_fn).call(this, getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), d2);
    n2.url = __privateMethod(this, _DOMFilterFactory_instances, _i_fn).call(this, h2);
    return n2.url;
  }
  addAlphaFilter(t2) {
    let e2 = __privateGet(this, _DOMFilterFactory_instances, x_get).get(t2);
    if (e2) return e2;
    const [i2] = __privateMethod(this, _DOMFilterFactory_instances, Ei_fn).call(this, [t2]), s2 = `alpha_${i2}`;
    e2 = __privateGet(this, _DOMFilterFactory_instances, x_get).get(s2);
    if (e2) {
      __privateGet(this, _DOMFilterFactory_instances, x_get).set(t2, e2);
      return e2;
    }
    const n2 = `g_${__privateGet(this, _Ai)}_alpha_map_${__privateWrapper(this, _y3)._++}`, a2 = __privateMethod(this, _DOMFilterFactory_instances, _i_fn).call(this, n2);
    __privateGet(this, _DOMFilterFactory_instances, x_get).set(t2, a2);
    __privateGet(this, _DOMFilterFactory_instances, x_get).set(s2, a2);
    const r2 = __privateMethod(this, _DOMFilterFactory_instances, Si_fn).call(this, n2);
    __privateMethod(this, _DOMFilterFactory_instances, Di_fn).call(this, i2, r2);
    return a2;
  }
  addLuminosityFilter(t2) {
    let e2, i2, s2 = __privateGet(this, _DOMFilterFactory_instances, x_get).get(t2 || "luminosity");
    if (s2) return s2;
    if (t2) {
      [e2] = __privateMethod(this, _DOMFilterFactory_instances, Ei_fn).call(this, [t2]);
      i2 = `luminosity_${e2}`;
    } else i2 = "luminosity";
    s2 = __privateGet(this, _DOMFilterFactory_instances, x_get).get(i2);
    if (s2) {
      __privateGet(this, _DOMFilterFactory_instances, x_get).set(t2, s2);
      return s2;
    }
    const n2 = `g_${__privateGet(this, _Ai)}_luminosity_map_${__privateWrapper(this, _y3)._++}`, a2 = __privateMethod(this, _DOMFilterFactory_instances, _i_fn).call(this, n2);
    __privateGet(this, _DOMFilterFactory_instances, x_get).set(t2, a2);
    __privateGet(this, _DOMFilterFactory_instances, x_get).set(i2, a2);
    const r2 = __privateMethod(this, _DOMFilterFactory_instances, Si_fn).call(this, n2);
    __privateMethod(this, _DOMFilterFactory_instances, Pi_fn).call(this, r2);
    t2 && __privateMethod(this, _DOMFilterFactory_instances, Di_fn).call(this, e2, r2);
    return a2;
  }
  addHighlightHCMFilter(t2, e2, i2, s2, n2) {
    var _a5;
    const a2 = `${e2}-${i2}-${s2}-${n2}`;
    let r2 = __privateGet(this, _DOMFilterFactory_instances, vi_get).get(t2);
    if ((r2 == null ? void 0 : r2.key) === a2) return r2.url;
    if (r2) {
      (_a5 = r2.filter) == null ? void 0 : _a5.remove();
      r2.key = a2;
      r2.url = "none";
      r2.filter = null;
    } else {
      r2 = { key: a2, url: "none", filter: null };
      __privateGet(this, _DOMFilterFactory_instances, vi_get).set(t2, r2);
    }
    if (!e2 || !i2) return r2.url;
    const [o2, l2] = [e2, i2].map(__privateMethod(this, _DOMFilterFactory_instances, Ti_fn).bind(this));
    let h2 = Math.round(0.2126 * o2[0] + 0.7152 * o2[1] + 0.0722 * o2[2]), d2 = Math.round(0.2126 * l2[0] + 0.7152 * l2[1] + 0.0722 * l2[2]), [c2, u2] = [s2, n2].map(__privateMethod(this, _DOMFilterFactory_instances, Ti_fn).bind(this));
    d2 < h2 && ([h2, d2, c2, u2] = [d2, h2, u2, c2]);
    __privateGet(this, _DOMFilterFactory_instances, xi_get).style.color = "";
    const getSteps = (t3, e3, i3) => {
      const s3 = new Array(256), n3 = (d2 - h2) / i3, a3 = t3 / 255, r3 = (e3 - t3) / (255 * i3);
      let o3 = 0;
      for (let t4 = 0; t4 <= i3; t4++) {
        const e4 = Math.round(h2 + t4 * n3), i4 = a3 + t4 * r3;
        for (let t5 = o3; t5 <= e4; t5++) s3[t5] = i4;
        o3 = e4 + 1;
      }
      for (let t4 = o3; t4 < 256; t4++) s3[t4] = s3[o3 - 1];
      return s3.join(",");
    }, p2 = `g_${__privateGet(this, _Ai)}_hcm_${t2}_filter`, g2 = r2.filter = __privateMethod(this, _DOMFilterFactory_instances, Si_fn).call(this, p2);
    __privateMethod(this, _DOMFilterFactory_instances, Mi_fn).call(this, g2);
    __privateMethod(this, _DOMFilterFactory_instances, Ci_fn).call(this, getSteps(c2[0], u2[0], 5), getSteps(c2[1], u2[1], 5), getSteps(c2[2], u2[2], 5), g2);
    r2.url = __privateMethod(this, _DOMFilterFactory_instances, _i_fn).call(this, p2);
    return r2.url;
  }
  destroy(t2 = false) {
    var _a5, _b, _c, _d;
    if (!t2 || !((_a5 = __privateGet(this, _yi)) == null ? void 0 : _a5.size)) {
      (_b = __privateGet(this, _bi)) == null ? void 0 : _b.parentNode.parentNode.remove();
      __privateSet(this, _bi, null);
      (_c = __privateGet(this, _mi)) == null ? void 0 : _c.clear();
      __privateSet(this, _mi, null);
      (_d = __privateGet(this, _yi)) == null ? void 0 : _d.clear();
      __privateSet(this, _yi, null);
      __privateSet(this, _y3, 0);
    }
  }
};
_fi = new WeakMap();
_mi = new WeakMap();
_bi = new WeakMap();
_Ai = new WeakMap();
_wi = new WeakMap();
_yi = new WeakMap();
_y3 = new WeakMap();
_DOMFilterFactory_instances = new WeakSet();
x_get = function() {
  return __privateGet(this, _mi) || __privateSet(this, _mi, /* @__PURE__ */ new Map());
};
vi_get = function() {
  return __privateGet(this, _yi) || __privateSet(this, _yi, /* @__PURE__ */ new Map());
};
xi_get = function() {
  if (!__privateGet(this, _bi)) {
    const t2 = __privateGet(this, _wi).createElement("div"), { style: e2 } = t2;
    e2.visibility = "hidden";
    e2.contain = "strict";
    e2.width = e2.height = 0;
    e2.position = "absolute";
    e2.top = e2.left = 0;
    e2.zIndex = -1;
    const i2 = __privateGet(this, _wi).createElementNS(z, "svg");
    i2.setAttribute("width", 0);
    i2.setAttribute("height", 0);
    __privateSet(this, _bi, __privateGet(this, _wi).createElementNS(z, "defs"));
    t2.append(i2);
    i2.append(__privateGet(this, _bi));
    __privateGet(this, _wi).body.append(t2);
  }
  return __privateGet(this, _bi);
};
Ei_fn = function(t2) {
  if (1 === t2.length) {
    const e3 = t2[0], i3 = new Array(256);
    for (let t3 = 0; t3 < 256; t3++) i3[t3] = e3[t3] / 255;
    const s3 = i3.join(",");
    return [s3, s3, s3];
  }
  const [e2, i2, s2] = t2, n2 = new Array(256), a2 = new Array(256), r2 = new Array(256);
  for (let t3 = 0; t3 < 256; t3++) {
    n2[t3] = e2[t3] / 255;
    a2[t3] = i2[t3] / 255;
    r2[t3] = s2[t3] / 255;
  }
  return [n2.join(","), a2.join(","), r2.join(",")];
};
_i_fn = function(t2) {
  if (void 0 === __privateGet(this, _fi)) {
    __privateSet(this, _fi, "");
    const t3 = __privateGet(this, _wi).URL;
    t3 !== __privateGet(this, _wi).baseURI && (isDataScheme(t3) ? warn('#createUrl: ignore "data:"-URL for performance reasons.') : __privateSet(this, _fi, updateUrlHash(t3, "")));
  }
  return `url(${__privateGet(this, _fi)}#${t2})`;
};
Pi_fn = function(t2) {
  const e2 = __privateGet(this, _wi).createElementNS(z, "feColorMatrix");
  e2.setAttribute("type", "matrix");
  e2.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0");
  t2.append(e2);
};
Mi_fn = function(t2) {
  const e2 = __privateGet(this, _wi).createElementNS(z, "feColorMatrix");
  e2.setAttribute("type", "matrix");
  e2.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0");
  t2.append(e2);
};
Si_fn = function(t2) {
  const e2 = __privateGet(this, _wi).createElementNS(z, "filter");
  e2.setAttribute("color-interpolation-filters", "sRGB");
  e2.setAttribute("id", t2);
  __privateGet(this, _DOMFilterFactory_instances, xi_get).append(e2);
  return e2;
};
ki_fn = function(t2, e2, i2) {
  const s2 = __privateGet(this, _wi).createElementNS(z, e2);
  s2.setAttribute("type", "discrete");
  s2.setAttribute("tableValues", i2);
  t2.append(s2);
};
Ci_fn = function(t2, e2, i2, s2) {
  const n2 = __privateGet(this, _wi).createElementNS(z, "feComponentTransfer");
  s2.append(n2);
  __privateMethod(this, _DOMFilterFactory_instances, ki_fn).call(this, n2, "feFuncR", t2);
  __privateMethod(this, _DOMFilterFactory_instances, ki_fn).call(this, n2, "feFuncG", e2);
  __privateMethod(this, _DOMFilterFactory_instances, ki_fn).call(this, n2, "feFuncB", i2);
};
Di_fn = function(t2, e2) {
  const i2 = __privateGet(this, _wi).createElementNS(z, "feComponentTransfer");
  e2.append(i2);
  __privateMethod(this, _DOMFilterFactory_instances, ki_fn).call(this, i2, "feFuncA", t2);
};
Ti_fn = function(t2) {
  __privateGet(this, _DOMFilterFactory_instances, xi_get).style.color = t2;
  return getRGB(getComputedStyle(__privateGet(this, _DOMFilterFactory_instances, xi_get)).getPropertyValue("color"));
};
var BaseStandardFontDataFactory = class {
  constructor({ baseUrl: t2 = null }) {
    this.baseUrl = t2;
  }
  async fetch({ filename: t2 }) {
    if (!this.baseUrl) throw new Error("Ensure that the `standardFontDataUrl` API parameter is provided.");
    if (!t2) throw new Error("Font filename must be specified.");
    const e2 = `${this.baseUrl}${t2}`;
    return this._fetch(e2).catch((t3) => {
      throw new Error(`Unable to load font data at: ${e2}`);
    });
  }
  async _fetch(t2) {
    unreachable("Abstract method `_fetch` called.");
  }
};
var DOMStandardFontDataFactory = class extends BaseStandardFontDataFactory {
  async _fetch(t2) {
    const e2 = await fetchData(t2, "arraybuffer");
    return new Uint8Array(e2);
  }
};
var BaseWasmFactory = class {
  constructor({ baseUrl: t2 = null }) {
    this.baseUrl = t2;
  }
  async fetch({ filename: t2 }) {
    if (!this.baseUrl) throw new Error("Ensure that the `wasmUrl` API parameter is provided.");
    if (!t2) throw new Error("Wasm filename must be specified.");
    const e2 = `${this.baseUrl}${t2}`;
    return this._fetch(e2).catch((t3) => {
      throw new Error(`Unable to load wasm data at: ${e2}`);
    });
  }
  async _fetch(t2) {
    unreachable("Abstract method `_fetch` called.");
  }
};
var DOMWasmFactory = class extends BaseWasmFactory {
  async _fetch(t2) {
    const e2 = await fetchData(t2, "arraybuffer");
    return new Uint8Array(e2);
  }
};
t && warn("Please use the `legacy` build in Node.js environments.");
async function node_utils_fetchData(t2) {
  const e2 = process.getBuiltinModule("fs"), i2 = await e2.promises.readFile(t2);
  return new Uint8Array(i2);
}
var NodeFilterFactory = class extends BaseFilterFactory {
};
var NodeCanvasFactory = class extends BaseCanvasFactory {
  _createCanvas(t2, e2) {
    return process.getBuiltinModule("module").createRequire(import.meta.url)("@napi-rs/canvas").createCanvas(t2, e2);
  }
};
var NodeCMapReaderFactory = class extends BaseCMapReaderFactory {
  async _fetch(t2) {
    return node_utils_fetchData(t2);
  }
};
var NodeStandardFontDataFactory = class extends BaseStandardFontDataFactory {
  async _fetch(t2) {
    return node_utils_fetchData(t2);
  }
};
var NodeWasmFactory = class extends BaseWasmFactory {
  async _fetch(t2) {
    return node_utils_fetchData(t2);
  }
};
var nt = "Fill";
var at = "Stroke";
var rt = "Shading";
function applyBoundingBox(t2, e2) {
  if (!e2) return;
  const i2 = e2[2] - e2[0], s2 = e2[3] - e2[1], n2 = new Path2D();
  n2.rect(e2[0], e2[1], i2, s2);
  t2.clip(n2);
}
var BaseShadingPattern = class {
  isModifyingCurrentTransform() {
    return false;
  }
  getPattern() {
    unreachable("Abstract method `getPattern` called.");
  }
};
var RadialAxialShadingPattern = class extends BaseShadingPattern {
  constructor(t2) {
    super();
    this._type = t2[1];
    this._bbox = t2[2];
    this._colorStops = t2[3];
    this._p0 = t2[4];
    this._p1 = t2[5];
    this._r0 = t2[6];
    this._r1 = t2[7];
    this.matrix = null;
  }
  _createGradient(t2) {
    let e2;
    "axial" === this._type ? e2 = t2.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : "radial" === this._type && (e2 = t2.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
    for (const t3 of this._colorStops) e2.addColorStop(t3[0], t3[1]);
    return e2;
  }
  getPattern(t2, e2, i2, s2) {
    let n2;
    if (s2 === at || s2 === nt) {
      const a2 = e2.current.getClippedPathBoundingBox(s2, getCurrentTransform(t2)) || [0, 0, 0, 0], r2 = Math.ceil(a2[2] - a2[0]) || 1, o2 = Math.ceil(a2[3] - a2[1]) || 1, l2 = e2.cachedCanvases.getCanvas("pattern", r2, o2), h2 = l2.context;
      h2.clearRect(0, 0, h2.canvas.width, h2.canvas.height);
      h2.beginPath();
      h2.rect(0, 0, h2.canvas.width, h2.canvas.height);
      h2.translate(-a2[0], -a2[1]);
      i2 = Util.transform(i2, [1, 0, 0, 1, a2[0], a2[1]]);
      h2.transform(...e2.baseTransform);
      this.matrix && h2.transform(...this.matrix);
      applyBoundingBox(h2, this._bbox);
      h2.fillStyle = this._createGradient(h2);
      h2.fill();
      n2 = t2.createPattern(l2.canvas, "no-repeat");
      const d2 = new DOMMatrix(i2);
      n2.setTransform(d2);
    } else {
      applyBoundingBox(t2, this._bbox);
      n2 = this._createGradient(t2);
    }
    return n2;
  }
};
function drawTriangle(t2, e2, i2, s2, n2, a2, r2, o2) {
  const l2 = e2.coords, h2 = e2.colors, d2 = t2.data, c2 = 4 * t2.width;
  let u2;
  if (l2[i2 + 1] > l2[s2 + 1]) {
    u2 = i2;
    i2 = s2;
    s2 = u2;
    u2 = a2;
    a2 = r2;
    r2 = u2;
  }
  if (l2[s2 + 1] > l2[n2 + 1]) {
    u2 = s2;
    s2 = n2;
    n2 = u2;
    u2 = r2;
    r2 = o2;
    o2 = u2;
  }
  if (l2[i2 + 1] > l2[s2 + 1]) {
    u2 = i2;
    i2 = s2;
    s2 = u2;
    u2 = a2;
    a2 = r2;
    r2 = u2;
  }
  const p2 = (l2[i2] + e2.offsetX) * e2.scaleX, g2 = (l2[i2 + 1] + e2.offsetY) * e2.scaleY, f2 = (l2[s2] + e2.offsetX) * e2.scaleX, m2 = (l2[s2 + 1] + e2.offsetY) * e2.scaleY, b2 = (l2[n2] + e2.offsetX) * e2.scaleX, A2 = (l2[n2 + 1] + e2.offsetY) * e2.scaleY;
  if (g2 >= A2) return;
  const w2 = h2[a2], y2 = h2[a2 + 1], v2 = h2[a2 + 2], x2 = h2[r2], E2 = h2[r2 + 1], _2 = h2[r2 + 2], S2 = h2[o2], C2 = h2[o2 + 1], T2 = h2[o2 + 2], M2 = Math.round(g2), D2 = Math.round(A2);
  let P2, k2, I2, R2, F2, L2, O2, N2;
  for (let t3 = M2; t3 <= D2; t3++) {
    if (t3 < m2) {
      const e4 = t3 < g2 ? 0 : (g2 - t3) / (g2 - m2);
      P2 = p2 - (p2 - f2) * e4;
      k2 = w2 - (w2 - x2) * e4;
      I2 = y2 - (y2 - E2) * e4;
      R2 = v2 - (v2 - _2) * e4;
    } else {
      let e4;
      e4 = t3 > A2 ? 1 : m2 === A2 ? 0 : (m2 - t3) / (m2 - A2);
      P2 = f2 - (f2 - b2) * e4;
      k2 = x2 - (x2 - S2) * e4;
      I2 = E2 - (E2 - C2) * e4;
      R2 = _2 - (_2 - T2) * e4;
    }
    let e3;
    e3 = t3 < g2 ? 0 : t3 > A2 ? 1 : (g2 - t3) / (g2 - A2);
    F2 = p2 - (p2 - b2) * e3;
    L2 = w2 - (w2 - S2) * e3;
    O2 = y2 - (y2 - C2) * e3;
    N2 = v2 - (v2 - T2) * e3;
    const i3 = Math.round(Math.min(P2, F2)), s3 = Math.round(Math.max(P2, F2));
    let n3 = c2 * t3 + 4 * i3;
    for (let t4 = i3; t4 <= s3; t4++) {
      e3 = (P2 - t4) / (P2 - F2);
      e3 < 0 ? e3 = 0 : e3 > 1 && (e3 = 1);
      d2[n3++] = k2 - (k2 - L2) * e3 | 0;
      d2[n3++] = I2 - (I2 - O2) * e3 | 0;
      d2[n3++] = R2 - (R2 - N2) * e3 | 0;
      d2[n3++] = 255;
    }
  }
}
function drawFigure(t2, e2, i2) {
  const s2 = e2.coords, n2 = e2.colors;
  let a2, r2;
  switch (e2.type) {
    case "lattice":
      const o2 = e2.verticesPerRow, l2 = Math.floor(s2.length / o2) - 1, h2 = o2 - 1;
      for (a2 = 0; a2 < l2; a2++) {
        let e3 = a2 * o2;
        for (let a3 = 0; a3 < h2; a3++, e3++) {
          drawTriangle(t2, i2, s2[e3], s2[e3 + 1], s2[e3 + o2], n2[e3], n2[e3 + 1], n2[e3 + o2]);
          drawTriangle(t2, i2, s2[e3 + o2 + 1], s2[e3 + 1], s2[e3 + o2], n2[e3 + o2 + 1], n2[e3 + 1], n2[e3 + o2]);
        }
      }
      break;
    case "triangles":
      for (a2 = 0, r2 = s2.length; a2 < r2; a2 += 3) drawTriangle(t2, i2, s2[a2], s2[a2 + 1], s2[a2 + 2], n2[a2], n2[a2 + 1], n2[a2 + 2]);
      break;
    default:
      throw new Error("illegal figure");
  }
}
var MeshShadingPattern = class extends BaseShadingPattern {
  constructor(t2) {
    super();
    this._coords = t2[2];
    this._colors = t2[3];
    this._figures = t2[4];
    this._bounds = t2[5];
    this._bbox = t2[6];
    this._background = t2[7];
    this.matrix = null;
  }
  _createMeshCanvas(t2, e2, i2) {
    const s2 = Math.floor(this._bounds[0]), n2 = Math.floor(this._bounds[1]), a2 = Math.ceil(this._bounds[2]) - s2, r2 = Math.ceil(this._bounds[3]) - n2, o2 = Math.min(Math.ceil(Math.abs(a2 * t2[0] * 1.1)), 3e3), l2 = Math.min(Math.ceil(Math.abs(r2 * t2[1] * 1.1)), 3e3), h2 = a2 / o2, d2 = r2 / l2, c2 = { coords: this._coords, colors: this._colors, offsetX: -s2, offsetY: -n2, scaleX: 1 / h2, scaleY: 1 / d2 }, u2 = o2 + 4, p2 = l2 + 4, g2 = i2.getCanvas("mesh", u2, p2), f2 = g2.context, m2 = f2.createImageData(o2, l2);
    if (e2) {
      const t3 = m2.data;
      for (let i3 = 0, s3 = t3.length; i3 < s3; i3 += 4) {
        t3[i3] = e2[0];
        t3[i3 + 1] = e2[1];
        t3[i3 + 2] = e2[2];
        t3[i3 + 3] = 255;
      }
    }
    for (const t3 of this._figures) drawFigure(m2, t3, c2);
    f2.putImageData(m2, 2, 2);
    return { canvas: g2.canvas, offsetX: s2 - 2 * h2, offsetY: n2 - 2 * d2, scaleX: h2, scaleY: d2 };
  }
  isModifyingCurrentTransform() {
    return true;
  }
  getPattern(t2, e2, i2, s2) {
    applyBoundingBox(t2, this._bbox);
    const n2 = new Float32Array(2);
    if (s2 === rt) Util.singularValueDecompose2dScale(getCurrentTransform(t2), n2);
    else if (this.matrix) {
      Util.singularValueDecompose2dScale(this.matrix, n2);
      const [t3, i3] = n2;
      Util.singularValueDecompose2dScale(e2.baseTransform, n2);
      n2[0] *= t3;
      n2[1] *= i3;
    } else Util.singularValueDecompose2dScale(e2.baseTransform, n2);
    const a2 = this._createMeshCanvas(n2, s2 === rt ? null : this._background, e2.cachedCanvases);
    if (s2 !== rt) {
      t2.setTransform(...e2.baseTransform);
      this.matrix && t2.transform(...this.matrix);
    }
    t2.translate(a2.offsetX, a2.offsetY);
    t2.scale(a2.scaleX, a2.scaleY);
    return t2.createPattern(a2.canvas, "no-repeat");
  }
};
var DummyShadingPattern = class extends BaseShadingPattern {
  getPattern() {
    return "hotpink";
  }
};
var ot = 1;
var lt = 2;
var _TilingPattern = class _TilingPattern {
  constructor(t2, e2, i2, s2) {
    this.color = t2[1];
    this.operatorList = t2[2];
    this.matrix = t2[3];
    this.bbox = t2[4];
    this.xstep = t2[5];
    this.ystep = t2[6];
    this.paintType = t2[7];
    this.tilingType = t2[8];
    this.ctx = e2;
    this.canvasGraphicsFactory = i2;
    this.baseTransform = s2;
  }
  createPatternCanvas(t2) {
    const { bbox: e2, operatorList: i2, paintType: s2, tilingType: n2, color: a2, canvasGraphicsFactory: r2 } = this;
    let { xstep: o2, ystep: l2 } = this;
    o2 = Math.abs(o2);
    l2 = Math.abs(l2);
    info("TilingType: " + n2);
    const h2 = e2[0], d2 = e2[1], c2 = e2[2], u2 = e2[3], p2 = c2 - h2, g2 = u2 - d2, f2 = new Float32Array(2);
    Util.singularValueDecompose2dScale(this.matrix, f2);
    const [m2, b2] = f2;
    Util.singularValueDecompose2dScale(this.baseTransform, f2);
    const A2 = m2 * f2[0], w2 = b2 * f2[1];
    let y2 = p2, v2 = g2, x2 = false, E2 = false;
    const _2 = Math.ceil(o2 * A2), S2 = Math.ceil(l2 * w2);
    _2 >= Math.ceil(p2 * A2) ? y2 = o2 : x2 = true;
    S2 >= Math.ceil(g2 * w2) ? v2 = l2 : E2 = true;
    const C2 = this.getSizeAndScale(y2, this.ctx.canvas.width, A2), T2 = this.getSizeAndScale(v2, this.ctx.canvas.height, w2), M2 = t2.cachedCanvases.getCanvas("pattern", C2.size, T2.size), D2 = M2.context, P2 = r2.createCanvasGraphics(D2);
    P2.groupLevel = t2.groupLevel;
    this.setFillAndStrokeStyleToContext(P2, s2, a2);
    D2.translate(-C2.scale * h2, -T2.scale * d2);
    P2.transform(C2.scale, 0, 0, T2.scale, 0, 0);
    D2.save();
    this.clipBbox(P2, h2, d2, c2, u2);
    P2.baseTransform = getCurrentTransform(P2.ctx);
    P2.executeOperatorList(i2);
    P2.endDrawing();
    D2.restore();
    if (x2 || E2) {
      const e3 = M2.canvas;
      x2 && (y2 = o2);
      E2 && (v2 = l2);
      const i3 = this.getSizeAndScale(y2, this.ctx.canvas.width, A2), s3 = this.getSizeAndScale(v2, this.ctx.canvas.height, w2), n3 = i3.size, a3 = s3.size, r3 = t2.cachedCanvases.getCanvas("pattern-workaround", n3, a3), c3 = r3.context, u3 = x2 ? Math.floor(p2 / o2) : 0, f3 = E2 ? Math.floor(g2 / l2) : 0;
      for (let t3 = 0; t3 <= u3; t3++) for (let i4 = 0; i4 <= f3; i4++) c3.drawImage(e3, n3 * t3, a3 * i4, n3, a3, 0, 0, n3, a3);
      return { canvas: r3.canvas, scaleX: i3.scale, scaleY: s3.scale, offsetX: h2, offsetY: d2 };
    }
    return { canvas: M2.canvas, scaleX: C2.scale, scaleY: T2.scale, offsetX: h2, offsetY: d2 };
  }
  getSizeAndScale(t2, e2, i2) {
    const s2 = Math.max(_TilingPattern.MAX_PATTERN_SIZE, e2);
    let n2 = Math.ceil(t2 * i2);
    n2 >= s2 ? n2 = s2 : i2 = n2 / t2;
    return { scale: i2, size: n2 };
  }
  clipBbox(t2, e2, i2, s2, n2) {
    const a2 = s2 - e2, r2 = n2 - i2;
    t2.ctx.rect(e2, i2, a2, r2);
    Util.axialAlignedBoundingBox([e2, i2, s2, n2], getCurrentTransform(t2.ctx), t2.current.minMax);
    t2.clip();
    t2.endPath();
  }
  setFillAndStrokeStyleToContext(t2, e2, i2) {
    const s2 = t2.ctx, n2 = t2.current;
    switch (e2) {
      case ot:
        const { fillStyle: t3, strokeStyle: a2 } = this.ctx;
        s2.fillStyle = n2.fillColor = t3;
        s2.strokeStyle = n2.strokeColor = a2;
        break;
      case lt:
        s2.fillStyle = s2.strokeStyle = i2;
        n2.fillColor = n2.strokeColor = i2;
        break;
      default:
        throw new FormatError(`Unsupported paint type: ${e2}`);
    }
  }
  isModifyingCurrentTransform() {
    return false;
  }
  getPattern(t2, e2, i2, s2) {
    let n2 = i2;
    if (s2 !== rt) {
      n2 = Util.transform(n2, e2.baseTransform);
      this.matrix && (n2 = Util.transform(n2, this.matrix));
    }
    const a2 = this.createPatternCanvas(e2);
    let r2 = new DOMMatrix(n2);
    r2 = r2.translate(a2.offsetX, a2.offsetY);
    r2 = r2.scale(1 / a2.scaleX, 1 / a2.scaleY);
    const o2 = t2.createPattern(a2.canvas, "repeat");
    o2.setTransform(r2);
    return o2;
  }
};
__publicField(_TilingPattern, "MAX_PATTERN_SIZE", 3e3);
var TilingPattern = _TilingPattern;
function convertBlackAndWhiteToRGBA({ src: t2, srcPos: e2 = 0, dest: i2, width: s2, height: n2, nonBlackColor: a2 = 4294967295, inverseDecode: r2 = false }) {
  const o2 = util_FeatureTest.isLittleEndian ? 4278190080 : 255, [l2, h2] = r2 ? [a2, o2] : [o2, a2], d2 = s2 >> 3, c2 = 7 & s2, u2 = t2.length;
  i2 = new Uint32Array(i2.buffer);
  let p2 = 0;
  for (let s3 = 0; s3 < n2; s3++) {
    for (const s5 = e2 + d2; e2 < s5; e2++) {
      const s6 = e2 < u2 ? t2[e2] : 255;
      i2[p2++] = 128 & s6 ? h2 : l2;
      i2[p2++] = 64 & s6 ? h2 : l2;
      i2[p2++] = 32 & s6 ? h2 : l2;
      i2[p2++] = 16 & s6 ? h2 : l2;
      i2[p2++] = 8 & s6 ? h2 : l2;
      i2[p2++] = 4 & s6 ? h2 : l2;
      i2[p2++] = 2 & s6 ? h2 : l2;
      i2[p2++] = 1 & s6 ? h2 : l2;
    }
    if (0 === c2) continue;
    const s4 = e2 < u2 ? t2[e2++] : 255;
    for (let t3 = 0; t3 < c2; t3++) i2[p2++] = s4 & 1 << 7 - t3 ? h2 : l2;
  }
  return { srcPos: e2, destPos: p2 };
}
var ht = 16;
var dt = new DOMMatrix();
var ct = new Float32Array(2);
var ut = new Float32Array([1 / 0, 1 / 0, -1 / 0, -1 / 0]);
var CachedCanvases = class {
  constructor(t2) {
    this.canvasFactory = t2;
    this.cache = /* @__PURE__ */ Object.create(null);
  }
  getCanvas(t2, e2, i2) {
    let s2;
    if (void 0 !== this.cache[t2]) {
      s2 = this.cache[t2];
      this.canvasFactory.reset(s2, e2, i2);
    } else {
      s2 = this.canvasFactory.create(e2, i2);
      this.cache[t2] = s2;
    }
    return s2;
  }
  delete(t2) {
    delete this.cache[t2];
  }
  clear() {
    for (const t2 in this.cache) {
      const e2 = this.cache[t2];
      this.canvasFactory.destroy(e2);
      delete this.cache[t2];
    }
  }
};
function drawImageAtIntegerCoords(t2, e2, i2, s2, n2, a2, r2, o2, l2, h2) {
  const [d2, c2, u2, p2, g2, f2] = getCurrentTransform(t2);
  if (0 === c2 && 0 === u2) {
    const m2 = r2 * d2 + g2, b2 = Math.round(m2), A2 = o2 * p2 + f2, w2 = Math.round(A2), y2 = (r2 + l2) * d2 + g2, v2 = Math.abs(Math.round(y2) - b2) || 1, x2 = (o2 + h2) * p2 + f2, E2 = Math.abs(Math.round(x2) - w2) || 1;
    t2.setTransform(Math.sign(d2), 0, 0, Math.sign(p2), b2, w2);
    t2.drawImage(e2, i2, s2, n2, a2, 0, 0, v2, E2);
    t2.setTransform(d2, c2, u2, p2, g2, f2);
    return [v2, E2];
  }
  if (0 === d2 && 0 === p2) {
    const m2 = o2 * u2 + g2, b2 = Math.round(m2), A2 = r2 * c2 + f2, w2 = Math.round(A2), y2 = (o2 + h2) * u2 + g2, v2 = Math.abs(Math.round(y2) - b2) || 1, x2 = (r2 + l2) * c2 + f2, E2 = Math.abs(Math.round(x2) - w2) || 1;
    t2.setTransform(0, Math.sign(c2), Math.sign(u2), 0, b2, w2);
    t2.drawImage(e2, i2, s2, n2, a2, 0, 0, E2, v2);
    t2.setTransform(d2, c2, u2, p2, g2, f2);
    return [E2, v2];
  }
  t2.drawImage(e2, i2, s2, n2, a2, r2, o2, l2, h2);
  return [Math.hypot(d2, c2) * l2, Math.hypot(u2, p2) * h2];
}
var CanvasExtraState = class {
  constructor(t2, e2) {
    __publicField(this, "alphaIsShape", false);
    __publicField(this, "fontSize", 0);
    __publicField(this, "fontSizeScale", 1);
    __publicField(this, "textMatrix", null);
    __publicField(this, "textMatrixScale", 1);
    __publicField(this, "fontMatrix", e);
    __publicField(this, "leading", 0);
    __publicField(this, "x", 0);
    __publicField(this, "y", 0);
    __publicField(this, "lineX", 0);
    __publicField(this, "lineY", 0);
    __publicField(this, "charSpacing", 0);
    __publicField(this, "wordSpacing", 0);
    __publicField(this, "textHScale", 1);
    __publicField(this, "textRenderingMode", f);
    __publicField(this, "textRise", 0);
    __publicField(this, "fillColor", "#000000");
    __publicField(this, "strokeColor", "#000000");
    __publicField(this, "patternFill", false);
    __publicField(this, "patternStroke", false);
    __publicField(this, "fillAlpha", 1);
    __publicField(this, "strokeAlpha", 1);
    __publicField(this, "lineWidth", 1);
    __publicField(this, "activeSMask", null);
    __publicField(this, "transferMaps", "none");
    this.clipBox = new Float32Array([0, 0, t2, e2]);
    this.minMax = ut.slice();
  }
  clone() {
    const t2 = Object.create(this);
    t2.clipBox = this.clipBox.slice();
    t2.minMax = this.minMax.slice();
    return t2;
  }
  getPathBoundingBox(t2 = nt, e2 = null) {
    const i2 = this.minMax.slice();
    if (t2 === at) {
      e2 || unreachable("Stroke bounding box must include transform.");
      Util.singularValueDecompose2dScale(e2, ct);
      const t3 = ct[0] * this.lineWidth / 2, s2 = ct[1] * this.lineWidth / 2;
      i2[0] -= t3;
      i2[1] -= s2;
      i2[2] += t3;
      i2[3] += s2;
    }
    return i2;
  }
  updateClipFromPath() {
    const t2 = Util.intersect(this.clipBox, this.getPathBoundingBox());
    this.startNewPathAndClipBox(t2 || [0, 0, 0, 0]);
  }
  isEmptyClip() {
    return this.minMax[0] === 1 / 0;
  }
  startNewPathAndClipBox(t2) {
    this.clipBox.set(t2, 0);
    this.minMax.set(ut, 0);
  }
  getClippedPathBoundingBox(t2 = nt, e2 = null) {
    return Util.intersect(this.clipBox, this.getPathBoundingBox(t2, e2));
  }
};
function putBinaryImageData(t2, e2) {
  if (e2 instanceof ImageData) {
    t2.putImageData(e2, 0, 0);
    return;
  }
  const i2 = e2.height, s2 = e2.width, n2 = i2 % ht, a2 = (i2 - n2) / ht, r2 = 0 === n2 ? a2 : a2 + 1, o2 = t2.createImageData(s2, ht);
  let l2, h2 = 0;
  const d2 = e2.data, c2 = o2.data;
  let u2, p2, g2, f2;
  if (e2.kind === v.GRAYSCALE_1BPP) {
    const e3 = d2.byteLength, i3 = new Uint32Array(c2.buffer, 0, c2.byteLength >> 2), f3 = i3.length, m2 = s2 + 7 >> 3, b2 = 4294967295, A2 = util_FeatureTest.isLittleEndian ? 4278190080 : 255;
    for (u2 = 0; u2 < r2; u2++) {
      g2 = u2 < a2 ? ht : n2;
      l2 = 0;
      for (p2 = 0; p2 < g2; p2++) {
        const t3 = e3 - h2;
        let n3 = 0;
        const a3 = t3 > m2 ? s2 : 8 * t3 - 7, r3 = -8 & a3;
        let o3 = 0, c3 = 0;
        for (; n3 < r3; n3 += 8) {
          c3 = d2[h2++];
          i3[l2++] = 128 & c3 ? b2 : A2;
          i3[l2++] = 64 & c3 ? b2 : A2;
          i3[l2++] = 32 & c3 ? b2 : A2;
          i3[l2++] = 16 & c3 ? b2 : A2;
          i3[l2++] = 8 & c3 ? b2 : A2;
          i3[l2++] = 4 & c3 ? b2 : A2;
          i3[l2++] = 2 & c3 ? b2 : A2;
          i3[l2++] = 1 & c3 ? b2 : A2;
        }
        for (; n3 < a3; n3++) {
          if (0 === o3) {
            c3 = d2[h2++];
            o3 = 128;
          }
          i3[l2++] = c3 & o3 ? b2 : A2;
          o3 >>= 1;
        }
      }
      for (; l2 < f3; ) i3[l2++] = 0;
      t2.putImageData(o2, 0, u2 * ht);
    }
  } else if (e2.kind === v.RGBA_32BPP) {
    p2 = 0;
    f2 = s2 * ht * 4;
    for (u2 = 0; u2 < a2; u2++) {
      c2.set(d2.subarray(h2, h2 + f2));
      h2 += f2;
      t2.putImageData(o2, 0, p2);
      p2 += ht;
    }
    if (u2 < r2) {
      f2 = s2 * n2 * 4;
      c2.set(d2.subarray(h2, h2 + f2));
      t2.putImageData(o2, 0, p2);
    }
  } else {
    if (e2.kind !== v.RGB_24BPP) throw new Error(`bad image kind: ${e2.kind}`);
    g2 = ht;
    f2 = s2 * g2;
    for (u2 = 0; u2 < r2; u2++) {
      if (u2 >= a2) {
        g2 = n2;
        f2 = s2 * g2;
      }
      l2 = 0;
      for (p2 = f2; p2--; ) {
        c2[l2++] = d2[h2++];
        c2[l2++] = d2[h2++];
        c2[l2++] = d2[h2++];
        c2[l2++] = 255;
      }
      t2.putImageData(o2, 0, u2 * ht);
    }
  }
}
function putBinaryImageMask(t2, e2) {
  if (e2.bitmap) {
    t2.drawImage(e2.bitmap, 0, 0);
    return;
  }
  const i2 = e2.height, s2 = e2.width, n2 = i2 % ht, a2 = (i2 - n2) / ht, r2 = 0 === n2 ? a2 : a2 + 1, o2 = t2.createImageData(s2, ht);
  let l2 = 0;
  const h2 = e2.data, d2 = o2.data;
  for (let e3 = 0; e3 < r2; e3++) {
    const i3 = e3 < a2 ? ht : n2;
    ({ srcPos: l2 } = convertBlackAndWhiteToRGBA({ src: h2, srcPos: l2, dest: d2, width: s2, height: i3, nonBlackColor: 0 }));
    t2.putImageData(o2, 0, e3 * ht);
  }
}
function copyCtxState(t2, e2) {
  const i2 = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
  for (const s2 of i2) void 0 !== t2[s2] && (e2[s2] = t2[s2]);
  if (void 0 !== t2.setLineDash) {
    e2.setLineDash(t2.getLineDash());
    e2.lineDashOffset = t2.lineDashOffset;
  }
}
function resetCtxToDefault(t2) {
  t2.strokeStyle = t2.fillStyle = "#000000";
  t2.fillRule = "nonzero";
  t2.globalAlpha = 1;
  t2.lineWidth = 1;
  t2.lineCap = "butt";
  t2.lineJoin = "miter";
  t2.miterLimit = 10;
  t2.globalCompositeOperation = "source-over";
  t2.font = "10px sans-serif";
  if (void 0 !== t2.setLineDash) {
    t2.setLineDash([]);
    t2.lineDashOffset = 0;
  }
  const { filter: e2 } = t2;
  "none" !== e2 && "" !== e2 && (t2.filter = "none");
}
function getImageSmoothingEnabled(t2, e2) {
  if (e2) return true;
  Util.singularValueDecompose2dScale(t2, ct);
  const i2 = Math.fround(OutputScale.pixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);
  return ct[0] <= i2 && ct[1] <= i2;
}
var pt = ["butt", "round", "square"];
var gt = ["miter", "round", "bevel"];
var ft = {};
var mt = {};
var _CanvasGraphics_instances, Ii_fn, Ri_fn, Fi_fn;
var _CanvasGraphics = class _CanvasGraphics {
  constructor(t2, e2, i2, s2, n2, { optionalContentConfig: a2, markedContentStack: r2 = null }, o2, l2) {
    __privateAdd(this, _CanvasGraphics_instances);
    this.ctx = t2;
    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
    this.stateStack = [];
    this.pendingClip = null;
    this.pendingEOFill = false;
    this.res = null;
    this.xobjs = null;
    this.commonObjs = e2;
    this.objs = i2;
    this.canvasFactory = s2;
    this.filterFactory = n2;
    this.groupStack = [];
    this.baseTransform = null;
    this.baseTransformStack = [];
    this.groupLevel = 0;
    this.smaskStack = [];
    this.smaskCounter = 0;
    this.tempSMask = null;
    this.suspendedCtx = null;
    this.contentVisible = true;
    this.markedContentStack = r2 || [];
    this.optionalContentConfig = a2;
    this.cachedCanvases = new CachedCanvases(this.canvasFactory);
    this.cachedPatterns = /* @__PURE__ */ new Map();
    this.annotationCanvasMap = o2;
    this.viewportScale = 1;
    this.outputScaleX = 1;
    this.outputScaleY = 1;
    this.pageColors = l2;
    this._cachedScaleForStroking = [-1, 0];
    this._cachedGetSinglePixelWidth = null;
    this._cachedBitmapsMap = /* @__PURE__ */ new Map();
  }
  getObject(t2, e2 = null) {
    return "string" == typeof t2 ? t2.startsWith("g_") ? this.commonObjs.get(t2) : this.objs.get(t2) : e2;
  }
  beginDrawing({ transform: t2, viewport: e2, transparency: i2 = false, background: s2 = null }) {
    const n2 = this.ctx.canvas.width, a2 = this.ctx.canvas.height, r2 = this.ctx.fillStyle;
    this.ctx.fillStyle = s2 || "#ffffff";
    this.ctx.fillRect(0, 0, n2, a2);
    this.ctx.fillStyle = r2;
    if (i2) {
      const t3 = this.cachedCanvases.getCanvas("transparent", n2, a2);
      this.compositeCtx = this.ctx;
      this.transparentCanvas = t3.canvas;
      this.ctx = t3.context;
      this.ctx.save();
      this.ctx.transform(...getCurrentTransform(this.compositeCtx));
    }
    this.ctx.save();
    resetCtxToDefault(this.ctx);
    if (t2) {
      this.ctx.transform(...t2);
      this.outputScaleX = t2[0];
      this.outputScaleY = t2[0];
    }
    this.ctx.transform(...e2.transform);
    this.viewportScale = e2.scale;
    this.baseTransform = getCurrentTransform(this.ctx);
  }
  executeOperatorList(t2, e2, i2, s2) {
    const n2 = t2.argsArray, a2 = t2.fnArray;
    let r2 = e2 || 0;
    const o2 = n2.length;
    if (o2 === r2) return r2;
    const l2 = o2 - r2 > 10 && "function" == typeof i2, h2 = l2 ? Date.now() + 15 : 0;
    let d2 = 0;
    const c2 = this.commonObjs, u2 = this.objs;
    let p2;
    for (; ; ) {
      if (void 0 !== s2 && r2 === s2.nextBreakPoint) {
        s2.breakIt(r2, i2);
        return r2;
      }
      p2 = a2[r2];
      if (p2 !== D.dependency) this[p2].apply(this, n2[r2]);
      else for (const t3 of n2[r2]) {
        const e3 = t3.startsWith("g_") ? c2 : u2;
        if (!e3.has(t3)) {
          e3.get(t3, i2);
          return r2;
        }
      }
      r2++;
      if (r2 === o2) return r2;
      if (l2 && ++d2 > 10) {
        if (Date.now() > h2) {
          i2();
          return r2;
        }
        d2 = 0;
      }
    }
  }
  endDrawing() {
    __privateMethod(this, _CanvasGraphics_instances, Ii_fn).call(this);
    this.cachedCanvases.clear();
    this.cachedPatterns.clear();
    for (const t2 of this._cachedBitmapsMap.values()) {
      for (const e2 of t2.values()) "undefined" != typeof HTMLCanvasElement && e2 instanceof HTMLCanvasElement && (e2.width = e2.height = 0);
      t2.clear();
    }
    this._cachedBitmapsMap.clear();
    __privateMethod(this, _CanvasGraphics_instances, Ri_fn).call(this);
  }
  _scaleImage(t2, e2) {
    const i2 = t2.width ?? t2.displayWidth, s2 = t2.height ?? t2.displayHeight;
    let n2, a2, r2 = Math.max(Math.hypot(e2[0], e2[1]), 1), o2 = Math.max(Math.hypot(e2[2], e2[3]), 1), l2 = i2, h2 = s2, d2 = "prescale1";
    for (; r2 > 2 && l2 > 1 || o2 > 2 && h2 > 1; ) {
      let e3 = l2, i3 = h2;
      if (r2 > 2 && l2 > 1) {
        e3 = l2 >= 16384 ? Math.floor(l2 / 2) - 1 || 1 : Math.ceil(l2 / 2);
        r2 /= l2 / e3;
      }
      if (o2 > 2 && h2 > 1) {
        i3 = h2 >= 16384 ? Math.floor(h2 / 2) - 1 || 1 : Math.ceil(h2) / 2;
        o2 /= h2 / i3;
      }
      n2 = this.cachedCanvases.getCanvas(d2, e3, i3);
      a2 = n2.context;
      a2.clearRect(0, 0, e3, i3);
      a2.drawImage(t2, 0, 0, l2, h2, 0, 0, e3, i3);
      t2 = n2.canvas;
      l2 = e3;
      h2 = i3;
      d2 = "prescale1" === d2 ? "prescale2" : "prescale1";
    }
    return { img: t2, paintWidth: l2, paintHeight: h2 };
  }
  _createMaskCanvas(t2) {
    const e2 = this.ctx, { width: i2, height: s2 } = t2, n2 = this.current.fillColor, a2 = this.current.patternFill, r2 = getCurrentTransform(e2);
    let o2, l2, h2, d2;
    if ((t2.bitmap || t2.data) && t2.count > 1) {
      const e3 = t2.bitmap || t2.data.buffer;
      l2 = JSON.stringify(a2 ? r2 : [r2.slice(0, 4), n2]);
      o2 = this._cachedBitmapsMap.get(e3);
      if (!o2) {
        o2 = /* @__PURE__ */ new Map();
        this._cachedBitmapsMap.set(e3, o2);
      }
      const i3 = o2.get(l2);
      if (i3 && !a2) {
        return { canvas: i3, offsetX: Math.round(Math.min(r2[0], r2[2]) + r2[4]), offsetY: Math.round(Math.min(r2[1], r2[3]) + r2[5]) };
      }
      h2 = i3;
    }
    if (!h2) {
      d2 = this.cachedCanvases.getCanvas("maskCanvas", i2, s2);
      putBinaryImageMask(d2.context, t2);
    }
    let c2 = Util.transform(r2, [1 / i2, 0, 0, -1 / s2, 0, 0]);
    c2 = Util.transform(c2, [1, 0, 0, 1, 0, -s2]);
    const u2 = ut.slice();
    Util.axialAlignedBoundingBox([0, 0, i2, s2], c2, u2);
    const [p2, g2, f2, m2] = u2, b2 = Math.round(f2 - p2) || 1, A2 = Math.round(m2 - g2) || 1, w2 = this.cachedCanvases.getCanvas("fillCanvas", b2, A2), y2 = w2.context, v2 = p2, x2 = g2;
    y2.translate(-v2, -x2);
    y2.transform(...c2);
    if (!h2) {
      h2 = this._scaleImage(d2.canvas, getCurrentTransformInverse(y2));
      h2 = h2.img;
      o2 && a2 && o2.set(l2, h2);
    }
    y2.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(y2), t2.interpolate);
    drawImageAtIntegerCoords(y2, h2, 0, 0, h2.width, h2.height, 0, 0, i2, s2);
    y2.globalCompositeOperation = "source-in";
    const E2 = Util.transform(getCurrentTransformInverse(y2), [1, 0, 0, 1, -v2, -x2]);
    y2.fillStyle = a2 ? n2.getPattern(e2, this, E2, nt) : n2;
    y2.fillRect(0, 0, i2, s2);
    if (o2 && !a2) {
      this.cachedCanvases.delete("fillCanvas");
      o2.set(l2, w2.canvas);
    }
    return { canvas: w2.canvas, offsetX: Math.round(v2), offsetY: Math.round(x2) };
  }
  setLineWidth(t2) {
    t2 !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1);
    this.current.lineWidth = t2;
    this.ctx.lineWidth = t2;
  }
  setLineCap(t2) {
    this.ctx.lineCap = pt[t2];
  }
  setLineJoin(t2) {
    this.ctx.lineJoin = gt[t2];
  }
  setMiterLimit(t2) {
    this.ctx.miterLimit = t2;
  }
  setDash(t2, e2) {
    const i2 = this.ctx;
    if (void 0 !== i2.setLineDash) {
      i2.setLineDash(t2);
      i2.lineDashOffset = e2;
    }
  }
  setRenderingIntent(t2) {
  }
  setFlatness(t2) {
  }
  setGState(t2) {
    for (const [e2, i2] of t2) switch (e2) {
      case "LW":
        this.setLineWidth(i2);
        break;
      case "LC":
        this.setLineCap(i2);
        break;
      case "LJ":
        this.setLineJoin(i2);
        break;
      case "ML":
        this.setMiterLimit(i2);
        break;
      case "D":
        this.setDash(i2[0], i2[1]);
        break;
      case "RI":
        this.setRenderingIntent(i2);
        break;
      case "FL":
        this.setFlatness(i2);
        break;
      case "Font":
        this.setFont(i2[0], i2[1]);
        break;
      case "CA":
        this.current.strokeAlpha = i2;
        break;
      case "ca":
        this.ctx.globalAlpha = this.current.fillAlpha = i2;
        break;
      case "BM":
        this.ctx.globalCompositeOperation = i2;
        break;
      case "SMask":
        this.current.activeSMask = i2 ? this.tempSMask : null;
        this.tempSMask = null;
        this.checkSMaskState();
        break;
      case "TR":
        this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(i2);
    }
  }
  get inSMaskMode() {
    return !!this.suspendedCtx;
  }
  checkSMaskState() {
    const t2 = this.inSMaskMode;
    this.current.activeSMask && !t2 ? this.beginSMaskMode() : !this.current.activeSMask && t2 && this.endSMaskMode();
  }
  beginSMaskMode() {
    if (this.inSMaskMode) throw new Error("beginSMaskMode called while already in smask mode");
    const t2 = this.ctx.canvas.width, e2 = this.ctx.canvas.height, i2 = "smaskGroupAt" + this.groupLevel, s2 = this.cachedCanvases.getCanvas(i2, t2, e2);
    this.suspendedCtx = this.ctx;
    const n2 = this.ctx = s2.context;
    n2.setTransform(this.suspendedCtx.getTransform());
    copyCtxState(this.suspendedCtx, n2);
    !function mirrorContextOperations(t3, e3) {
      if (t3._removeMirroring) throw new Error("Context is already forwarding operations.");
      t3.__originalSave = t3.save;
      t3.__originalRestore = t3.restore;
      t3.__originalRotate = t3.rotate;
      t3.__originalScale = t3.scale;
      t3.__originalTranslate = t3.translate;
      t3.__originalTransform = t3.transform;
      t3.__originalSetTransform = t3.setTransform;
      t3.__originalResetTransform = t3.resetTransform;
      t3.__originalClip = t3.clip;
      t3.__originalMoveTo = t3.moveTo;
      t3.__originalLineTo = t3.lineTo;
      t3.__originalBezierCurveTo = t3.bezierCurveTo;
      t3.__originalRect = t3.rect;
      t3.__originalClosePath = t3.closePath;
      t3.__originalBeginPath = t3.beginPath;
      t3._removeMirroring = () => {
        t3.save = t3.__originalSave;
        t3.restore = t3.__originalRestore;
        t3.rotate = t3.__originalRotate;
        t3.scale = t3.__originalScale;
        t3.translate = t3.__originalTranslate;
        t3.transform = t3.__originalTransform;
        t3.setTransform = t3.__originalSetTransform;
        t3.resetTransform = t3.__originalResetTransform;
        t3.clip = t3.__originalClip;
        t3.moveTo = t3.__originalMoveTo;
        t3.lineTo = t3.__originalLineTo;
        t3.bezierCurveTo = t3.__originalBezierCurveTo;
        t3.rect = t3.__originalRect;
        t3.closePath = t3.__originalClosePath;
        t3.beginPath = t3.__originalBeginPath;
        delete t3._removeMirroring;
      };
      t3.save = function() {
        e3.save();
        this.__originalSave();
      };
      t3.restore = function() {
        e3.restore();
        this.__originalRestore();
      };
      t3.translate = function(t4, i3) {
        e3.translate(t4, i3);
        this.__originalTranslate(t4, i3);
      };
      t3.scale = function(t4, i3) {
        e3.scale(t4, i3);
        this.__originalScale(t4, i3);
      };
      t3.transform = function(t4, i3, s3, n3, a2, r2) {
        e3.transform(t4, i3, s3, n3, a2, r2);
        this.__originalTransform(t4, i3, s3, n3, a2, r2);
      };
      t3.setTransform = function(t4, i3, s3, n3, a2, r2) {
        e3.setTransform(t4, i3, s3, n3, a2, r2);
        this.__originalSetTransform(t4, i3, s3, n3, a2, r2);
      };
      t3.resetTransform = function() {
        e3.resetTransform();
        this.__originalResetTransform();
      };
      t3.rotate = function(t4) {
        e3.rotate(t4);
        this.__originalRotate(t4);
      };
      t3.clip = function(t4) {
        e3.clip(t4);
        this.__originalClip(t4);
      };
      t3.moveTo = function(t4, i3) {
        e3.moveTo(t4, i3);
        this.__originalMoveTo(t4, i3);
      };
      t3.lineTo = function(t4, i3) {
        e3.lineTo(t4, i3);
        this.__originalLineTo(t4, i3);
      };
      t3.bezierCurveTo = function(t4, i3, s3, n3, a2, r2) {
        e3.bezierCurveTo(t4, i3, s3, n3, a2, r2);
        this.__originalBezierCurveTo(t4, i3, s3, n3, a2, r2);
      };
      t3.rect = function(t4, i3, s3, n3) {
        e3.rect(t4, i3, s3, n3);
        this.__originalRect(t4, i3, s3, n3);
      };
      t3.closePath = function() {
        e3.closePath();
        this.__originalClosePath();
      };
      t3.beginPath = function() {
        e3.beginPath();
        this.__originalBeginPath();
      };
    }(n2, this.suspendedCtx);
    this.setGState([["BM", "source-over"]]);
  }
  endSMaskMode() {
    if (!this.inSMaskMode) throw new Error("endSMaskMode called while not in smask mode");
    this.ctx._removeMirroring();
    copyCtxState(this.ctx, this.suspendedCtx);
    this.ctx = this.suspendedCtx;
    this.suspendedCtx = null;
  }
  compose(t2) {
    if (!this.current.activeSMask) return;
    if (t2) {
      t2[0] = Math.floor(t2[0]);
      t2[1] = Math.floor(t2[1]);
      t2[2] = Math.ceil(t2[2]);
      t2[3] = Math.ceil(t2[3]);
    } else t2 = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
    const e2 = this.current.activeSMask, i2 = this.suspendedCtx;
    this.composeSMask(i2, e2, this.ctx, t2);
    this.ctx.save();
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    this.ctx.restore();
  }
  composeSMask(t2, e2, i2, s2) {
    const n2 = s2[0], a2 = s2[1], r2 = s2[2] - n2, o2 = s2[3] - a2;
    if (0 !== r2 && 0 !== o2) {
      this.genericComposeSMask(e2.context, i2, r2, o2, e2.subtype, e2.backdrop, e2.transferMap, n2, a2, e2.offsetX, e2.offsetY);
      t2.save();
      t2.globalAlpha = 1;
      t2.globalCompositeOperation = "source-over";
      t2.setTransform(1, 0, 0, 1, 0, 0);
      t2.drawImage(i2.canvas, 0, 0);
      t2.restore();
    }
  }
  genericComposeSMask(t2, e2, i2, s2, n2, a2, r2, o2, l2, h2, d2) {
    let c2 = t2.canvas, u2 = o2 - h2, p2 = l2 - d2;
    if (a2) if (u2 < 0 || p2 < 0 || u2 + i2 > c2.width || p2 + s2 > c2.height) {
      const t3 = this.cachedCanvases.getCanvas("maskExtension", i2, s2), e3 = t3.context;
      e3.drawImage(c2, -u2, -p2);
      e3.globalCompositeOperation = "destination-atop";
      e3.fillStyle = a2;
      e3.fillRect(0, 0, i2, s2);
      e3.globalCompositeOperation = "source-over";
      c2 = t3.canvas;
      u2 = p2 = 0;
    } else {
      t2.save();
      t2.globalAlpha = 1;
      t2.setTransform(1, 0, 0, 1, 0, 0);
      const e3 = new Path2D();
      e3.rect(u2, p2, i2, s2);
      t2.clip(e3);
      t2.globalCompositeOperation = "destination-atop";
      t2.fillStyle = a2;
      t2.fillRect(u2, p2, i2, s2);
      t2.restore();
    }
    e2.save();
    e2.globalAlpha = 1;
    e2.setTransform(1, 0, 0, 1, 0, 0);
    "Alpha" === n2 && r2 ? e2.filter = this.filterFactory.addAlphaFilter(r2) : "Luminosity" === n2 && (e2.filter = this.filterFactory.addLuminosityFilter(r2));
    const g2 = new Path2D();
    g2.rect(o2, l2, i2, s2);
    e2.clip(g2);
    e2.globalCompositeOperation = "destination-in";
    e2.drawImage(c2, u2, p2, i2, s2, o2, l2, i2, s2);
    e2.restore();
  }
  save() {
    this.inSMaskMode && copyCtxState(this.ctx, this.suspendedCtx);
    this.ctx.save();
    const t2 = this.current;
    this.stateStack.push(t2);
    this.current = t2.clone();
  }
  restore() {
    if (0 !== this.stateStack.length) {
      this.current = this.stateStack.pop();
      this.ctx.restore();
      this.inSMaskMode && copyCtxState(this.suspendedCtx, this.ctx);
      this.checkSMaskState();
      this.pendingClip = null;
      this._cachedScaleForStroking[0] = -1;
      this._cachedGetSinglePixelWidth = null;
    } else this.inSMaskMode && this.endSMaskMode();
  }
  transform(t2, e2, i2, s2, n2, a2) {
    this.ctx.transform(t2, e2, i2, s2, n2, a2);
    this._cachedScaleForStroking[0] = -1;
    this._cachedGetSinglePixelWidth = null;
  }
  constructPath(t2, e2, i2) {
    let [s2] = e2;
    if (i2) {
      if (!(s2 instanceof Path2D)) {
        const t3 = e2[0] = new Path2D();
        for (let e3 = 0, i3 = s2.length; e3 < i3; ) switch (s2[e3++]) {
          case P:
            t3.moveTo(s2[e3++], s2[e3++]);
            break;
          case k:
            t3.lineTo(s2[e3++], s2[e3++]);
            break;
          case I:
            t3.bezierCurveTo(s2[e3++], s2[e3++], s2[e3++], s2[e3++], s2[e3++], s2[e3++]);
            break;
          case R:
            t3.closePath();
            break;
          default:
            warn(`Unrecognized drawing path operator: ${s2[e3 - 1]}`);
        }
        s2 = t3;
      }
      Util.axialAlignedBoundingBox(i2, getCurrentTransform(this.ctx), this.current.minMax);
      this[t2](s2);
    } else {
      s2 || (s2 = e2[0] = new Path2D());
      this[t2](s2);
    }
  }
  closePath() {
    this.ctx.closePath();
  }
  stroke(t2, e2 = true) {
    const i2 = this.ctx, s2 = this.current.strokeColor;
    i2.globalAlpha = this.current.strokeAlpha;
    if (this.contentVisible) if ("object" == typeof s2 && (s2 == null ? void 0 : s2.getPattern)) {
      const e3 = s2.isModifyingCurrentTransform() ? i2.getTransform() : null;
      i2.save();
      i2.strokeStyle = s2.getPattern(i2, this, getCurrentTransformInverse(i2), at);
      if (e3) {
        const s3 = new Path2D();
        s3.addPath(t2, i2.getTransform().invertSelf().multiplySelf(e3));
        t2 = s3;
      }
      this.rescaleAndStroke(t2, false);
      i2.restore();
    } else this.rescaleAndStroke(t2, true);
    e2 && this.consumePath(t2, this.current.getClippedPathBoundingBox(at, getCurrentTransform(this.ctx)));
    i2.globalAlpha = this.current.fillAlpha;
  }
  closeStroke(t2) {
    this.stroke(t2);
  }
  fill(t2, e2 = true) {
    const i2 = this.ctx, s2 = this.current.fillColor;
    let n2 = false;
    if (this.current.patternFill) {
      const e3 = s2.isModifyingCurrentTransform() ? i2.getTransform() : null;
      i2.save();
      i2.fillStyle = s2.getPattern(i2, this, getCurrentTransformInverse(i2), nt);
      if (e3) {
        const s3 = new Path2D();
        s3.addPath(t2, i2.getTransform().invertSelf().multiplySelf(e3));
        t2 = s3;
      }
      n2 = true;
    }
    const a2 = this.current.getClippedPathBoundingBox();
    if (this.contentVisible && null !== a2) if (this.pendingEOFill) {
      i2.fill(t2, "evenodd");
      this.pendingEOFill = false;
    } else i2.fill(t2);
    n2 && i2.restore();
    e2 && this.consumePath(t2, a2);
  }
  eoFill(t2) {
    this.pendingEOFill = true;
    this.fill(t2);
  }
  fillStroke(t2) {
    this.fill(t2, false);
    this.stroke(t2, false);
    this.consumePath(t2);
  }
  eoFillStroke(t2) {
    this.pendingEOFill = true;
    this.fillStroke(t2);
  }
  closeFillStroke(t2) {
    this.fillStroke(t2);
  }
  closeEOFillStroke(t2) {
    this.pendingEOFill = true;
    this.fillStroke(t2);
  }
  endPath(t2) {
    this.consumePath(t2);
  }
  rawFillPath(t2) {
    this.ctx.fill(t2);
  }
  clip() {
    this.pendingClip = ft;
  }
  eoClip() {
    this.pendingClip = mt;
  }
  beginText() {
    this.current.textMatrix = null;
    this.current.textMatrixScale = 1;
    this.current.x = this.current.lineX = 0;
    this.current.y = this.current.lineY = 0;
  }
  endText() {
    const t2 = this.pendingTextPaths, e2 = this.ctx;
    if (void 0 === t2) return;
    const i2 = new Path2D(), s2 = e2.getTransform().invertSelf();
    for (const { transform: e3, x: n2, y: a2, fontSize: r2, path: o2 } of t2) i2.addPath(o2, new DOMMatrix(e3).preMultiplySelf(s2).translate(n2, a2).scale(r2, -r2));
    e2.clip(i2);
    delete this.pendingTextPaths;
  }
  setCharSpacing(t2) {
    this.current.charSpacing = t2;
  }
  setWordSpacing(t2) {
    this.current.wordSpacing = t2;
  }
  setHScale(t2) {
    this.current.textHScale = t2 / 100;
  }
  setLeading(t2) {
    this.current.leading = -t2;
  }
  setFont(t2, i2) {
    var _a5;
    const s2 = this.commonObjs.get(t2), n2 = this.current;
    if (!s2) throw new Error(`Can't find font for ${t2}`);
    n2.fontMatrix = s2.fontMatrix || e;
    0 !== n2.fontMatrix[0] && 0 !== n2.fontMatrix[3] || warn("Invalid font matrix for font " + t2);
    if (i2 < 0) {
      i2 = -i2;
      n2.fontDirection = -1;
    } else n2.fontDirection = 1;
    this.current.font = s2;
    this.current.fontSize = i2;
    if (s2.isType3Font) return;
    const a2 = s2.loadedName || "sans-serif", r2 = ((_a5 = s2.systemFontInfo) == null ? void 0 : _a5.css) || `"${a2}", ${s2.fallbackName}`;
    let o2 = "normal";
    s2.black ? o2 = "900" : s2.bold && (o2 = "bold");
    const l2 = s2.italic ? "italic" : "normal";
    let h2 = i2;
    i2 < 16 ? h2 = 16 : i2 > 100 && (h2 = 100);
    this.current.fontSizeScale = i2 / h2;
    this.ctx.font = `${l2} ${o2} ${h2}px ${r2}`;
  }
  setTextRenderingMode(t2) {
    this.current.textRenderingMode = t2;
  }
  setTextRise(t2) {
    this.current.textRise = t2;
  }
  moveText(t2, e2) {
    this.current.x = this.current.lineX += t2;
    this.current.y = this.current.lineY += e2;
  }
  setLeadingMoveText(t2, e2) {
    this.setLeading(-e2);
    this.moveText(t2, e2);
  }
  setTextMatrix(t2) {
    const { current: e2 } = this;
    e2.textMatrix = t2;
    e2.textMatrixScale = Math.hypot(t2[0], t2[1]);
    e2.x = e2.lineX = 0;
    e2.y = e2.lineY = 0;
  }
  nextLine() {
    this.moveText(0, this.current.leading);
  }
  paintChar(t2, e2, i2, s2, n2) {
    const a2 = this.ctx, r2 = this.current, o2 = r2.font, l2 = r2.textRenderingMode, h2 = r2.fontSize / r2.fontSizeScale, d2 = l2 & w, c2 = !!(l2 & y), u2 = r2.patternFill && !o2.missingFile, p2 = r2.patternStroke && !o2.missingFile;
    let g2;
    (o2.disableFontFace || c2 || u2 || p2) && (g2 = o2.getPathGenerator(this.commonObjs, t2));
    if (o2.disableFontFace || u2 || p2) {
      a2.save();
      a2.translate(e2, i2);
      a2.scale(h2, -h2);
      let t3;
      if (d2 === f || d2 === b) if (s2) {
        t3 = a2.getTransform();
        a2.setTransform(...s2);
        a2.fill(__privateMethod(this, _CanvasGraphics_instances, Fi_fn).call(this, g2, t3, s2));
      } else a2.fill(g2);
      if (d2 === m || d2 === b) if (n2) {
        t3 || (t3 = a2.getTransform());
        a2.setTransform(...n2);
        const { a: e3, b: i3, c: s3, d: r3 } = t3, o3 = Util.inverseTransform(n2), l3 = Util.transform([e3, i3, s3, r3, 0, 0], o3);
        Util.singularValueDecompose2dScale(l3, ct);
        a2.lineWidth *= Math.max(ct[0], ct[1]) / h2;
        a2.stroke(__privateMethod(this, _CanvasGraphics_instances, Fi_fn).call(this, g2, t3, n2));
      } else {
        a2.lineWidth /= h2;
        a2.stroke(g2);
      }
      a2.restore();
    } else {
      d2 !== f && d2 !== b || a2.fillText(t2, e2, i2);
      d2 !== m && d2 !== b || a2.strokeText(t2, e2, i2);
    }
    if (c2) {
      (this.pendingTextPaths || (this.pendingTextPaths = [])).push({ transform: getCurrentTransform(a2), x: e2, y: i2, fontSize: h2, path: g2 });
    }
  }
  get isFontSubpixelAAEnabled() {
    const { context: t2 } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
    t2.scale(1.5, 1);
    t2.fillText("I", 0, 10);
    const e2 = t2.getImageData(0, 0, 10, 10).data;
    let i2 = false;
    for (let t3 = 3; t3 < e2.length; t3 += 4) if (e2[t3] > 0 && e2[t3] < 255) {
      i2 = true;
      break;
    }
    return shadow(this, "isFontSubpixelAAEnabled", i2);
  }
  showText(t2) {
    const e2 = this.current, i2 = e2.font;
    if (i2.isType3Font) return this.showType3Text(t2);
    const s2 = e2.fontSize;
    if (0 === s2) return;
    const n2 = this.ctx, a2 = e2.fontSizeScale, r2 = e2.charSpacing, o2 = e2.wordSpacing, l2 = e2.fontDirection, h2 = e2.textHScale * l2, d2 = t2.length, c2 = i2.vertical, u2 = c2 ? 1 : -1, p2 = i2.defaultVMetrics, g2 = s2 * e2.fontMatrix[0], A2 = e2.textRenderingMode === f && !i2.disableFontFace && !e2.patternFill;
    n2.save();
    e2.textMatrix && n2.transform(...e2.textMatrix);
    n2.translate(e2.x, e2.y + e2.textRise);
    l2 > 0 ? n2.scale(h2, -1) : n2.scale(h2, 1);
    let y2, v2;
    if (e2.patternFill) {
      n2.save();
      const t3 = e2.fillColor.getPattern(n2, this, getCurrentTransformInverse(n2), nt);
      y2 = getCurrentTransform(n2);
      n2.restore();
      n2.fillStyle = t3;
    }
    if (e2.patternStroke) {
      n2.save();
      const t3 = e2.strokeColor.getPattern(n2, this, getCurrentTransformInverse(n2), at);
      v2 = getCurrentTransform(n2);
      n2.restore();
      n2.strokeStyle = t3;
    }
    let x2 = e2.lineWidth;
    const E2 = e2.textMatrixScale;
    if (0 === E2 || 0 === x2) {
      const t3 = e2.textRenderingMode & w;
      t3 !== m && t3 !== b || (x2 = this.getSinglePixelWidth());
    } else x2 /= E2;
    if (1 !== a2) {
      n2.scale(a2, a2);
      x2 /= a2;
    }
    n2.lineWidth = x2;
    if (i2.isInvalidPDFjsFont) {
      const i3 = [];
      let s3 = 0;
      for (const e3 of t2) {
        i3.push(e3.unicode);
        s3 += e3.width;
      }
      n2.fillText(i3.join(""), 0, 0);
      e2.x += s3 * g2 * h2;
      n2.restore();
      this.compose();
      return;
    }
    let _2, S2 = 0;
    for (_2 = 0; _2 < d2; ++_2) {
      const e3 = t2[_2];
      if ("number" == typeof e3) {
        S2 += u2 * e3 * s2 / 1e3;
        continue;
      }
      let h3 = false;
      const d3 = (e3.isSpace ? o2 : 0) + r2, f2 = e3.fontChar, m2 = e3.accent;
      let b2, w2, x3 = e3.width;
      if (c2) {
        const t3 = e3.vmetric || p2, i3 = -(e3.vmetric ? t3[1] : 0.5 * x3) * g2, s3 = t3[2] * g2;
        x3 = t3 ? -t3[0] : x3;
        b2 = i3 / a2;
        w2 = (S2 + s3) / a2;
      } else {
        b2 = S2 / a2;
        w2 = 0;
      }
      if (i2.remeasure && x3 > 0) {
        const t3 = 1e3 * n2.measureText(f2).width / s2 * a2;
        if (x3 < t3 && this.isFontSubpixelAAEnabled) {
          const e4 = x3 / t3;
          h3 = true;
          n2.save();
          n2.scale(e4, 1);
          b2 /= e4;
        } else x3 !== t3 && (b2 += (x3 - t3) / 2e3 * s2 / a2);
      }
      if (this.contentVisible && (e3.isInFont || i2.missingFile)) if (A2 && !m2) n2.fillText(f2, b2, w2);
      else {
        this.paintChar(f2, b2, w2, y2, v2);
        if (m2) {
          const t3 = b2 + s2 * m2.offset.x / a2, e4 = w2 - s2 * m2.offset.y / a2;
          this.paintChar(m2.fontChar, t3, e4, y2, v2);
        }
      }
      S2 += c2 ? x3 * g2 - d3 * l2 : x3 * g2 + d3 * l2;
      h3 && n2.restore();
    }
    c2 ? e2.y -= S2 : e2.x += S2 * h2;
    n2.restore();
    this.compose();
  }
  showType3Text(t2) {
    const i2 = this.ctx, s2 = this.current, n2 = s2.font, a2 = s2.fontSize, r2 = s2.fontDirection, o2 = n2.vertical ? 1 : -1, l2 = s2.charSpacing, h2 = s2.wordSpacing, d2 = s2.textHScale * r2, c2 = s2.fontMatrix || e, u2 = t2.length;
    let p2, g2, f2, m2;
    if (!(s2.textRenderingMode === A) && 0 !== a2) {
      this._cachedScaleForStroking[0] = -1;
      this._cachedGetSinglePixelWidth = null;
      i2.save();
      s2.textMatrix && i2.transform(...s2.textMatrix);
      i2.translate(s2.x, s2.y + s2.textRise);
      i2.scale(d2, r2);
      for (p2 = 0; p2 < u2; ++p2) {
        g2 = t2[p2];
        if ("number" == typeof g2) {
          m2 = o2 * g2 * a2 / 1e3;
          this.ctx.translate(m2, 0);
          s2.x += m2 * d2;
          continue;
        }
        const e2 = (g2.isSpace ? h2 : 0) + l2, r3 = n2.charProcOperatorList[g2.operatorListId];
        if (r3) {
          if (this.contentVisible) {
            this.save();
            i2.scale(a2, a2);
            i2.transform(...c2);
            this.executeOperatorList(r3);
            this.restore();
          }
        } else warn(`Type3 character "${g2.operatorListId}" is not available.`);
        const u3 = [g2.width, 0];
        Util.applyTransform(u3, c2);
        f2 = u3[0] * a2 + e2;
        i2.translate(f2, 0);
        s2.x += f2 * d2;
      }
      i2.restore();
    }
  }
  setCharWidth(t2, e2) {
  }
  setCharWidthAndBounds(t2, e2, i2, s2, n2, a2) {
    const r2 = new Path2D();
    r2.rect(i2, s2, n2 - i2, a2 - s2);
    this.ctx.clip(r2);
    this.endPath();
  }
  getColorN_Pattern(t2) {
    let e2;
    if ("TilingPattern" === t2[0]) {
      const i2 = this.baseTransform || getCurrentTransform(this.ctx), s2 = { createCanvasGraphics: (t3) => new _CanvasGraphics(t3, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, { optionalContentConfig: this.optionalContentConfig, markedContentStack: this.markedContentStack }) };
      e2 = new TilingPattern(t2, this.ctx, s2, i2);
    } else e2 = this._getPattern(t2[1], t2[2]);
    return e2;
  }
  setStrokeColorN() {
    this.current.strokeColor = this.getColorN_Pattern(arguments);
    this.current.patternStroke = true;
  }
  setFillColorN() {
    this.current.fillColor = this.getColorN_Pattern(arguments);
    this.current.patternFill = true;
  }
  setStrokeRGBColor(t2) {
    this.ctx.strokeStyle = this.current.strokeColor = t2;
    this.current.patternStroke = false;
  }
  setStrokeTransparent() {
    this.ctx.strokeStyle = this.current.strokeColor = "transparent";
    this.current.patternStroke = false;
  }
  setFillRGBColor(t2) {
    this.ctx.fillStyle = this.current.fillColor = t2;
    this.current.patternFill = false;
  }
  setFillTransparent() {
    this.ctx.fillStyle = this.current.fillColor = "transparent";
    this.current.patternFill = false;
  }
  _getPattern(t2, e2 = null) {
    let i2;
    if (this.cachedPatterns.has(t2)) i2 = this.cachedPatterns.get(t2);
    else {
      i2 = function getShadingPattern(t3) {
        switch (t3[0]) {
          case "RadialAxial":
            return new RadialAxialShadingPattern(t3);
          case "Mesh":
            return new MeshShadingPattern(t3);
          case "Dummy":
            return new DummyShadingPattern();
        }
        throw new Error(`Unknown IR type: ${t3[0]}`);
      }(this.getObject(t2));
      this.cachedPatterns.set(t2, i2);
    }
    e2 && (i2.matrix = e2);
    return i2;
  }
  shadingFill(t2) {
    if (!this.contentVisible) return;
    const e2 = this.ctx;
    this.save();
    const i2 = this._getPattern(t2);
    e2.fillStyle = i2.getPattern(e2, this, getCurrentTransformInverse(e2), rt);
    const s2 = getCurrentTransformInverse(e2);
    if (s2) {
      const { width: t3, height: i3 } = e2.canvas, n2 = ut.slice();
      Util.axialAlignedBoundingBox([0, 0, t3, i3], s2, n2);
      const [a2, r2, o2, l2] = n2;
      this.ctx.fillRect(a2, r2, o2 - a2, l2 - r2);
    } else this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
    this.compose(this.current.getClippedPathBoundingBox());
    this.restore();
  }
  beginInlineImage() {
    unreachable("Should not call beginInlineImage");
  }
  beginImageData() {
    unreachable("Should not call beginImageData");
  }
  paintFormXObjectBegin(t2, e2) {
    if (this.contentVisible) {
      this.save();
      this.baseTransformStack.push(this.baseTransform);
      t2 && this.transform(...t2);
      this.baseTransform = getCurrentTransform(this.ctx);
      if (e2) {
        Util.axialAlignedBoundingBox(e2, this.baseTransform, this.current.minMax);
        const [t3, i2, s2, n2] = e2, a2 = new Path2D();
        a2.rect(t3, i2, s2 - t3, n2 - i2);
        this.ctx.clip(a2);
        this.endPath();
      }
    }
  }
  paintFormXObjectEnd() {
    if (this.contentVisible) {
      this.restore();
      this.baseTransform = this.baseTransformStack.pop();
    }
  }
  beginGroup(t2) {
    if (!this.contentVisible) return;
    this.save();
    if (this.inSMaskMode) {
      this.endSMaskMode();
      this.current.activeSMask = null;
    }
    const e2 = this.ctx;
    t2.isolated || info("TODO: Support non-isolated groups.");
    t2.knockout && warn("Knockout groups not supported.");
    const i2 = getCurrentTransform(e2);
    t2.matrix && e2.transform(...t2.matrix);
    if (!t2.bbox) throw new Error("Bounding box is required.");
    let s2 = ut.slice();
    Util.axialAlignedBoundingBox(t2.bbox, getCurrentTransform(e2), s2);
    const n2 = [0, 0, e2.canvas.width, e2.canvas.height];
    s2 = Util.intersect(s2, n2) || [0, 0, 0, 0];
    const a2 = Math.floor(s2[0]), r2 = Math.floor(s2[1]), o2 = Math.max(Math.ceil(s2[2]) - a2, 1), l2 = Math.max(Math.ceil(s2[3]) - r2, 1);
    this.current.startNewPathAndClipBox([0, 0, o2, l2]);
    let h2 = "groupAt" + this.groupLevel;
    t2.smask && (h2 += "_smask_" + this.smaskCounter++ % 2);
    const d2 = this.cachedCanvases.getCanvas(h2, o2, l2), c2 = d2.context;
    c2.translate(-a2, -r2);
    c2.transform(...i2);
    let u2 = new Path2D();
    const [p2, g2, f2, m2] = t2.bbox;
    u2.rect(p2, g2, f2 - p2, m2 - g2);
    if (t2.matrix) {
      const e3 = new Path2D();
      e3.addPath(u2, new DOMMatrix(t2.matrix));
      u2 = e3;
    }
    c2.clip(u2);
    if (t2.smask) this.smaskStack.push({ canvas: d2.canvas, context: c2, offsetX: a2, offsetY: r2, subtype: t2.smask.subtype, backdrop: t2.smask.backdrop, transferMap: t2.smask.transferMap || null, startTransformInverse: null });
    else {
      e2.setTransform(1, 0, 0, 1, 0, 0);
      e2.translate(a2, r2);
      e2.save();
    }
    copyCtxState(e2, c2);
    this.ctx = c2;
    this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
    this.groupStack.push(e2);
    this.groupLevel++;
  }
  endGroup(t2) {
    if (!this.contentVisible) return;
    this.groupLevel--;
    const e2 = this.ctx, i2 = this.groupStack.pop();
    this.ctx = i2;
    this.ctx.imageSmoothingEnabled = false;
    if (t2.smask) {
      this.tempSMask = this.smaskStack.pop();
      this.restore();
    } else {
      this.ctx.restore();
      const t3 = getCurrentTransform(this.ctx);
      this.restore();
      this.ctx.save();
      this.ctx.setTransform(...t3);
      const i3 = ut.slice();
      Util.axialAlignedBoundingBox([0, 0, e2.canvas.width, e2.canvas.height], t3, i3);
      this.ctx.drawImage(e2.canvas, 0, 0);
      this.ctx.restore();
      this.compose(i3);
    }
  }
  beginAnnotation(t2, e2, i2, s2, n2) {
    __privateMethod(this, _CanvasGraphics_instances, Ii_fn).call(this);
    resetCtxToDefault(this.ctx);
    this.ctx.save();
    this.save();
    this.baseTransform && this.ctx.setTransform(...this.baseTransform);
    if (e2) {
      const s3 = e2[2] - e2[0], a2 = e2[3] - e2[1];
      if (n2 && this.annotationCanvasMap) {
        (i2 = i2.slice())[4] -= e2[0];
        i2[5] -= e2[1];
        (e2 = e2.slice())[0] = e2[1] = 0;
        e2[2] = s3;
        e2[3] = a2;
        Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx), ct);
        const { viewportScale: n3 } = this, r2 = Math.ceil(s3 * this.outputScaleX * n3), o2 = Math.ceil(a2 * this.outputScaleY * n3);
        this.annotationCanvas = this.canvasFactory.create(r2, o2);
        const { canvas: l2, context: h2 } = this.annotationCanvas;
        this.annotationCanvasMap.set(t2, l2);
        this.annotationCanvas.savedCtx = this.ctx;
        this.ctx = h2;
        this.ctx.save();
        this.ctx.setTransform(ct[0], 0, 0, -ct[1], 0, a2 * ct[1]);
        resetCtxToDefault(this.ctx);
      } else {
        resetCtxToDefault(this.ctx);
        this.endPath();
        const t3 = new Path2D();
        t3.rect(e2[0], e2[1], s3, a2);
        this.ctx.clip(t3);
      }
    }
    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
    this.transform(...i2);
    this.transform(...s2);
  }
  endAnnotation() {
    if (this.annotationCanvas) {
      this.ctx.restore();
      __privateMethod(this, _CanvasGraphics_instances, Ri_fn).call(this);
      this.ctx = this.annotationCanvas.savedCtx;
      delete this.annotationCanvas.savedCtx;
      delete this.annotationCanvas;
    }
  }
  paintImageMaskXObject(t2) {
    if (!this.contentVisible) return;
    const e2 = t2.count;
    (t2 = this.getObject(t2.data, t2)).count = e2;
    const i2 = this.ctx, s2 = this._createMaskCanvas(t2), n2 = s2.canvas;
    i2.save();
    i2.setTransform(1, 0, 0, 1, 0, 0);
    i2.drawImage(n2, s2.offsetX, s2.offsetY);
    i2.restore();
    this.compose();
  }
  paintImageMaskXObjectRepeat(t2, e2, i2 = 0, s2 = 0, n2, a2) {
    if (!this.contentVisible) return;
    t2 = this.getObject(t2.data, t2);
    const r2 = this.ctx;
    r2.save();
    const o2 = getCurrentTransform(r2);
    r2.transform(e2, i2, s2, n2, 0, 0);
    const l2 = this._createMaskCanvas(t2);
    r2.setTransform(1, 0, 0, 1, l2.offsetX - o2[4], l2.offsetY - o2[5]);
    for (let t3 = 0, h2 = a2.length; t3 < h2; t3 += 2) {
      const h3 = Util.transform(o2, [e2, i2, s2, n2, a2[t3], a2[t3 + 1]]);
      r2.drawImage(l2.canvas, h3[4], h3[5]);
    }
    r2.restore();
    this.compose();
  }
  paintImageMaskXObjectGroup(t2) {
    if (!this.contentVisible) return;
    const e2 = this.ctx, i2 = this.current.fillColor, s2 = this.current.patternFill;
    for (const n2 of t2) {
      const { data: t3, width: a2, height: r2, transform: o2 } = n2, l2 = this.cachedCanvases.getCanvas("maskCanvas", a2, r2), h2 = l2.context;
      h2.save();
      putBinaryImageMask(h2, this.getObject(t3, n2));
      h2.globalCompositeOperation = "source-in";
      h2.fillStyle = s2 ? i2.getPattern(h2, this, getCurrentTransformInverse(e2), nt) : i2;
      h2.fillRect(0, 0, a2, r2);
      h2.restore();
      e2.save();
      e2.transform(...o2);
      e2.scale(1, -1);
      drawImageAtIntegerCoords(e2, l2.canvas, 0, 0, a2, r2, 0, -1, 1, 1);
      e2.restore();
    }
    this.compose();
  }
  paintImageXObject(t2) {
    if (!this.contentVisible) return;
    const e2 = this.getObject(t2);
    e2 ? this.paintInlineImageXObject(e2) : warn("Dependent image isn't ready yet");
  }
  paintImageXObjectRepeat(t2, e2, i2, s2) {
    if (!this.contentVisible) return;
    const n2 = this.getObject(t2);
    if (!n2) {
      warn("Dependent image isn't ready yet");
      return;
    }
    const a2 = n2.width, r2 = n2.height, o2 = [];
    for (let t3 = 0, n3 = s2.length; t3 < n3; t3 += 2) o2.push({ transform: [e2, 0, 0, i2, s2[t3], s2[t3 + 1]], x: 0, y: 0, w: a2, h: r2 });
    this.paintInlineImageXObjectGroup(n2, o2);
  }
  applyTransferMapsToCanvas(t2) {
    if ("none" !== this.current.transferMaps) {
      t2.filter = this.current.transferMaps;
      t2.drawImage(t2.canvas, 0, 0);
      t2.filter = "none";
    }
    return t2.canvas;
  }
  applyTransferMapsToBitmap(t2) {
    if ("none" === this.current.transferMaps) return t2.bitmap;
    const { bitmap: e2, width: i2, height: s2 } = t2, n2 = this.cachedCanvases.getCanvas("inlineImage", i2, s2), a2 = n2.context;
    a2.filter = this.current.transferMaps;
    a2.drawImage(e2, 0, 0);
    a2.filter = "none";
    return n2.canvas;
  }
  paintInlineImageXObject(t2) {
    if (!this.contentVisible) return;
    const e2 = t2.width, i2 = t2.height, s2 = this.ctx;
    this.save();
    const { filter: n2 } = s2;
    "none" !== n2 && "" !== n2 && (s2.filter = "none");
    s2.scale(1 / e2, -1 / i2);
    let a2;
    if (t2.bitmap) a2 = this.applyTransferMapsToBitmap(t2);
    else if ("function" == typeof HTMLElement && t2 instanceof HTMLElement || !t2.data) a2 = t2;
    else {
      const s3 = this.cachedCanvases.getCanvas("inlineImage", e2, i2).context;
      putBinaryImageData(s3, t2);
      a2 = this.applyTransferMapsToCanvas(s3);
    }
    const r2 = this._scaleImage(a2, getCurrentTransformInverse(s2));
    s2.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(s2), t2.interpolate);
    drawImageAtIntegerCoords(s2, r2.img, 0, 0, r2.paintWidth, r2.paintHeight, 0, -i2, e2, i2);
    this.compose();
    this.restore();
  }
  paintInlineImageXObjectGroup(t2, e2) {
    if (!this.contentVisible) return;
    const i2 = this.ctx;
    let s2;
    if (t2.bitmap) s2 = t2.bitmap;
    else {
      const e3 = t2.width, i3 = t2.height, n2 = this.cachedCanvases.getCanvas("inlineImage", e3, i3).context;
      putBinaryImageData(n2, t2);
      s2 = this.applyTransferMapsToCanvas(n2);
    }
    for (const t3 of e2) {
      i2.save();
      i2.transform(...t3.transform);
      i2.scale(1, -1);
      drawImageAtIntegerCoords(i2, s2, t3.x, t3.y, t3.w, t3.h, 0, -1, 1, 1);
      i2.restore();
    }
    this.compose();
  }
  paintSolidColorImageMask() {
    if (this.contentVisible) {
      this.ctx.fillRect(0, 0, 1, 1);
      this.compose();
    }
  }
  markPoint(t2) {
  }
  markPointProps(t2, e2) {
  }
  beginMarkedContent(t2) {
    this.markedContentStack.push({ visible: true });
  }
  beginMarkedContentProps(t2, e2) {
    "OC" === t2 ? this.markedContentStack.push({ visible: this.optionalContentConfig.isVisible(e2) }) : this.markedContentStack.push({ visible: true });
    this.contentVisible = this.isContentVisible();
  }
  endMarkedContent() {
    this.markedContentStack.pop();
    this.contentVisible = this.isContentVisible();
  }
  beginCompat() {
  }
  endCompat() {
  }
  consumePath(t2, e2) {
    const i2 = this.current.isEmptyClip();
    this.pendingClip && this.current.updateClipFromPath();
    this.pendingClip || this.compose(e2);
    const s2 = this.ctx;
    if (this.pendingClip) {
      i2 || (this.pendingClip === mt ? s2.clip(t2, "evenodd") : s2.clip(t2));
      this.pendingClip = null;
    }
    this.current.startNewPathAndClipBox(this.current.clipBox);
  }
  getSinglePixelWidth() {
    if (!this._cachedGetSinglePixelWidth) {
      const t2 = getCurrentTransform(this.ctx);
      if (0 === t2[1] && 0 === t2[2]) this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(t2[0]), Math.abs(t2[3]));
      else {
        const e2 = Math.abs(t2[0] * t2[3] - t2[2] * t2[1]), i2 = Math.hypot(t2[0], t2[2]), s2 = Math.hypot(t2[1], t2[3]);
        this._cachedGetSinglePixelWidth = Math.max(i2, s2) / e2;
      }
    }
    return this._cachedGetSinglePixelWidth;
  }
  getScaleForStroking() {
    if (-1 === this._cachedScaleForStroking[0]) {
      const { lineWidth: t2 } = this.current, { a: e2, b: i2, c: s2, d: n2 } = this.ctx.getTransform();
      let a2, r2;
      if (0 === i2 && 0 === s2) {
        const i3 = Math.abs(e2), s3 = Math.abs(n2);
        if (i3 === s3) if (0 === t2) a2 = r2 = 1 / i3;
        else {
          const e3 = i3 * t2;
          a2 = r2 = e3 < 1 ? 1 / e3 : 1;
        }
        else if (0 === t2) {
          a2 = 1 / i3;
          r2 = 1 / s3;
        } else {
          const e3 = i3 * t2, n3 = s3 * t2;
          a2 = e3 < 1 ? 1 / e3 : 1;
          r2 = n3 < 1 ? 1 / n3 : 1;
        }
      } else {
        const o2 = Math.abs(e2 * n2 - i2 * s2), l2 = Math.hypot(e2, i2), h2 = Math.hypot(s2, n2);
        if (0 === t2) {
          a2 = h2 / o2;
          r2 = l2 / o2;
        } else {
          const e3 = t2 * o2;
          a2 = h2 > e3 ? h2 / e3 : 1;
          r2 = l2 > e3 ? l2 / e3 : 1;
        }
      }
      this._cachedScaleForStroking[0] = a2;
      this._cachedScaleForStroking[1] = r2;
    }
    return this._cachedScaleForStroking;
  }
  rescaleAndStroke(t2, e2) {
    const { ctx: i2, current: { lineWidth: s2 } } = this, [n2, a2] = this.getScaleForStroking();
    if (n2 === a2) {
      i2.lineWidth = (s2 || 1) * n2;
      i2.stroke(t2);
      return;
    }
    const r2 = i2.getLineDash();
    e2 && i2.save();
    i2.scale(n2, a2);
    dt.a = 1 / n2;
    dt.d = 1 / a2;
    const o2 = new Path2D();
    o2.addPath(t2, dt);
    if (r2.length > 0) {
      const t3 = Math.max(n2, a2);
      i2.setLineDash(r2.map((e3) => e3 / t3));
      i2.lineDashOffset /= t3;
    }
    i2.lineWidth = s2 || 1;
    i2.stroke(o2);
    e2 && i2.restore();
  }
  isContentVisible() {
    for (let t2 = this.markedContentStack.length - 1; t2 >= 0; t2--) if (!this.markedContentStack[t2].visible) return false;
    return true;
  }
};
_CanvasGraphics_instances = new WeakSet();
Ii_fn = function() {
  for (; this.stateStack.length || this.inSMaskMode; ) this.restore();
  this.current.activeSMask = null;
  this.ctx.restore();
  if (this.transparentCanvas) {
    this.ctx = this.compositeCtx;
    this.ctx.save();
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    this.ctx.drawImage(this.transparentCanvas, 0, 0);
    this.ctx.restore();
    this.transparentCanvas = null;
  }
};
Ri_fn = function() {
  if (this.pageColors) {
    const t2 = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
    if ("none" !== t2) {
      const e2 = this.ctx.filter;
      this.ctx.filter = t2;
      this.ctx.drawImage(this.ctx.canvas, 0, 0);
      this.ctx.filter = e2;
    }
  }
};
Fi_fn = function(t2, e2, i2) {
  const s2 = new Path2D();
  s2.addPath(t2, new DOMMatrix(i2).invertSelf().multiplySelf(e2));
  return s2;
};
var CanvasGraphics = _CanvasGraphics;
for (const t2 in D) void 0 !== CanvasGraphics.prototype[t2] && (CanvasGraphics.prototype[D[t2]] = CanvasGraphics.prototype[t2]);
var _Li, _Oi;
var GlobalWorkerOptions = class {
  static get workerPort() {
    return __privateGet(this, _Li);
  }
  static set workerPort(t2) {
    if (!("undefined" != typeof Worker && t2 instanceof Worker) && null !== t2) throw new Error("Invalid `workerPort` type.");
    __privateSet(this, _Li, t2);
  }
  static get workerSrc() {
    return __privateGet(this, _Oi);
  }
  static set workerSrc(t2) {
    if ("string" != typeof t2) throw new Error("Invalid `workerSrc` type.");
    __privateSet(this, _Oi, t2);
  }
};
_Li = new WeakMap();
_Oi = new WeakMap();
__privateAdd(GlobalWorkerOptions, _Li, null);
__privateAdd(GlobalWorkerOptions, _Oi, "");
var _Ni, _Bi;
var Metadata = class {
  constructor({ parsedData: t2, rawData: e2 }) {
    __privateAdd(this, _Ni);
    __privateAdd(this, _Bi);
    __privateSet(this, _Ni, t2);
    __privateSet(this, _Bi, e2);
  }
  getRaw() {
    return __privateGet(this, _Bi);
  }
  get(t2) {
    return __privateGet(this, _Ni).get(t2) ?? null;
  }
  [Symbol.iterator]() {
    return __privateGet(this, _Ni).entries();
  }
};
_Ni = new WeakMap();
_Bi = new WeakMap();
var bt = Symbol("INTERNAL");
var _Hi, _Ui, _zi, _Gi;
var OptionalContentGroup = class {
  constructor(t2, { name: e2, intent: i2, usage: s2, rbGroups: r2 }) {
    __privateAdd(this, _Hi, false);
    __privateAdd(this, _Ui, false);
    __privateAdd(this, _zi, false);
    __privateAdd(this, _Gi, true);
    __privateSet(this, _Hi, !!(t2 & n));
    __privateSet(this, _Ui, !!(t2 & a));
    this.name = e2;
    this.intent = i2;
    this.usage = s2;
    this.rbGroups = r2;
  }
  get visible() {
    if (__privateGet(this, _zi)) return __privateGet(this, _Gi);
    if (!__privateGet(this, _Gi)) return false;
    const { print: t2, view: e2 } = this.usage;
    return __privateGet(this, _Hi) ? "OFF" !== (e2 == null ? void 0 : e2.viewState) : !__privateGet(this, _Ui) || "OFF" !== (t2 == null ? void 0 : t2.printState);
  }
  _setVisible(t2, e2, i2 = false) {
    t2 !== bt && unreachable("Internal method `_setVisible` called.");
    __privateSet(this, _zi, i2);
    __privateSet(this, _Gi, e2);
  }
};
_Hi = new WeakMap();
_Ui = new WeakMap();
_zi = new WeakMap();
_Gi = new WeakMap();
var _$i, _Wi, _Vi, _ji, _OptionalContentConfig_instances, qi_fn;
var OptionalContentConfig = class {
  constructor(t2, e2 = n) {
    __privateAdd(this, _OptionalContentConfig_instances);
    __privateAdd(this, _$i, null);
    __privateAdd(this, _Wi, /* @__PURE__ */ new Map());
    __privateAdd(this, _Vi, null);
    __privateAdd(this, _ji, null);
    this.renderingIntent = e2;
    this.name = null;
    this.creator = null;
    if (null !== t2) {
      this.name = t2.name;
      this.creator = t2.creator;
      __privateSet(this, _ji, t2.order);
      for (const i2 of t2.groups) __privateGet(this, _Wi).set(i2.id, new OptionalContentGroup(e2, i2));
      if ("OFF" === t2.baseState) for (const t3 of __privateGet(this, _Wi).values()) t3._setVisible(bt, false);
      for (const e3 of t2.on) __privateGet(this, _Wi).get(e3)._setVisible(bt, true);
      for (const e3 of t2.off) __privateGet(this, _Wi).get(e3)._setVisible(bt, false);
      __privateSet(this, _Vi, this.getHash());
    }
  }
  isVisible(t2) {
    if (0 === __privateGet(this, _Wi).size) return true;
    if (!t2) {
      info("Optional content group not defined.");
      return true;
    }
    if ("OCG" === t2.type) {
      if (!__privateGet(this, _Wi).has(t2.id)) {
        warn(`Optional content group not found: ${t2.id}`);
        return true;
      }
      return __privateGet(this, _Wi).get(t2.id).visible;
    }
    if ("OCMD" === t2.type) {
      if (t2.expression) return __privateMethod(this, _OptionalContentConfig_instances, qi_fn).call(this, t2.expression);
      if (!t2.policy || "AnyOn" === t2.policy) {
        for (const e2 of t2.ids) {
          if (!__privateGet(this, _Wi).has(e2)) {
            warn(`Optional content group not found: ${e2}`);
            return true;
          }
          if (__privateGet(this, _Wi).get(e2).visible) return true;
        }
        return false;
      }
      if ("AllOn" === t2.policy) {
        for (const e2 of t2.ids) {
          if (!__privateGet(this, _Wi).has(e2)) {
            warn(`Optional content group not found: ${e2}`);
            return true;
          }
          if (!__privateGet(this, _Wi).get(e2).visible) return false;
        }
        return true;
      }
      if ("AnyOff" === t2.policy) {
        for (const e2 of t2.ids) {
          if (!__privateGet(this, _Wi).has(e2)) {
            warn(`Optional content group not found: ${e2}`);
            return true;
          }
          if (!__privateGet(this, _Wi).get(e2).visible) return true;
        }
        return false;
      }
      if ("AllOff" === t2.policy) {
        for (const e2 of t2.ids) {
          if (!__privateGet(this, _Wi).has(e2)) {
            warn(`Optional content group not found: ${e2}`);
            return true;
          }
          if (__privateGet(this, _Wi).get(e2).visible) return false;
        }
        return true;
      }
      warn(`Unknown optional content policy ${t2.policy}.`);
      return true;
    }
    warn(`Unknown group type ${t2.type}.`);
    return true;
  }
  setVisibility(t2, e2 = true, i2 = true) {
    var _a5;
    const s2 = __privateGet(this, _Wi).get(t2);
    if (s2) {
      if (i2 && e2 && s2.rbGroups.length) for (const e3 of s2.rbGroups) for (const i3 of e3) i3 !== t2 && ((_a5 = __privateGet(this, _Wi).get(i3)) == null ? void 0 : _a5._setVisible(bt, false, true));
      s2._setVisible(bt, !!e2, true);
      __privateSet(this, _$i, null);
    } else warn(`Optional content group not found: ${t2}`);
  }
  setOCGState({ state: t2, preserveRB: e2 }) {
    let i2;
    for (const s2 of t2) {
      switch (s2) {
        case "ON":
        case "OFF":
        case "Toggle":
          i2 = s2;
          continue;
      }
      const t3 = __privateGet(this, _Wi).get(s2);
      if (t3) switch (i2) {
        case "ON":
          this.setVisibility(s2, true, e2);
          break;
        case "OFF":
          this.setVisibility(s2, false, e2);
          break;
        case "Toggle":
          this.setVisibility(s2, !t3.visible, e2);
      }
    }
    __privateSet(this, _$i, null);
  }
  get hasInitialVisibility() {
    return null === __privateGet(this, _Vi) || this.getHash() === __privateGet(this, _Vi);
  }
  getOrder() {
    return __privateGet(this, _Wi).size ? __privateGet(this, _ji) ? __privateGet(this, _ji).slice() : [...__privateGet(this, _Wi).keys()] : null;
  }
  getGroup(t2) {
    return __privateGet(this, _Wi).get(t2) || null;
  }
  getHash() {
    if (null !== __privateGet(this, _$i)) return __privateGet(this, _$i);
    const t2 = new MurmurHash3_64();
    for (const [e2, i2] of __privateGet(this, _Wi)) t2.update(`${e2}:${i2.visible}`);
    return __privateSet(this, _$i, t2.hexdigest());
  }
  [Symbol.iterator]() {
    return __privateGet(this, _Wi).entries();
  }
};
_$i = new WeakMap();
_Wi = new WeakMap();
_Vi = new WeakMap();
_ji = new WeakMap();
_OptionalContentConfig_instances = new WeakSet();
qi_fn = function(t2) {
  const e2 = t2.length;
  if (e2 < 2) return true;
  const i2 = t2[0];
  for (let s2 = 1; s2 < e2; s2++) {
    const e3 = t2[s2];
    let n2;
    if (Array.isArray(e3)) n2 = __privateMethod(this, _OptionalContentConfig_instances, qi_fn).call(this, e3);
    else {
      if (!__privateGet(this, _Wi).has(e3)) {
        warn(`Optional content group not found: ${e3}`);
        return true;
      }
      n2 = __privateGet(this, _Wi).get(e3).visible;
    }
    switch (i2) {
      case "And":
        if (!n2) return false;
        break;
      case "Or":
        if (n2) return true;
        break;
      case "Not":
        return !n2;
      default:
        return true;
    }
  }
  return "And" === i2;
};
var PDFDataTransportStream = class {
  constructor(t2, { disableRange: e2 = false, disableStream: i2 = false }) {
    assert(t2, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
    const { length: s2, initialData: n2, progressiveDone: a2, contentDispositionFilename: r2 } = t2;
    this._queuedChunks = [];
    this._progressiveDone = a2;
    this._contentDispositionFilename = r2;
    if ((n2 == null ? void 0 : n2.length) > 0) {
      const t3 = n2 instanceof Uint8Array && n2.byteLength === n2.buffer.byteLength ? n2.buffer : new Uint8Array(n2).buffer;
      this._queuedChunks.push(t3);
    }
    this._pdfDataRangeTransport = t2;
    this._isStreamingSupported = !i2;
    this._isRangeSupported = !e2;
    this._contentLength = s2;
    this._fullRequestReader = null;
    this._rangeReaders = [];
    t2.addRangeListener((t3, e3) => {
      this._onReceiveData({ begin: t3, chunk: e3 });
    });
    t2.addProgressListener((t3, e3) => {
      this._onProgress({ loaded: t3, total: e3 });
    });
    t2.addProgressiveReadListener((t3) => {
      this._onReceiveData({ chunk: t3 });
    });
    t2.addProgressiveDoneListener(() => {
      this._onProgressiveDone();
    });
    t2.transportReady();
  }
  _onReceiveData({ begin: t2, chunk: e2 }) {
    const i2 = e2 instanceof Uint8Array && e2.byteLength === e2.buffer.byteLength ? e2.buffer : new Uint8Array(e2).buffer;
    if (void 0 === t2) this._fullRequestReader ? this._fullRequestReader._enqueue(i2) : this._queuedChunks.push(i2);
    else {
      assert(this._rangeReaders.some(function(e3) {
        if (e3._begin !== t2) return false;
        e3._enqueue(i2);
        return true;
      }), "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
    }
  }
  get _progressiveDataLength() {
    var _a5;
    return ((_a5 = this._fullRequestReader) == null ? void 0 : _a5._loaded) ?? 0;
  }
  _onProgress(t2) {
    var _a5, _b, _c, _d;
    void 0 === t2.total ? (_b = (_a5 = this._rangeReaders[0]) == null ? void 0 : _a5.onProgress) == null ? void 0 : _b.call(_a5, { loaded: t2.loaded }) : (_d = (_c = this._fullRequestReader) == null ? void 0 : _c.onProgress) == null ? void 0 : _d.call(_c, { loaded: t2.loaded, total: t2.total });
  }
  _onProgressiveDone() {
    var _a5;
    (_a5 = this._fullRequestReader) == null ? void 0 : _a5.progressiveDone();
    this._progressiveDone = true;
  }
  _removeRangeReader(t2) {
    const e2 = this._rangeReaders.indexOf(t2);
    e2 >= 0 && this._rangeReaders.splice(e2, 1);
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
    const t2 = this._queuedChunks;
    this._queuedChunks = null;
    return new PDFDataTransportStreamReader(this, t2, this._progressiveDone, this._contentDispositionFilename);
  }
  getRangeReader(t2, e2) {
    if (e2 <= this._progressiveDataLength) return null;
    const i2 = new PDFDataTransportStreamRangeReader(this, t2, e2);
    this._pdfDataRangeTransport.requestDataRange(t2, e2);
    this._rangeReaders.push(i2);
    return i2;
  }
  cancelAllRequests(t2) {
    var _a5;
    (_a5 = this._fullRequestReader) == null ? void 0 : _a5.cancel(t2);
    for (const e2 of this._rangeReaders.slice(0)) e2.cancel(t2);
    this._pdfDataRangeTransport.abort();
  }
};
var PDFDataTransportStreamReader = class {
  constructor(t2, e2, i2 = false, s2 = null) {
    this._stream = t2;
    this._done = i2 || false;
    this._filename = isPdfFile(s2) ? s2 : null;
    this._queuedChunks = e2 || [];
    this._loaded = 0;
    for (const t3 of this._queuedChunks) this._loaded += t3.byteLength;
    this._requests = [];
    this._headersReady = Promise.resolve();
    t2._fullRequestReader = this;
    this.onProgress = null;
  }
  _enqueue(t2) {
    if (!this._done) {
      if (this._requests.length > 0) {
        this._requests.shift().resolve({ value: t2, done: false });
      } else this._queuedChunks.push(t2);
      this._loaded += t2.byteLength;
    }
  }
  get headersReady() {
    return this._headersReady;
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._stream._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._stream._isStreamingSupported;
  }
  get contentLength() {
    return this._stream._contentLength;
  }
  async read() {
    if (this._queuedChunks.length > 0) {
      return { value: this._queuedChunks.shift(), done: false };
    }
    if (this._done) return { value: void 0, done: true };
    const t2 = Promise.withResolvers();
    this._requests.push(t2);
    return t2.promise;
  }
  cancel(t2) {
    this._done = true;
    for (const t3 of this._requests) t3.resolve({ value: void 0, done: true });
    this._requests.length = 0;
  }
  progressiveDone() {
    this._done || (this._done = true);
  }
};
var PDFDataTransportStreamRangeReader = class {
  constructor(t2, e2, i2) {
    this._stream = t2;
    this._begin = e2;
    this._end = i2;
    this._queuedChunk = null;
    this._requests = [];
    this._done = false;
    this.onProgress = null;
  }
  _enqueue(t2) {
    if (!this._done) {
      if (0 === this._requests.length) this._queuedChunk = t2;
      else {
        this._requests.shift().resolve({ value: t2, done: false });
        for (const t3 of this._requests) t3.resolve({ value: void 0, done: true });
        this._requests.length = 0;
      }
      this._done = true;
      this._stream._removeRangeReader(this);
    }
  }
  get isStreamingSupported() {
    return false;
  }
  async read() {
    if (this._queuedChunk) {
      const t3 = this._queuedChunk;
      this._queuedChunk = null;
      return { value: t3, done: false };
    }
    if (this._done) return { value: void 0, done: true };
    const t2 = Promise.withResolvers();
    this._requests.push(t2);
    return t2.promise;
  }
  cancel(t2) {
    this._done = true;
    for (const t3 of this._requests) t3.resolve({ value: void 0, done: true });
    this._requests.length = 0;
    this._stream._removeRangeReader(this);
  }
};
function createHeaders(t2, e2) {
  const i2 = new Headers();
  if (!t2 || !e2 || "object" != typeof e2) return i2;
  for (const t3 in e2) {
    const s2 = e2[t3];
    void 0 !== s2 && i2.append(t3, s2);
  }
  return i2;
}
function getResponseOrigin(t2) {
  var _a5;
  return ((_a5 = URL.parse(t2)) == null ? void 0 : _a5.origin) ?? null;
}
function validateRangeRequestCapabilities({ responseHeaders: t2, isHttp: e2, rangeChunkSize: i2, disableRange: s2 }) {
  const n2 = { allowRangeRequests: false, suggestedLength: void 0 }, a2 = parseInt(t2.get("Content-Length"), 10);
  if (!Number.isInteger(a2)) return n2;
  n2.suggestedLength = a2;
  if (a2 <= 2 * i2) return n2;
  if (s2 || !e2) return n2;
  if ("bytes" !== t2.get("Accept-Ranges")) return n2;
  if ("identity" !== (t2.get("Content-Encoding") || "identity")) return n2;
  n2.allowRangeRequests = true;
  return n2;
}
function extractFilenameFromHeader(t2) {
  const e2 = t2.get("Content-Disposition");
  if (e2) {
    let t3 = function getFilenameFromContentDispositionHeader(t4) {
      let e3 = true, i2 = toParamRegExp("filename\\*", "i").exec(t4);
      if (i2) {
        i2 = i2[1];
        let t5 = rfc2616unquote(i2);
        t5 = unescape(t5);
        t5 = rfc5987decode(t5);
        t5 = rfc2047decode(t5);
        return fixupEncoding(t5);
      }
      i2 = function rfc2231getparam(t5) {
        const e4 = [];
        let i3;
        const s2 = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
        for (; null !== (i3 = s2.exec(t5)); ) {
          let [, t6, s3, n3] = i3;
          t6 = parseInt(t6, 10);
          if (t6 in e4) {
            if (0 === t6) break;
          } else e4[t6] = [s3, n3];
        }
        const n2 = [];
        for (let t6 = 0; t6 < e4.length && t6 in e4; ++t6) {
          let [i4, s3] = e4[t6];
          s3 = rfc2616unquote(s3);
          if (i4) {
            s3 = unescape(s3);
            0 === t6 && (s3 = rfc5987decode(s3));
          }
          n2.push(s3);
        }
        return n2.join("");
      }(t4);
      if (i2) return fixupEncoding(rfc2047decode(i2));
      i2 = toParamRegExp("filename", "i").exec(t4);
      if (i2) {
        i2 = i2[1];
        let t5 = rfc2616unquote(i2);
        t5 = rfc2047decode(t5);
        return fixupEncoding(t5);
      }
      function toParamRegExp(t5, e4) {
        return new RegExp("(?:^|;)\\s*" + t5 + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', e4);
      }
      function textdecode(t5, i3) {
        if (t5) {
          if (!/^[\x00-\xFF]+$/.test(i3)) return i3;
          try {
            const s2 = new TextDecoder(t5, { fatal: true }), n2 = stringToBytes(i3);
            i3 = s2.decode(n2);
            e3 = false;
          } catch {
          }
        }
        return i3;
      }
      function fixupEncoding(t5) {
        if (e3 && /[\x80-\xff]/.test(t5)) {
          t5 = textdecode("utf-8", t5);
          e3 && (t5 = textdecode("iso-8859-1", t5));
        }
        return t5;
      }
      function rfc2616unquote(t5) {
        if (t5.startsWith('"')) {
          const e4 = t5.slice(1).split('\\"');
          for (let t6 = 0; t6 < e4.length; ++t6) {
            const i3 = e4[t6].indexOf('"');
            if (-1 !== i3) {
              e4[t6] = e4[t6].slice(0, i3);
              e4.length = t6 + 1;
            }
            e4[t6] = e4[t6].replaceAll(/\\(.)/g, "$1");
          }
          t5 = e4.join('"');
        }
        return t5;
      }
      function rfc5987decode(t5) {
        const e4 = t5.indexOf("'");
        return -1 === e4 ? t5 : textdecode(t5.slice(0, e4), t5.slice(e4 + 1).replace(/^[^']*'/, ""));
      }
      function rfc2047decode(t5) {
        return !t5.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(t5) ? t5 : t5.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(t6, e4, i3, s2) {
          if ("q" === i3 || "Q" === i3) return textdecode(e4, s2 = (s2 = s2.replaceAll("_", " ")).replaceAll(/=([0-9a-fA-F]{2})/g, function(t7, e5) {
            return String.fromCharCode(parseInt(e5, 16));
          }));
          try {
            s2 = atob(s2);
          } catch {
          }
          return textdecode(e4, s2);
        });
      }
      return "";
    }(e2);
    if (t3.includes("%")) try {
      t3 = decodeURIComponent(t3);
    } catch {
    }
    if (isPdfFile(t3)) return t3;
  }
  return null;
}
function createResponseError(t2, e2) {
  return new ResponseException(`Unexpected server response (${t2}) while retrieving PDF "${e2}".`, t2, 404 === t2 || 0 === t2 && e2.startsWith("file:"));
}
function validateResponseStatus(t2) {
  return 200 === t2 || 206 === t2;
}
function createFetchOptions(t2, e2, i2) {
  return { method: "GET", headers: t2, signal: i2.signal, mode: "cors", credentials: e2 ? "include" : "same-origin", redirect: "follow" };
}
function getArrayBuffer(t2) {
  if (t2 instanceof Uint8Array) return t2.buffer;
  if (t2 instanceof ArrayBuffer) return t2;
  warn(`getArrayBuffer - unexpected data format: ${t2}`);
  return new Uint8Array(t2).buffer;
}
var PDFFetchStream = class {
  constructor(t2) {
    __publicField(this, "_responseOrigin", null);
    this.source = t2;
    this.isHttp = /^https?:/i.test(t2.url);
    this.headers = createHeaders(this.isHttp, t2.httpHeaders);
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    var _a5;
    return ((_a5 = this._fullRequestReader) == null ? void 0 : _a5._loaded) ?? 0;
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFFetchStreamReader(this);
    return this._fullRequestReader;
  }
  getRangeReader(t2, e2) {
    if (e2 <= this._progressiveDataLength) return null;
    const i2 = new PDFFetchStreamRangeReader(this, t2, e2);
    this._rangeRequestReaders.push(i2);
    return i2;
  }
  cancelAllRequests(t2) {
    var _a5;
    (_a5 = this._fullRequestReader) == null ? void 0 : _a5.cancel(t2);
    for (const e2 of this._rangeRequestReaders.slice(0)) e2.cancel(t2);
  }
};
var PDFFetchStreamReader = class {
  constructor(t2) {
    this._stream = t2;
    this._reader = null;
    this._loaded = 0;
    this._filename = null;
    const e2 = t2.source;
    this._withCredentials = e2.withCredentials || false;
    this._contentLength = e2.length;
    this._headersCapability = Promise.withResolvers();
    this._disableRange = e2.disableRange || false;
    this._rangeChunkSize = e2.rangeChunkSize;
    this._rangeChunkSize || this._disableRange || (this._disableRange = true);
    this._abortController = new AbortController();
    this._isStreamingSupported = !e2.disableStream;
    this._isRangeSupported = !e2.disableRange;
    const i2 = new Headers(t2.headers), s2 = e2.url;
    fetch(s2, createFetchOptions(i2, this._withCredentials, this._abortController)).then((e3) => {
      t2._responseOrigin = getResponseOrigin(e3.url);
      if (!validateResponseStatus(e3.status)) throw createResponseError(e3.status, s2);
      this._reader = e3.body.getReader();
      this._headersCapability.resolve();
      const i3 = e3.headers, { allowRangeRequests: n2, suggestedLength: a2 } = validateRangeRequestCapabilities({ responseHeaders: i3, isHttp: t2.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange });
      this._isRangeSupported = n2;
      this._contentLength = a2 || this._contentLength;
      this._filename = extractFilenameFromHeader(i3);
      !this._isStreamingSupported && this._isRangeSupported && this.cancel(new AbortException("Streaming is disabled."));
    }).catch(this._headersCapability.reject);
    this.onProgress = null;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var _a5;
    await this._headersCapability.promise;
    const { value: t2, done: e2 } = await this._reader.read();
    if (e2) return { value: t2, done: e2 };
    this._loaded += t2.byteLength;
    (_a5 = this.onProgress) == null ? void 0 : _a5.call(this, { loaded: this._loaded, total: this._contentLength });
    return { value: getArrayBuffer(t2), done: false };
  }
  cancel(t2) {
    var _a5;
    (_a5 = this._reader) == null ? void 0 : _a5.cancel(t2);
    this._abortController.abort();
  }
};
var PDFFetchStreamRangeReader = class {
  constructor(t2, e2, i2) {
    this._stream = t2;
    this._reader = null;
    this._loaded = 0;
    const s2 = t2.source;
    this._withCredentials = s2.withCredentials || false;
    this._readCapability = Promise.withResolvers();
    this._isStreamingSupported = !s2.disableStream;
    this._abortController = new AbortController();
    const n2 = new Headers(t2.headers);
    n2.append("Range", `bytes=${e2}-${i2 - 1}`);
    const a2 = s2.url;
    fetch(a2, createFetchOptions(n2, this._withCredentials, this._abortController)).then((e3) => {
      const i3 = getResponseOrigin(e3.url);
      if (i3 !== t2._responseOrigin) throw new Error(`Expected range response-origin "${i3}" to match "${t2._responseOrigin}".`);
      if (!validateResponseStatus(e3.status)) throw createResponseError(e3.status, a2);
      this._readCapability.resolve();
      this._reader = e3.body.getReader();
    }).catch(this._readCapability.reject);
    this.onProgress = null;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var _a5;
    await this._readCapability.promise;
    const { value: t2, done: e2 } = await this._reader.read();
    if (e2) return { value: t2, done: e2 };
    this._loaded += t2.byteLength;
    (_a5 = this.onProgress) == null ? void 0 : _a5.call(this, { loaded: this._loaded });
    return { value: getArrayBuffer(t2), done: false };
  }
  cancel(t2) {
    var _a5;
    (_a5 = this._reader) == null ? void 0 : _a5.cancel(t2);
    this._abortController.abort();
  }
};
var NetworkManager = class {
  constructor({ url: t2, httpHeaders: e2, withCredentials: i2 }) {
    __publicField(this, "_responseOrigin", null);
    this.url = t2;
    this.isHttp = /^https?:/i.test(t2);
    this.headers = createHeaders(this.isHttp, e2);
    this.withCredentials = i2 || false;
    this.currXhrId = 0;
    this.pendingRequests = /* @__PURE__ */ Object.create(null);
  }
  request(t2) {
    const e2 = new XMLHttpRequest(), i2 = this.currXhrId++, s2 = this.pendingRequests[i2] = { xhr: e2 };
    e2.open("GET", this.url);
    e2.withCredentials = this.withCredentials;
    for (const [t3, i3] of this.headers) e2.setRequestHeader(t3, i3);
    if (this.isHttp && "begin" in t2 && "end" in t2) {
      e2.setRequestHeader("Range", `bytes=${t2.begin}-${t2.end - 1}`);
      s2.expectedStatus = 206;
    } else s2.expectedStatus = 200;
    e2.responseType = "arraybuffer";
    assert(t2.onError, "Expected `onError` callback to be provided.");
    e2.onerror = () => {
      t2.onError(e2.status);
    };
    e2.onreadystatechange = this.onStateChange.bind(this, i2);
    e2.onprogress = this.onProgress.bind(this, i2);
    s2.onHeadersReceived = t2.onHeadersReceived;
    s2.onDone = t2.onDone;
    s2.onError = t2.onError;
    s2.onProgress = t2.onProgress;
    e2.send(null);
    return i2;
  }
  onProgress(t2, e2) {
    var _a5;
    const i2 = this.pendingRequests[t2];
    i2 && ((_a5 = i2.onProgress) == null ? void 0 : _a5.call(i2, e2));
  }
  onStateChange(t2, e2) {
    const i2 = this.pendingRequests[t2];
    if (!i2) return;
    const s2 = i2.xhr;
    if (s2.readyState >= 2 && i2.onHeadersReceived) {
      i2.onHeadersReceived();
      delete i2.onHeadersReceived;
    }
    if (4 !== s2.readyState) return;
    if (!(t2 in this.pendingRequests)) return;
    delete this.pendingRequests[t2];
    if (0 === s2.status && this.isHttp) {
      i2.onError(s2.status);
      return;
    }
    const n2 = s2.status || 200;
    if (!(200 === n2 && 206 === i2.expectedStatus) && n2 !== i2.expectedStatus) {
      i2.onError(s2.status);
      return;
    }
    const a2 = function network_getArrayBuffer(t3) {
      const e3 = t3.response;
      return "string" != typeof e3 ? e3 : stringToBytes(e3).buffer;
    }(s2);
    if (206 === n2) {
      const t3 = s2.getResponseHeader("Content-Range"), e3 = /bytes (\d+)-(\d+)\/(\d+)/.exec(t3);
      if (e3) i2.onDone({ begin: parseInt(e3[1], 10), chunk: a2 });
      else {
        warn('Missing or invalid "Content-Range" header.');
        i2.onError(0);
      }
    } else a2 ? i2.onDone({ begin: 0, chunk: a2 }) : i2.onError(s2.status);
  }
  getRequestXhr(t2) {
    return this.pendingRequests[t2].xhr;
  }
  isPendingRequest(t2) {
    return t2 in this.pendingRequests;
  }
  abortRequest(t2) {
    const e2 = this.pendingRequests[t2].xhr;
    delete this.pendingRequests[t2];
    e2.abort();
  }
};
var PDFNetworkStream = class {
  constructor(t2) {
    this._source = t2;
    this._manager = new NetworkManager(t2);
    this._rangeChunkSize = t2.rangeChunkSize;
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  _onRangeRequestReaderClosed(t2) {
    const e2 = this._rangeRequestReaders.indexOf(t2);
    e2 >= 0 && this._rangeRequestReaders.splice(e2, 1);
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
    return this._fullRequestReader;
  }
  getRangeReader(t2, e2) {
    const i2 = new PDFNetworkStreamRangeRequestReader(this._manager, t2, e2);
    i2.onClosed = this._onRangeRequestReaderClosed.bind(this);
    this._rangeRequestReaders.push(i2);
    return i2;
  }
  cancelAllRequests(t2) {
    var _a5;
    (_a5 = this._fullRequestReader) == null ? void 0 : _a5.cancel(t2);
    for (const e2 of this._rangeRequestReaders.slice(0)) e2.cancel(t2);
  }
};
var PDFNetworkStreamFullRequestReader = class {
  constructor(t2, e2) {
    this._manager = t2;
    this._url = e2.url;
    this._fullRequestId = t2.request({ onHeadersReceived: this._onHeadersReceived.bind(this), onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) });
    this._headersCapability = Promise.withResolvers();
    this._disableRange = e2.disableRange || false;
    this._contentLength = e2.length;
    this._rangeChunkSize = e2.rangeChunkSize;
    this._rangeChunkSize || this._disableRange || (this._disableRange = true);
    this._isStreamingSupported = false;
    this._isRangeSupported = false;
    this._cachedChunks = [];
    this._requests = [];
    this._done = false;
    this._storedError = void 0;
    this._filename = null;
    this.onProgress = null;
  }
  _onHeadersReceived() {
    const t2 = this._fullRequestId, e2 = this._manager.getRequestXhr(t2);
    this._manager._responseOrigin = getResponseOrigin(e2.responseURL);
    const i2 = e2.getAllResponseHeaders(), s2 = new Headers(i2 ? i2.trimStart().replace(/[^\S ]+$/, "").split(/[\r\n]+/).map((t3) => {
      const [e3, ...i3] = t3.split(": ");
      return [e3, i3.join(": ")];
    }) : []), { allowRangeRequests: n2, suggestedLength: a2 } = validateRangeRequestCapabilities({ responseHeaders: s2, isHttp: this._manager.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange });
    n2 && (this._isRangeSupported = true);
    this._contentLength = a2 || this._contentLength;
    this._filename = extractFilenameFromHeader(s2);
    this._isRangeSupported && this._manager.abortRequest(t2);
    this._headersCapability.resolve();
  }
  _onDone(t2) {
    if (t2) if (this._requests.length > 0) {
      this._requests.shift().resolve({ value: t2.chunk, done: false });
    } else this._cachedChunks.push(t2.chunk);
    this._done = true;
    if (!(this._cachedChunks.length > 0)) {
      for (const t3 of this._requests) t3.resolve({ value: void 0, done: true });
      this._requests.length = 0;
    }
  }
  _onError(t2) {
    this._storedError = createResponseError(t2, this._url);
    this._headersCapability.reject(this._storedError);
    for (const t3 of this._requests) t3.reject(this._storedError);
    this._requests.length = 0;
    this._cachedChunks.length = 0;
  }
  _onProgress(t2) {
    var _a5;
    (_a5 = this.onProgress) == null ? void 0 : _a5.call(this, { loaded: t2.loaded, total: t2.lengthComputable ? t2.total : this._contentLength });
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get contentLength() {
    return this._contentLength;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  async read() {
    await this._headersCapability.promise;
    if (this._storedError) throw this._storedError;
    if (this._cachedChunks.length > 0) {
      return { value: this._cachedChunks.shift(), done: false };
    }
    if (this._done) return { value: void 0, done: true };
    const t2 = Promise.withResolvers();
    this._requests.push(t2);
    return t2.promise;
  }
  cancel(t2) {
    this._done = true;
    this._headersCapability.reject(t2);
    for (const t3 of this._requests) t3.resolve({ value: void 0, done: true });
    this._requests.length = 0;
    this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId);
    this._fullRequestReader = null;
  }
};
var PDFNetworkStreamRangeRequestReader = class {
  constructor(t2, e2, i2) {
    this._manager = t2;
    this._url = t2.url;
    this._requestId = t2.request({ begin: e2, end: i2, onHeadersReceived: this._onHeadersReceived.bind(this), onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) });
    this._requests = [];
    this._queuedChunk = null;
    this._done = false;
    this._storedError = void 0;
    this.onProgress = null;
    this.onClosed = null;
  }
  _onHeadersReceived() {
    var _a5;
    const t2 = getResponseOrigin((_a5 = this._manager.getRequestXhr(this._requestId)) == null ? void 0 : _a5.responseURL);
    if (t2 !== this._manager._responseOrigin) {
      this._storedError = new Error(`Expected range response-origin "${t2}" to match "${this._manager._responseOrigin}".`);
      this._onError(0);
    }
  }
  _close() {
    var _a5;
    (_a5 = this.onClosed) == null ? void 0 : _a5.call(this, this);
  }
  _onDone(t2) {
    const e2 = t2.chunk;
    if (this._requests.length > 0) {
      this._requests.shift().resolve({ value: e2, done: false });
    } else this._queuedChunk = e2;
    this._done = true;
    for (const t3 of this._requests) t3.resolve({ value: void 0, done: true });
    this._requests.length = 0;
    this._close();
  }
  _onError(t2) {
    this._storedError ?? (this._storedError = createResponseError(t2, this._url));
    for (const t3 of this._requests) t3.reject(this._storedError);
    this._requests.length = 0;
    this._queuedChunk = null;
  }
  _onProgress(t2) {
    var _a5;
    this.isStreamingSupported || ((_a5 = this.onProgress) == null ? void 0 : _a5.call(this, { loaded: t2.loaded }));
  }
  get isStreamingSupported() {
    return false;
  }
  async read() {
    if (this._storedError) throw this._storedError;
    if (null !== this._queuedChunk) {
      const t3 = this._queuedChunk;
      this._queuedChunk = null;
      return { value: t3, done: false };
    }
    if (this._done) return { value: void 0, done: true };
    const t2 = Promise.withResolvers();
    this._requests.push(t2);
    return t2.promise;
  }
  cancel(t2) {
    this._done = true;
    for (const t3 of this._requests) t3.resolve({ value: void 0, done: true });
    this._requests.length = 0;
    this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId);
    this._close();
  }
};
var At = /^[a-z][a-z0-9\-+.]+:/i;
var PDFNodeStream = class {
  constructor(t2) {
    this.source = t2;
    this.url = function parseUrlOrPath(t3) {
      if (At.test(t3)) return new URL(t3);
      const e2 = process.getBuiltinModule("url");
      return new URL(e2.pathToFileURL(t3));
    }(t2.url);
    assert("file:" === this.url.protocol, "PDFNodeStream only supports file:// URLs.");
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    var _a5;
    return ((_a5 = this._fullRequestReader) == null ? void 0 : _a5._loaded) ?? 0;
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFNodeStreamFsFullReader(this);
    return this._fullRequestReader;
  }
  getRangeReader(t2, e2) {
    if (e2 <= this._progressiveDataLength) return null;
    const i2 = new PDFNodeStreamFsRangeReader(this, t2, e2);
    this._rangeRequestReaders.push(i2);
    return i2;
  }
  cancelAllRequests(t2) {
    var _a5;
    (_a5 = this._fullRequestReader) == null ? void 0 : _a5.cancel(t2);
    for (const e2 of this._rangeRequestReaders.slice(0)) e2.cancel(t2);
  }
};
var PDFNodeStreamFsFullReader = class {
  constructor(t2) {
    this._url = t2.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    const e2 = t2.source;
    this._contentLength = e2.length;
    this._loaded = 0;
    this._filename = null;
    this._disableRange = e2.disableRange || false;
    this._rangeChunkSize = e2.rangeChunkSize;
    this._rangeChunkSize || this._disableRange || (this._disableRange = true);
    this._isStreamingSupported = !e2.disableStream;
    this._isRangeSupported = !e2.disableRange;
    this._readableStream = null;
    this._readCapability = Promise.withResolvers();
    this._headersCapability = Promise.withResolvers();
    const i2 = process.getBuiltinModule("fs");
    i2.promises.lstat(this._url).then((t3) => {
      this._contentLength = t3.size;
      this._setReadableStream(i2.createReadStream(this._url));
      this._headersCapability.resolve();
    }, (t3) => {
      "ENOENT" === t3.code && (t3 = createResponseError(0, this._url.href));
      this._storedError = t3;
      this._headersCapability.reject(t3);
    });
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var _a5;
    await this._readCapability.promise;
    if (this._done) return { value: void 0, done: true };
    if (this._storedError) throw this._storedError;
    const t2 = this._readableStream.read();
    if (null === t2) {
      this._readCapability = Promise.withResolvers();
      return this.read();
    }
    this._loaded += t2.length;
    (_a5 = this.onProgress) == null ? void 0 : _a5.call(this, { loaded: this._loaded, total: this._contentLength });
    return { value: new Uint8Array(t2).buffer, done: false };
  }
  cancel(t2) {
    this._readableStream ? this._readableStream.destroy(t2) : this._error(t2);
  }
  _error(t2) {
    this._storedError = t2;
    this._readCapability.resolve();
  }
  _setReadableStream(t2) {
    this._readableStream = t2;
    t2.on("readable", () => {
      this._readCapability.resolve();
    });
    t2.on("end", () => {
      t2.destroy();
      this._done = true;
      this._readCapability.resolve();
    });
    t2.on("error", (t3) => {
      this._error(t3);
    });
    !this._isStreamingSupported && this._isRangeSupported && this._error(new AbortException("streaming is disabled"));
    this._storedError && this._readableStream.destroy(this._storedError);
  }
};
var PDFNodeStreamFsRangeReader = class {
  constructor(t2, e2, i2) {
    this._url = t2.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    this._loaded = 0;
    this._readableStream = null;
    this._readCapability = Promise.withResolvers();
    const s2 = t2.source;
    this._isStreamingSupported = !s2.disableStream;
    const n2 = process.getBuiltinModule("fs");
    this._setReadableStream(n2.createReadStream(this._url, { start: e2, end: i2 - 1 }));
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var _a5;
    await this._readCapability.promise;
    if (this._done) return { value: void 0, done: true };
    if (this._storedError) throw this._storedError;
    const t2 = this._readableStream.read();
    if (null === t2) {
      this._readCapability = Promise.withResolvers();
      return this.read();
    }
    this._loaded += t2.length;
    (_a5 = this.onProgress) == null ? void 0 : _a5.call(this, { loaded: this._loaded });
    return { value: new Uint8Array(t2).buffer, done: false };
  }
  cancel(t2) {
    this._readableStream ? this._readableStream.destroy(t2) : this._error(t2);
  }
  _error(t2) {
    this._storedError = t2;
    this._readCapability.resolve();
  }
  _setReadableStream(t2) {
    this._readableStream = t2;
    t2.on("readable", () => {
      this._readCapability.resolve();
    });
    t2.on("end", () => {
      t2.destroy();
      this._done = true;
      this._readCapability.resolve();
    });
    t2.on("error", (t3) => {
      this._error(t3);
    });
    this._storedError && this._readableStream.destroy(this._storedError);
  }
};
var wt = Symbol("INITIAL_DATA");
var _Xi, _PDFObjects_instances, Ki_fn;
var PDFObjects = class {
  constructor() {
    __privateAdd(this, _PDFObjects_instances);
    __privateAdd(this, _Xi, /* @__PURE__ */ Object.create(null));
  }
  get(t2, e2 = null) {
    if (e2) {
      const i3 = __privateMethod(this, _PDFObjects_instances, Ki_fn).call(this, t2);
      i3.promise.then(() => e2(i3.data));
      return null;
    }
    const i2 = __privateGet(this, _Xi)[t2];
    if (!i2 || i2.data === wt) throw new Error(`Requesting object that isn't resolved yet ${t2}.`);
    return i2.data;
  }
  has(t2) {
    const e2 = __privateGet(this, _Xi)[t2];
    return !!e2 && e2.data !== wt;
  }
  delete(t2) {
    const e2 = __privateGet(this, _Xi)[t2];
    if (!e2 || e2.data === wt) return false;
    delete __privateGet(this, _Xi)[t2];
    return true;
  }
  resolve(t2, e2 = null) {
    const i2 = __privateMethod(this, _PDFObjects_instances, Ki_fn).call(this, t2);
    i2.data = e2;
    i2.resolve();
  }
  clear() {
    var _a5;
    for (const t2 in __privateGet(this, _Xi)) {
      const { data: e2 } = __privateGet(this, _Xi)[t2];
      (_a5 = e2 == null ? void 0 : e2.bitmap) == null ? void 0 : _a5.close();
    }
    __privateSet(this, _Xi, /* @__PURE__ */ Object.create(null));
  }
  *[Symbol.iterator]() {
    for (const t2 in __privateGet(this, _Xi)) {
      const { data: e2 } = __privateGet(this, _Xi)[t2];
      e2 !== wt && (yield [t2, e2]);
    }
  }
};
_Xi = new WeakMap();
_PDFObjects_instances = new WeakSet();
Ki_fn = function(t2) {
  var _a5;
  return (_a5 = __privateGet(this, _Xi))[t2] || (_a5[t2] = { ...Promise.withResolvers(), data: wt });
};
var _a3, _Yi, _mt3, _Qi, _Ji, _Zi, _ts, _es, _is, _ss, _ns, _as, _rs, _os, _ls, _hs, _ds, _cs, _us, _ps, _gs, _fs, _ms, _bs, _TextLayer_instances, ws_fn, xs_fn, vs_fn, _TextLayer_static, ys_fn, _s_fn, As_fn, Es_fn;
var _TextLayer = class _TextLayer {
  constructor({ textContentSource: t2, container: e2, viewport: i2 }) {
    __privateAdd(this, _TextLayer_instances);
    __privateAdd(this, _Yi, Promise.withResolvers());
    __privateAdd(this, _mt3, null);
    __privateAdd(this, _Qi, false);
    __privateAdd(this, _Ji, !!((_a3 = globalThis.FontInspector) == null ? void 0 : _a3.enabled));
    __privateAdd(this, _Zi, null);
    __privateAdd(this, _ts, null);
    __privateAdd(this, _es, 0);
    __privateAdd(this, _is, 0);
    __privateAdd(this, _ss, null);
    __privateAdd(this, _ns, null);
    __privateAdd(this, _as, 0);
    __privateAdd(this, _rs, 0);
    __privateAdd(this, _os, /* @__PURE__ */ Object.create(null));
    __privateAdd(this, _ls, []);
    __privateAdd(this, _hs, null);
    __privateAdd(this, _ds, []);
    __privateAdd(this, _cs, /* @__PURE__ */ new WeakMap());
    __privateAdd(this, _us, null);
    var _a5;
    if (t2 instanceof ReadableStream) __privateSet(this, _hs, t2);
    else {
      if ("object" != typeof t2) throw new Error('No "textContentSource" parameter specified.');
      __privateSet(this, _hs, new ReadableStream({ start(e3) {
        e3.enqueue(t2);
        e3.close();
      } }));
    }
    __privateSet(this, _mt3, __privateSet(this, _ns, e2));
    __privateSet(this, _rs, i2.scale * OutputScale.pixelRatio);
    __privateSet(this, _as, i2.rotation);
    __privateSet(this, _ts, { div: null, properties: null, ctx: null });
    const { pageWidth: s2, pageHeight: n2, pageX: a2, pageY: r2 } = i2.rawDims;
    __privateSet(this, _us, [1, 0, 0, -1, -a2, r2 + n2]);
    __privateSet(this, _is, s2);
    __privateSet(this, _es, n2);
    __privateMethod(_a5 = _TextLayer, _TextLayer_static, As_fn).call(_a5);
    setLayerDimensions(e2, i2);
    __privateGet(this, _Yi).promise.finally(() => {
      __privateGet(_TextLayer, _bs).delete(this);
      __privateSet(this, _ts, null);
      __privateSet(this, _os, null);
    }).catch(() => {
    });
  }
  static get fontFamilyMap() {
    const { isWindows: t2, isFirefox: e2 } = util_FeatureTest.platform;
    return shadow(this, "fontFamilyMap", /* @__PURE__ */ new Map([["sans-serif", (t2 && e2 ? "Calibri, " : "") + "sans-serif"], ["monospace", (t2 && e2 ? "Lucida Console, " : "") + "monospace"]]));
  }
  render() {
    const pump = () => {
      __privateGet(this, _ss).read().then(({ value: t2, done: e2 }) => {
        if (e2) __privateGet(this, _Yi).resolve();
        else {
          __privateGet(this, _Zi) ?? __privateSet(this, _Zi, t2.lang);
          Object.assign(__privateGet(this, _os), t2.styles);
          __privateMethod(this, _TextLayer_instances, ws_fn).call(this, t2.items);
          pump();
        }
      }, __privateGet(this, _Yi).reject);
    };
    __privateSet(this, _ss, __privateGet(this, _hs).getReader());
    __privateGet(_TextLayer, _bs).add(this);
    pump();
    return __privateGet(this, _Yi).promise;
  }
  update({ viewport: t2, onBefore: e2 = null }) {
    var _a5;
    const i2 = t2.scale * OutputScale.pixelRatio, s2 = t2.rotation;
    if (s2 !== __privateGet(this, _as)) {
      e2 == null ? void 0 : e2();
      __privateSet(this, _as, s2);
      setLayerDimensions(__privateGet(this, _ns), { rotation: s2 });
    }
    if (i2 !== __privateGet(this, _rs)) {
      e2 == null ? void 0 : e2();
      __privateSet(this, _rs, i2);
      const t3 = { div: null, properties: null, ctx: __privateMethod(_a5 = _TextLayer, _TextLayer_static, ys_fn).call(_a5, __privateGet(this, _Zi)) };
      for (const e3 of __privateGet(this, _ds)) {
        t3.properties = __privateGet(this, _cs).get(e3);
        t3.div = e3;
        __privateMethod(this, _TextLayer_instances, vs_fn).call(this, t3);
      }
    }
  }
  cancel() {
    var _a5;
    const t2 = new AbortException("TextLayer task cancelled.");
    (_a5 = __privateGet(this, _ss)) == null ? void 0 : _a5.cancel(t2).catch(() => {
    });
    __privateSet(this, _ss, null);
    __privateGet(this, _Yi).reject(t2);
  }
  get textDivs() {
    return __privateGet(this, _ds);
  }
  get textContentItemsStr() {
    return __privateGet(this, _ls);
  }
  static cleanup() {
    if (!(__privateGet(this, _bs).size > 0)) {
      __privateGet(this, _ps).clear();
      for (const { canvas: t2 } of __privateGet(this, _gs).values()) t2.remove();
      __privateGet(this, _gs).clear();
    }
  }
};
_Yi = new WeakMap();
_mt3 = new WeakMap();
_Qi = new WeakMap();
_Ji = new WeakMap();
_Zi = new WeakMap();
_ts = new WeakMap();
_es = new WeakMap();
_is = new WeakMap();
_ss = new WeakMap();
_ns = new WeakMap();
_as = new WeakMap();
_rs = new WeakMap();
_os = new WeakMap();
_ls = new WeakMap();
_hs = new WeakMap();
_ds = new WeakMap();
_cs = new WeakMap();
_us = new WeakMap();
_ps = new WeakMap();
_gs = new WeakMap();
_fs = new WeakMap();
_ms = new WeakMap();
_bs = new WeakMap();
_TextLayer_instances = new WeakSet();
ws_fn = function(t2) {
  var _a5, _b;
  if (__privateGet(this, _Qi)) return;
  (_b = __privateGet(this, _ts)).ctx ?? (_b.ctx = __privateMethod(_a5 = _TextLayer, _TextLayer_static, ys_fn).call(_a5, __privateGet(this, _Zi)));
  const e2 = __privateGet(this, _ds), i2 = __privateGet(this, _ls);
  for (const s2 of t2) {
    if (e2.length > 1e5) {
      warn("Ignoring additional textDivs for performance reasons.");
      __privateSet(this, _Qi, true);
      return;
    }
    if (void 0 !== s2.str) {
      i2.push(s2.str);
      __privateMethod(this, _TextLayer_instances, xs_fn).call(this, s2);
    } else if ("beginMarkedContentProps" === s2.type || "beginMarkedContent" === s2.type) {
      const t3 = __privateGet(this, _mt3);
      __privateSet(this, _mt3, document.createElement("span"));
      __privateGet(this, _mt3).classList.add("markedContent");
      null !== s2.id && __privateGet(this, _mt3).setAttribute("id", `${s2.id}`);
      t3.append(__privateGet(this, _mt3));
    } else "endMarkedContent" === s2.type && __privateSet(this, _mt3, __privateGet(this, _mt3).parentNode);
  }
};
xs_fn = function(t2) {
  var _a5;
  const e2 = document.createElement("span"), i2 = { angle: 0, canvasWidth: 0, hasText: "" !== t2.str, hasEOL: t2.hasEOL, fontSize: 0 };
  __privateGet(this, _ds).push(e2);
  const s2 = Util.transform(__privateGet(this, _us), t2.transform);
  let n2 = Math.atan2(s2[1], s2[0]);
  const a2 = __privateGet(this, _os)[t2.fontName];
  a2.vertical && (n2 += Math.PI / 2);
  let r2 = __privateGet(this, _Ji) && a2.fontSubstitution || a2.fontFamily;
  r2 = _TextLayer.fontFamilyMap.get(r2) || r2;
  const o2 = Math.hypot(s2[2], s2[3]), l2 = o2 * __privateMethod(_a5 = _TextLayer, _TextLayer_static, Es_fn).call(_a5, r2, a2, __privateGet(this, _Zi));
  let h2, d2;
  if (0 === n2) {
    h2 = s2[4];
    d2 = s2[5] - l2;
  } else {
    h2 = s2[4] + l2 * Math.sin(n2);
    d2 = s2[5] - l2 * Math.cos(n2);
  }
  const c2 = "calc(var(--total-scale-factor) *", u2 = e2.style;
  if (__privateGet(this, _mt3) === __privateGet(this, _ns)) {
    u2.left = `${(100 * h2 / __privateGet(this, _is)).toFixed(2)}%`;
    u2.top = `${(100 * d2 / __privateGet(this, _es)).toFixed(2)}%`;
  } else {
    u2.left = `${c2}${h2.toFixed(2)}px)`;
    u2.top = `${c2}${d2.toFixed(2)}px)`;
  }
  u2.fontSize = `${c2}${(__privateGet(_TextLayer, _ms) * o2).toFixed(2)}px)`;
  u2.fontFamily = r2;
  i2.fontSize = o2;
  e2.setAttribute("role", "presentation");
  e2.textContent = t2.str;
  e2.dir = t2.dir;
  __privateGet(this, _Ji) && (e2.dataset.fontName = a2.fontSubstitutionLoadedName || t2.fontName);
  0 !== n2 && (i2.angle = n2 * (180 / Math.PI));
  let p2 = false;
  if (t2.str.length > 1) p2 = true;
  else if (" " !== t2.str && t2.transform[0] !== t2.transform[3]) {
    const e3 = Math.abs(t2.transform[0]), i3 = Math.abs(t2.transform[3]);
    e3 !== i3 && Math.max(e3, i3) / Math.min(e3, i3) > 1.5 && (p2 = true);
  }
  p2 && (i2.canvasWidth = a2.vertical ? t2.height : t2.width);
  __privateGet(this, _cs).set(e2, i2);
  __privateGet(this, _ts).div = e2;
  __privateGet(this, _ts).properties = i2;
  __privateMethod(this, _TextLayer_instances, vs_fn).call(this, __privateGet(this, _ts));
  i2.hasText && __privateGet(this, _mt3).append(e2);
  if (i2.hasEOL) {
    const t3 = document.createElement("br");
    t3.setAttribute("role", "presentation");
    __privateGet(this, _mt3).append(t3);
  }
};
vs_fn = function(t2) {
  var _a5;
  const { div: e2, properties: i2, ctx: s2 } = t2, { style: n2 } = e2;
  let a2 = "";
  __privateGet(_TextLayer, _ms) > 1 && (a2 = `scale(${1 / __privateGet(_TextLayer, _ms)})`);
  if (0 !== i2.canvasWidth && i2.hasText) {
    const { fontFamily: t3 } = n2, { canvasWidth: r2, fontSize: o2 } = i2;
    __privateMethod(_a5 = _TextLayer, _TextLayer_static, _s_fn).call(_a5, s2, o2 * __privateGet(this, _rs), t3);
    const { width: l2 } = s2.measureText(e2.textContent);
    l2 > 0 && (a2 = `scaleX(${r2 * __privateGet(this, _rs) / l2}) ${a2}`);
  }
  0 !== i2.angle && (a2 = `rotate(${i2.angle}deg) ${a2}`);
  a2.length > 0 && (n2.transform = a2);
};
_TextLayer_static = new WeakSet();
ys_fn = function(t2 = null) {
  let e2 = __privateGet(this, _gs).get(t2 || (t2 = ""));
  if (!e2) {
    const i2 = document.createElement("canvas");
    i2.className = "hiddenCanvasElement";
    i2.lang = t2;
    document.body.append(i2);
    e2 = i2.getContext("2d", { alpha: false, willReadFrequently: true });
    __privateGet(this, _gs).set(t2, e2);
    __privateGet(this, _fs).set(e2, { size: 0, family: "" });
  }
  return e2;
};
_s_fn = function(t2, e2, i2) {
  const s2 = __privateGet(this, _fs).get(t2);
  if (e2 !== s2.size || i2 !== s2.family) {
    t2.font = `${e2}px ${i2}`;
    s2.size = e2;
    s2.family = i2;
  }
};
As_fn = function() {
  if (null !== __privateGet(this, _ms)) return;
  const t2 = document.createElement("div");
  t2.style.opacity = 0;
  t2.style.lineHeight = 1;
  t2.style.fontSize = "1px";
  t2.style.position = "absolute";
  t2.textContent = "X";
  document.body.append(t2);
  __privateSet(this, _ms, t2.getBoundingClientRect().height);
  t2.remove();
};
Es_fn = function(t2, e2, i2) {
  const s2 = __privateGet(this, _ps).get(t2);
  if (s2) return s2;
  const n2 = __privateMethod(this, _TextLayer_static, ys_fn).call(this, i2);
  n2.canvas.width = n2.canvas.height = 30;
  __privateMethod(this, _TextLayer_static, _s_fn).call(this, n2, 30, t2);
  const a2 = n2.measureText(""), r2 = a2.fontBoundingBoxAscent, o2 = Math.abs(a2.fontBoundingBoxDescent);
  n2.canvas.width = n2.canvas.height = 0;
  let l2 = 0.8;
  if (r2) l2 = r2 / (r2 + o2);
  else {
    util_FeatureTest.platform.isFirefox && warn("Enable the `dom.textMetrics.fontBoundingBox.enabled` preference in `about:config` to improve TextLayer rendering.");
    e2.ascent ? l2 = e2.ascent : e2.descent && (l2 = 1 + e2.descent);
  }
  __privateGet(this, _ps).set(t2, l2);
  return l2;
};
__privateAdd(_TextLayer, _TextLayer_static);
__privateAdd(_TextLayer, _ps, /* @__PURE__ */ new Map());
__privateAdd(_TextLayer, _gs, /* @__PURE__ */ new Map());
__privateAdd(_TextLayer, _fs, /* @__PURE__ */ new WeakMap());
__privateAdd(_TextLayer, _ms, null);
__privateAdd(_TextLayer, _bs, /* @__PURE__ */ new Set());
var TextLayer = _TextLayer;
var XfaText = class _XfaText {
  static textContent(t2) {
    const e2 = [], i2 = { items: e2, styles: /* @__PURE__ */ Object.create(null) };
    !function walk(t3) {
      var _a5;
      if (!t3) return;
      let i3 = null;
      const s2 = t3.name;
      if ("#text" === s2) i3 = t3.value;
      else {
        if (!_XfaText.shouldBuildText(s2)) return;
        ((_a5 = t3 == null ? void 0 : t3.attributes) == null ? void 0 : _a5.textContent) ? i3 = t3.attributes.textContent : t3.value && (i3 = t3.value);
      }
      null !== i3 && e2.push({ str: i3 });
      if (t3.children) for (const e3 of t3.children) walk(e3);
    }(t2);
    return i2;
  }
  static shouldBuildText(t2) {
    return !("textarea" === t2 || "input" === t2 || "option" === t2 || "select" === t2);
  }
};
function getDocument(e2 = {}) {
  "string" == typeof e2 || e2 instanceof URL ? e2 = { url: e2 } : (e2 instanceof ArrayBuffer || ArrayBuffer.isView(e2)) && (e2 = { data: e2 });
  const i2 = new PDFDocumentLoadingTask(), { docId: s2 } = i2, n2 = e2.url ? function getUrlProp(e3) {
    if (e3 instanceof URL) return e3.href;
    if ("string" == typeof e3) {
      if (t) return e3;
      const i3 = URL.parse(e3, window.location);
      if (i3) return i3.href;
    }
    throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
  }(e2.url) : null, a2 = e2.data ? function getDataProp(e3) {
    if (t && "undefined" != typeof Buffer && e3 instanceof Buffer) throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
    if (e3 instanceof Uint8Array && e3.byteLength === e3.buffer.byteLength) return e3;
    if ("string" == typeof e3) return stringToBytes(e3);
    if (e3 instanceof ArrayBuffer || ArrayBuffer.isView(e3) || "object" == typeof e3 && !isNaN(e3 == null ? void 0 : e3.length)) return new Uint8Array(e3);
    throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
  }(e2.data) : null, r2 = e2.httpHeaders || null, o2 = true === e2.withCredentials, l2 = e2.password ?? null, h2 = e2.range instanceof PDFDataRangeTransport ? e2.range : null, d2 = Number.isInteger(e2.rangeChunkSize) && e2.rangeChunkSize > 0 ? e2.rangeChunkSize : 65536;
  let c2 = e2.worker instanceof PDFWorker ? e2.worker : null;
  const u2 = e2.verbosity, p2 = "string" != typeof e2.docBaseUrl || isDataScheme(e2.docBaseUrl) ? null : e2.docBaseUrl, g2 = getFactoryUrlProp(e2.cMapUrl), f2 = false !== e2.cMapPacked, m2 = e2.CMapReaderFactory || (t ? NodeCMapReaderFactory : DOMCMapReaderFactory), b2 = getFactoryUrlProp(e2.iccUrl), A2 = getFactoryUrlProp(e2.standardFontDataUrl), w2 = e2.StandardFontDataFactory || (t ? NodeStandardFontDataFactory : DOMStandardFontDataFactory), y2 = getFactoryUrlProp(e2.wasmUrl), v2 = e2.WasmFactory || (t ? NodeWasmFactory : DOMWasmFactory), x2 = true !== e2.stopAtErrors, E2 = Number.isInteger(e2.maxImageSize) && e2.maxImageSize > -1 ? e2.maxImageSize : -1, _2 = false !== e2.isEvalSupported, S2 = "boolean" == typeof e2.isOffscreenCanvasSupported ? e2.isOffscreenCanvasSupported : !t, C2 = "boolean" == typeof e2.isImageDecoderSupported ? e2.isImageDecoderSupported : !t && (util_FeatureTest.platform.isFirefox || !globalThis.chrome), T2 = Number.isInteger(e2.canvasMaxAreaInBytes) ? e2.canvasMaxAreaInBytes : -1, M2 = "boolean" == typeof e2.disableFontFace ? e2.disableFontFace : t, D2 = true === e2.fontExtraProperties, P2 = true === e2.enableXfa, k2 = e2.ownerDocument || globalThis.document, I2 = true === e2.disableRange, R2 = true === e2.disableStream, F2 = true === e2.disableAutoFetch, L2 = true === e2.pdfBug, O2 = e2.CanvasFactory || (t ? NodeCanvasFactory : DOMCanvasFactory), N2 = e2.FilterFactory || (t ? NodeFilterFactory : DOMFilterFactory), B2 = true === e2.enableHWA, H2 = false !== e2.useWasm, U2 = h2 ? h2.length : e2.length ?? NaN, z2 = "boolean" == typeof e2.useSystemFonts ? e2.useSystemFonts : !t && !M2, G2 = "boolean" == typeof e2.useWorkerFetch ? e2.useWorkerFetch : !!(m2 === DOMCMapReaderFactory && w2 === DOMStandardFontDataFactory && v2 === DOMWasmFactory && g2 && A2 && y2 && isValidFetchUrl(g2, document.baseURI) && isValidFetchUrl(A2, document.baseURI) && isValidFetchUrl(y2, document.baseURI));
  setVerbosityLevel(u2);
  const $2 = { canvasFactory: new O2({ ownerDocument: k2, enableHWA: B2 }), filterFactory: new N2({ docId: s2, ownerDocument: k2 }), cMapReaderFactory: G2 ? null : new m2({ baseUrl: g2, isCompressed: f2 }), standardFontDataFactory: G2 ? null : new w2({ baseUrl: A2 }), wasmFactory: G2 ? null : new v2({ baseUrl: y2 }) };
  if (!c2) {
    c2 = PDFWorker.create({ verbosity: u2, port: GlobalWorkerOptions.workerPort });
    i2._worker = c2;
  }
  const W2 = { docId: s2, apiVersion: "5.3.31", data: a2, password: l2, disableAutoFetch: F2, rangeChunkSize: d2, length: U2, docBaseUrl: p2, enableXfa: P2, evaluatorOptions: { maxImageSize: E2, disableFontFace: M2, ignoreErrors: x2, isEvalSupported: _2, isOffscreenCanvasSupported: S2, isImageDecoderSupported: C2, canvasMaxAreaInBytes: T2, fontExtraProperties: D2, useSystemFonts: z2, useWasm: H2, useWorkerFetch: G2, cMapUrl: g2, iccUrl: b2, standardFontDataUrl: A2, wasmUrl: y2 } }, V2 = { ownerDocument: k2, pdfBug: L2, styleElement: null, loadingParams: { disableAutoFetch: F2, enableXfa: P2 } };
  c2.promise.then(function() {
    if (i2.destroyed) throw new Error("Loading aborted");
    if (c2.destroyed) throw new Error("Worker was destroyed");
    const e3 = c2.messageHandler.sendWithPromise("GetDocRequest", W2, a2 ? [a2.buffer] : null);
    let l3;
    if (h2) l3 = new PDFDataTransportStream(h2, { disableRange: I2, disableStream: R2 });
    else if (!a2) {
      if (!n2) throw new Error("getDocument - no `url` parameter provided.");
      const e4 = isValidFetchUrl(n2) ? PDFFetchStream : t ? PDFNodeStream : PDFNetworkStream;
      l3 = new e4({ url: n2, length: U2, httpHeaders: r2, withCredentials: o2, rangeChunkSize: d2, disableRange: I2, disableStream: R2 });
    }
    return e3.then((t2) => {
      if (i2.destroyed) throw new Error("Loading aborted");
      if (c2.destroyed) throw new Error("Worker was destroyed");
      const e4 = new MessageHandler(s2, t2, c2.port), n3 = new WorkerTransport(e4, i2, l3, V2, $2);
      i2._transport = n3;
      e4.send("Ready", null);
    });
  }).catch(i2._capability.reject);
  return i2;
}
var _Ai2;
var _PDFDocumentLoadingTask = class _PDFDocumentLoadingTask {
  constructor() {
    __publicField(this, "_capability", Promise.withResolvers());
    __publicField(this, "_transport", null);
    __publicField(this, "_worker", null);
    __publicField(this, "docId", "d" + __privateWrapper(_PDFDocumentLoadingTask, _Ai2)._++);
    __publicField(this, "destroyed", false);
    __publicField(this, "onPassword", null);
    __publicField(this, "onProgress", null);
  }
  get promise() {
    return this._capability.promise;
  }
  async destroy() {
    var _a5, _b, _c, _d;
    this.destroyed = true;
    try {
      ((_a5 = this._worker) == null ? void 0 : _a5.port) && (this._worker._pendingDestroy = true);
      await ((_b = this._transport) == null ? void 0 : _b.destroy());
    } catch (t2) {
      ((_c = this._worker) == null ? void 0 : _c.port) && delete this._worker._pendingDestroy;
      throw t2;
    }
    this._transport = null;
    (_d = this._worker) == null ? void 0 : _d.destroy();
    this._worker = null;
  }
  async getData() {
    return this._transport.getData();
  }
};
_Ai2 = new WeakMap();
__privateAdd(_PDFDocumentLoadingTask, _Ai2, 0);
var PDFDocumentLoadingTask = _PDFDocumentLoadingTask;
var _Yi2, _Ss, _Cs, _Ts, _Ms;
var PDFDataRangeTransport = class {
  constructor(t2, e2, i2 = false, s2 = null) {
    __privateAdd(this, _Yi2, Promise.withResolvers());
    __privateAdd(this, _Ss, []);
    __privateAdd(this, _Cs, []);
    __privateAdd(this, _Ts, []);
    __privateAdd(this, _Ms, []);
    this.length = t2;
    this.initialData = e2;
    this.progressiveDone = i2;
    this.contentDispositionFilename = s2;
  }
  addRangeListener(t2) {
    __privateGet(this, _Ms).push(t2);
  }
  addProgressListener(t2) {
    __privateGet(this, _Ts).push(t2);
  }
  addProgressiveReadListener(t2) {
    __privateGet(this, _Cs).push(t2);
  }
  addProgressiveDoneListener(t2) {
    __privateGet(this, _Ss).push(t2);
  }
  onDataRange(t2, e2) {
    for (const i2 of __privateGet(this, _Ms)) i2(t2, e2);
  }
  onDataProgress(t2, e2) {
    __privateGet(this, _Yi2).promise.then(() => {
      for (const i2 of __privateGet(this, _Ts)) i2(t2, e2);
    });
  }
  onDataProgressiveRead(t2) {
    __privateGet(this, _Yi2).promise.then(() => {
      for (const e2 of __privateGet(this, _Cs)) e2(t2);
    });
  }
  onDataProgressiveDone() {
    __privateGet(this, _Yi2).promise.then(() => {
      for (const t2 of __privateGet(this, _Ss)) t2();
    });
  }
  transportReady() {
    __privateGet(this, _Yi2).resolve();
  }
  requestDataRange(t2, e2) {
    unreachable("Abstract method PDFDataRangeTransport.requestDataRange");
  }
  abort() {
  }
};
_Yi2 = new WeakMap();
_Ss = new WeakMap();
_Cs = new WeakMap();
_Ts = new WeakMap();
_Ms = new WeakMap();
var PDFDocumentProxy = class {
  constructor(t2, e2) {
    this._pdfInfo = t2;
    this._transport = e2;
  }
  get annotationStorage() {
    return this._transport.annotationStorage;
  }
  get canvasFactory() {
    return this._transport.canvasFactory;
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get numPages() {
    return this._pdfInfo.numPages;
  }
  get fingerprints() {
    return this._pdfInfo.fingerprints;
  }
  get isPureXfa() {
    return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  get allXfaHtml() {
    return this._transport._htmlForXfa;
  }
  getPage(t2) {
    return this._transport.getPage(t2);
  }
  getPageIndex(t2) {
    return this._transport.getPageIndex(t2);
  }
  getDestinations() {
    return this._transport.getDestinations();
  }
  getDestination(t2) {
    return this._transport.getDestination(t2);
  }
  getPageLabels() {
    return this._transport.getPageLabels();
  }
  getPageLayout() {
    return this._transport.getPageLayout();
  }
  getPageMode() {
    return this._transport.getPageMode();
  }
  getViewerPreferences() {
    return this._transport.getViewerPreferences();
  }
  getOpenAction() {
    return this._transport.getOpenAction();
  }
  getAttachments() {
    return this._transport.getAttachments();
  }
  getJSActions() {
    return this._transport.getDocJSActions();
  }
  getOutline() {
    return this._transport.getOutline();
  }
  getOptionalContentConfig({ intent: t2 = "display" } = {}) {
    const { renderingIntent: e2 } = this._transport.getRenderingIntent(t2);
    return this._transport.getOptionalContentConfig(e2);
  }
  getPermissions() {
    return this._transport.getPermissions();
  }
  getMetadata() {
    return this._transport.getMetadata();
  }
  getMarkInfo() {
    return this._transport.getMarkInfo();
  }
  getData() {
    return this._transport.getData();
  }
  saveDocument() {
    return this._transport.saveDocument();
  }
  getDownloadInfo() {
    return this._transport.downloadInfoCapability.promise;
  }
  cleanup(t2 = false) {
    return this._transport.startCleanup(t2 || this.isPureXfa);
  }
  destroy() {
    return this.loadingTask.destroy();
  }
  cachedPageNumber(t2) {
    return this._transport.cachedPageNumber(t2);
  }
  get loadingParams() {
    return this._transport.loadingParams;
  }
  get loadingTask() {
    return this._transport.loadingTask;
  }
  getFieldObjects() {
    return this._transport.getFieldObjects();
  }
  hasJSActions() {
    return this._transport.hasJSActions();
  }
  getCalculationOrderIds() {
    return this._transport.getCalculationOrderIds();
  }
};
var _Ds, _PDFPageProxy_instances, Ps_fn;
var PDFPageProxy = class {
  constructor(t2, e2, i2, s2 = false) {
    __privateAdd(this, _PDFPageProxy_instances);
    __privateAdd(this, _Ds, false);
    this._pageIndex = t2;
    this._pageInfo = e2;
    this._transport = i2;
    this._stats = s2 ? new StatTimer() : null;
    this._pdfBug = s2;
    this.commonObjs = i2.commonObjs;
    this.objs = new PDFObjects();
    this._intentStates = /* @__PURE__ */ new Map();
    this.destroyed = false;
  }
  get pageNumber() {
    return this._pageIndex + 1;
  }
  get rotate() {
    return this._pageInfo.rotate;
  }
  get ref() {
    return this._pageInfo.ref;
  }
  get userUnit() {
    return this._pageInfo.userUnit;
  }
  get view() {
    return this._pageInfo.view;
  }
  getViewport({ scale: t2, rotation: e2 = this.rotate, offsetX: i2 = 0, offsetY: s2 = 0, dontFlip: n2 = false } = {}) {
    return new PageViewport({ viewBox: this.view, userUnit: this.userUnit, scale: t2, rotation: e2, offsetX: i2, offsetY: s2, dontFlip: n2 });
  }
  getAnnotations({ intent: t2 = "display" } = {}) {
    const { renderingIntent: e2 } = this._transport.getRenderingIntent(t2);
    return this._transport.getAnnotations(this._pageIndex, e2);
  }
  getJSActions() {
    return this._transport.getPageJSActions(this._pageIndex);
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get isPureXfa() {
    return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  async getXfa() {
    var _a5;
    return ((_a5 = this._transport._htmlForXfa) == null ? void 0 : _a5.children[this._pageIndex]) || null;
  }
  render({ canvasContext: t2, viewport: e2, intent: i2 = "display", annotationMode: s2 = c.ENABLE, transform: n2 = null, background: r2 = null, optionalContentConfigPromise: o2 = null, annotationCanvasMap: l2 = null, pageColors: h2 = null, printAnnotationStorage: d2 = null, isEditing: u2 = false }) {
    var _a5, _b;
    (_a5 = this._stats) == null ? void 0 : _a5.time("Overall");
    const p2 = this._transport.getRenderingIntent(i2, s2, d2, u2), { renderingIntent: g2, cacheKey: f2 } = p2;
    __privateSet(this, _Ds, false);
    o2 || (o2 = this._transport.getOptionalContentConfig(g2));
    let m2 = this._intentStates.get(f2);
    if (!m2) {
      m2 = /* @__PURE__ */ Object.create(null);
      this._intentStates.set(f2, m2);
    }
    if (m2.streamReaderCancelTimeout) {
      clearTimeout(m2.streamReaderCancelTimeout);
      m2.streamReaderCancelTimeout = null;
    }
    const b2 = !!(g2 & a);
    if (!m2.displayReadyCapability) {
      m2.displayReadyCapability = Promise.withResolvers();
      m2.operatorList = { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null };
      (_b = this._stats) == null ? void 0 : _b.time("Page Request");
      this._pumpOperatorList(p2);
    }
    const complete = (t3) => {
      var _a6;
      m2.renderTasks.delete(A2);
      b2 && __privateSet(this, _Ds, true);
      __privateMethod(this, _PDFPageProxy_instances, Ps_fn).call(this);
      if (t3) {
        A2.capability.reject(t3);
        this._abortOperatorList({ intentState: m2, reason: t3 instanceof Error ? t3 : new Error(t3) });
      } else A2.capability.resolve();
      if (this._stats) {
        this._stats.timeEnd("Rendering");
        this._stats.timeEnd("Overall");
        ((_a6 = globalThis.Stats) == null ? void 0 : _a6.enabled) && globalThis.Stats.add(this.pageNumber, this._stats);
      }
    }, A2 = new InternalRenderTask({ callback: complete, params: { canvasContext: t2, viewport: e2, transform: n2, background: r2 }, objs: this.objs, commonObjs: this.commonObjs, annotationCanvasMap: l2, operatorList: m2.operatorList, pageIndex: this._pageIndex, canvasFactory: this._transport.canvasFactory, filterFactory: this._transport.filterFactory, useRequestAnimationFrame: !b2, pdfBug: this._pdfBug, pageColors: h2 });
    (m2.renderTasks || (m2.renderTasks = /* @__PURE__ */ new Set())).add(A2);
    const w2 = A2.task;
    Promise.all([m2.displayReadyCapability.promise, o2]).then(([t3, e3]) => {
      var _a6;
      if (this.destroyed) complete();
      else {
        (_a6 = this._stats) == null ? void 0 : _a6.time("Rendering");
        if (!(e3.renderingIntent & g2)) throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.");
        A2.initializeGraphics({ transparency: t3, optionalContentConfig: e3 });
        A2.operatorListChanged();
      }
    }).catch(complete);
    return w2;
  }
  getOperatorList({ intent: t2 = "display", annotationMode: e2 = c.ENABLE, printAnnotationStorage: i2 = null, isEditing: s2 = false } = {}) {
    var _a5;
    const n2 = this._transport.getRenderingIntent(t2, e2, i2, s2, true);
    let a2, r2 = this._intentStates.get(n2.cacheKey);
    if (!r2) {
      r2 = /* @__PURE__ */ Object.create(null);
      this._intentStates.set(n2.cacheKey, r2);
    }
    if (!r2.opListReadCapability) {
      a2 = /* @__PURE__ */ Object.create(null);
      a2.operatorListChanged = function operatorListChanged() {
        if (r2.operatorList.lastChunk) {
          r2.opListReadCapability.resolve(r2.operatorList);
          r2.renderTasks.delete(a2);
        }
      };
      r2.opListReadCapability = Promise.withResolvers();
      (r2.renderTasks || (r2.renderTasks = /* @__PURE__ */ new Set())).add(a2);
      r2.operatorList = { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null };
      (_a5 = this._stats) == null ? void 0 : _a5.time("Page Request");
      this._pumpOperatorList(n2);
    }
    return r2.opListReadCapability.promise;
  }
  streamTextContent({ includeMarkedContent: t2 = false, disableNormalization: e2 = false } = {}) {
    return this._transport.messageHandler.sendWithStream("GetTextContent", { pageIndex: this._pageIndex, includeMarkedContent: true === t2, disableNormalization: true === e2 }, { highWaterMark: 100, size: (t3) => t3.items.length });
  }
  getTextContent(t2 = {}) {
    if (this._transport._htmlForXfa) return this.getXfa().then((t3) => XfaText.textContent(t3));
    const e2 = this.streamTextContent(t2);
    return new Promise(function(t3, i2) {
      const s2 = e2.getReader(), n2 = { items: [], styles: /* @__PURE__ */ Object.create(null), lang: null };
      !function pump() {
        s2.read().then(function({ value: e3, done: i3 }) {
          if (i3) t3(n2);
          else {
            n2.lang ?? (n2.lang = e3.lang);
            Object.assign(n2.styles, e3.styles);
            n2.items.push(...e3.items);
            pump();
          }
        }, i2);
      }();
    });
  }
  getStructTree() {
    return this._transport.getStructTree(this._pageIndex);
  }
  _destroy() {
    this.destroyed = true;
    const t2 = [];
    for (const e2 of this._intentStates.values()) {
      this._abortOperatorList({ intentState: e2, reason: new Error("Page was destroyed."), force: true });
      if (!e2.opListReadCapability) for (const i2 of e2.renderTasks) {
        t2.push(i2.completed);
        i2.cancel();
      }
    }
    this.objs.clear();
    __privateSet(this, _Ds, false);
    return Promise.all(t2);
  }
  cleanup(t2 = false) {
    __privateSet(this, _Ds, true);
    const e2 = __privateMethod(this, _PDFPageProxy_instances, Ps_fn).call(this);
    t2 && e2 && (this._stats && (this._stats = new StatTimer()));
    return e2;
  }
  _startRenderPage(t2, e2) {
    var _a5, _b;
    const i2 = this._intentStates.get(e2);
    if (i2) {
      (_a5 = this._stats) == null ? void 0 : _a5.timeEnd("Page Request");
      (_b = i2.displayReadyCapability) == null ? void 0 : _b.resolve(t2);
    }
  }
  _renderPageChunk(t2, e2) {
    for (let i2 = 0, s2 = t2.length; i2 < s2; i2++) {
      e2.operatorList.fnArray.push(t2.fnArray[i2]);
      e2.operatorList.argsArray.push(t2.argsArray[i2]);
    }
    e2.operatorList.lastChunk = t2.lastChunk;
    e2.operatorList.separateAnnots = t2.separateAnnots;
    for (const t3 of e2.renderTasks) t3.operatorListChanged();
    t2.lastChunk && __privateMethod(this, _PDFPageProxy_instances, Ps_fn).call(this);
  }
  _pumpOperatorList({ renderingIntent: t2, cacheKey: e2, annotationStorageSerializable: i2, modifiedIds: s2 }) {
    const { map: n2, transfer: a2 } = i2, r2 = this._transport.messageHandler.sendWithStream("GetOperatorList", { pageIndex: this._pageIndex, intent: t2, cacheKey: e2, annotationStorage: n2, modifiedIds: s2 }, a2).getReader(), o2 = this._intentStates.get(e2);
    o2.streamReader = r2;
    const pump = () => {
      r2.read().then(({ value: t3, done: e3 }) => {
        if (e3) o2.streamReader = null;
        else if (!this._transport.destroyed) {
          this._renderPageChunk(t3, o2);
          pump();
        }
      }, (t3) => {
        o2.streamReader = null;
        if (!this._transport.destroyed) {
          if (o2.operatorList) {
            o2.operatorList.lastChunk = true;
            for (const t4 of o2.renderTasks) t4.operatorListChanged();
            __privateMethod(this, _PDFPageProxy_instances, Ps_fn).call(this);
          }
          if (o2.displayReadyCapability) o2.displayReadyCapability.reject(t3);
          else {
            if (!o2.opListReadCapability) throw t3;
            o2.opListReadCapability.reject(t3);
          }
        }
      });
    };
    pump();
  }
  _abortOperatorList({ intentState: t2, reason: e2, force: i2 = false }) {
    if (t2.streamReader) {
      if (t2.streamReaderCancelTimeout) {
        clearTimeout(t2.streamReaderCancelTimeout);
        t2.streamReaderCancelTimeout = null;
      }
      if (!i2) {
        if (t2.renderTasks.size > 0) return;
        if (e2 instanceof RenderingCancelledException) {
          let i3 = 100;
          e2.extraDelay > 0 && e2.extraDelay < 1e3 && (i3 += e2.extraDelay);
          t2.streamReaderCancelTimeout = setTimeout(() => {
            t2.streamReaderCancelTimeout = null;
            this._abortOperatorList({ intentState: t2, reason: e2, force: true });
          }, i3);
          return;
        }
      }
      t2.streamReader.cancel(new AbortException(e2.message)).catch(() => {
      });
      t2.streamReader = null;
      if (!this._transport.destroyed) {
        for (const [e3, i3] of this._intentStates) if (i3 === t2) {
          this._intentStates.delete(e3);
          break;
        }
        this.cleanup();
      }
    }
  }
  get stats() {
    return this._stats;
  }
};
_Ds = new WeakMap();
_PDFPageProxy_instances = new WeakSet();
Ps_fn = function() {
  if (!__privateGet(this, _Ds) || this.destroyed) return false;
  for (const { renderTasks: t2, operatorList: e2 } of this._intentStates.values()) if (t2.size > 0 || !e2.lastChunk) return false;
  this._intentStates.clear();
  this.objs.clear();
  __privateSet(this, _Ds, false);
  return true;
};
var _Yi3, _ks, _Li2, _Is, _Rs, _Fs, _Ls, _PDFWorker_instances, Bs_fn, Os_fn, Ns_fn, Us_fn, _PDFWorker_static, Hs_get;
var _PDFWorker = class _PDFWorker {
  constructor({ name: t2 = null, port: e2 = null, verbosity: i2 = getVerbosityLevel() } = {}) {
    __privateAdd(this, _PDFWorker_instances);
    __privateAdd(this, _Yi3, Promise.withResolvers());
    __privateAdd(this, _ks, null);
    __privateAdd(this, _Li2, null);
    __privateAdd(this, _Is, null);
    this.name = t2;
    this.destroyed = false;
    this.verbosity = i2;
    if (e2) {
      if (__privateGet(_PDFWorker, _Ls).has(e2)) throw new Error("Cannot use more than one PDFWorker per port.");
      __privateGet(_PDFWorker, _Ls).set(e2, this);
      __privateMethod(this, _PDFWorker_instances, Os_fn).call(this, e2);
    } else __privateMethod(this, _PDFWorker_instances, Ns_fn).call(this);
  }
  get promise() {
    return __privateGet(this, _Yi3).promise;
  }
  get port() {
    return __privateGet(this, _Li2);
  }
  get messageHandler() {
    return __privateGet(this, _ks);
  }
  destroy() {
    var _a5, _b;
    this.destroyed = true;
    (_a5 = __privateGet(this, _Is)) == null ? void 0 : _a5.terminate();
    __privateSet(this, _Is, null);
    __privateGet(_PDFWorker, _Ls).delete(__privateGet(this, _Li2));
    __privateSet(this, _Li2, null);
    (_b = __privateGet(this, _ks)) == null ? void 0 : _b.destroy();
    __privateSet(this, _ks, null);
  }
  static create(t2) {
    const e2 = __privateGet(this, _Ls).get(t2 == null ? void 0 : t2.port);
    if (e2) {
      if (e2._pendingDestroy) throw new Error("PDFWorker.create - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
      return e2;
    }
    return new _PDFWorker(t2);
  }
  static get workerSrc() {
    if (GlobalWorkerOptions.workerSrc) return GlobalWorkerOptions.workerSrc;
    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
  }
  static get _setupFakeWorkerGlobal() {
    return shadow(this, "_setupFakeWorkerGlobal", (async () => {
      if (__privateGet(this, _PDFWorker_static, Hs_get)) return __privateGet(this, _PDFWorker_static, Hs_get);
      return (await import(
        /*webpackIgnore: true*/
        /*@vite-ignore*/
        this.workerSrc
      )).WorkerMessageHandler;
    })());
  }
};
_Yi3 = new WeakMap();
_ks = new WeakMap();
_Li2 = new WeakMap();
_Is = new WeakMap();
_Rs = new WeakMap();
_Fs = new WeakMap();
_Ls = new WeakMap();
_PDFWorker_instances = new WeakSet();
Bs_fn = function() {
  __privateGet(this, _Yi3).resolve();
  __privateGet(this, _ks).send("configure", { verbosity: this.verbosity });
};
Os_fn = function(t2) {
  __privateSet(this, _Li2, t2);
  __privateSet(this, _ks, new MessageHandler("main", "worker", t2));
  __privateGet(this, _ks).on("ready", () => {
  });
  __privateMethod(this, _PDFWorker_instances, Bs_fn).call(this);
};
Ns_fn = function() {
  if (__privateGet(_PDFWorker, _Fs) || __privateGet(_PDFWorker, _PDFWorker_static, Hs_get)) {
    __privateMethod(this, _PDFWorker_instances, Us_fn).call(this);
    return;
  }
  let { workerSrc: t2 } = _PDFWorker;
  try {
    _PDFWorker._isSameOrigin(window.location, t2) || (t2 = _PDFWorker._createCDNWrapper(new URL(t2, window.location).href));
    const e2 = new Worker(t2, { type: "module" }), i2 = new MessageHandler("main", "worker", e2), terminateEarly = () => {
      s2.abort();
      i2.destroy();
      e2.terminate();
      this.destroyed ? __privateGet(this, _Yi3).reject(new Error("Worker was destroyed")) : __privateMethod(this, _PDFWorker_instances, Us_fn).call(this);
    }, s2 = new AbortController();
    e2.addEventListener("error", () => {
      __privateGet(this, _Is) || terminateEarly();
    }, { signal: s2.signal });
    i2.on("test", (t3) => {
      s2.abort();
      if (!this.destroyed && t3) {
        __privateSet(this, _ks, i2);
        __privateSet(this, _Li2, e2);
        __privateSet(this, _Is, e2);
        __privateMethod(this, _PDFWorker_instances, Bs_fn).call(this);
      } else terminateEarly();
    });
    i2.on("ready", (t3) => {
      s2.abort();
      if (this.destroyed) terminateEarly();
      else try {
        sendTest();
      } catch {
        __privateMethod(this, _PDFWorker_instances, Us_fn).call(this);
      }
    });
    const sendTest = () => {
      const t3 = new Uint8Array();
      i2.send("test", t3, [t3.buffer]);
    };
    sendTest();
    return;
  } catch {
    info("The worker has been disabled.");
  }
  __privateMethod(this, _PDFWorker_instances, Us_fn).call(this);
};
Us_fn = function() {
  if (!__privateGet(_PDFWorker, _Fs)) {
    warn("Setting up fake worker.");
    __privateSet(_PDFWorker, _Fs, true);
  }
  _PDFWorker._setupFakeWorkerGlobal.then((t2) => {
    if (this.destroyed) {
      __privateGet(this, _Yi3).reject(new Error("Worker was destroyed"));
      return;
    }
    const e2 = new LoopbackPort();
    __privateSet(this, _Li2, e2);
    const i2 = "fake" + __privateWrapper(_PDFWorker, _Rs)._++, s2 = new MessageHandler(i2 + "_worker", i2, e2);
    t2.setup(s2, e2);
    __privateSet(this, _ks, new MessageHandler(i2, i2 + "_worker", e2));
    __privateMethod(this, _PDFWorker_instances, Bs_fn).call(this);
  }).catch((t2) => {
    __privateGet(this, _Yi3).reject(new Error(`Setting up fake worker failed: "${t2.message}".`));
  });
};
_PDFWorker_static = new WeakSet();
Hs_get = function() {
  var _a5;
  try {
    return ((_a5 = globalThis.pdfjsWorker) == null ? void 0 : _a5.WorkerMessageHandler) || null;
  } catch {
    return null;
  }
};
__privateAdd(_PDFWorker, _PDFWorker_static);
__privateAdd(_PDFWorker, _Rs, 0);
__privateAdd(_PDFWorker, _Fs, false);
__privateAdd(_PDFWorker, _Ls, /* @__PURE__ */ new WeakMap());
(() => {
  if (t) {
    __privateSet(_PDFWorker, _Fs, true);
    GlobalWorkerOptions.workerSrc || (GlobalWorkerOptions.workerSrc = "./pdf.worker.mjs");
  }
  _PDFWorker._isSameOrigin = (t2, e2) => {
    const i2 = URL.parse(t2);
    if (!(i2 == null ? void 0 : i2.origin) || "null" === i2.origin) return false;
    const s2 = new URL(e2, i2);
    return i2.origin === s2.origin;
  };
  _PDFWorker._createCDNWrapper = (t2) => {
    const e2 = `await import("${t2}");`;
    return URL.createObjectURL(new Blob([e2], { type: "text/javascript" }));
  };
  _PDFWorker.fromPort = (t2) => {
    !function deprecated(t3) {
      console.log("Deprecated API usage: " + t3);
    }("`PDFWorker.fromPort` - please use `PDFWorker.create` instead.");
    if (!(t2 == null ? void 0 : t2.port)) throw new Error("PDFWorker.fromPort - invalid method signature.");
    return _PDFWorker.create(t2);
  };
})();
var PDFWorker = _PDFWorker;
var _zs, _Gs, _$s, _Ws, _Vs, _WorkerTransport_instances, js_fn;
var WorkerTransport = class {
  constructor(t2, e2, i2, s2, n2) {
    __privateAdd(this, _WorkerTransport_instances);
    __privateAdd(this, _zs, /* @__PURE__ */ new Map());
    __privateAdd(this, _Gs, /* @__PURE__ */ new Map());
    __privateAdd(this, _$s, /* @__PURE__ */ new Map());
    __privateAdd(this, _Ws, /* @__PURE__ */ new Map());
    __privateAdd(this, _Vs, null);
    this.messageHandler = t2;
    this.loadingTask = e2;
    this.commonObjs = new PDFObjects();
    this.fontLoader = new FontLoader({ ownerDocument: s2.ownerDocument, styleElement: s2.styleElement });
    this.loadingParams = s2.loadingParams;
    this._params = s2;
    this.canvasFactory = n2.canvasFactory;
    this.filterFactory = n2.filterFactory;
    this.cMapReaderFactory = n2.cMapReaderFactory;
    this.standardFontDataFactory = n2.standardFontDataFactory;
    this.wasmFactory = n2.wasmFactory;
    this.destroyed = false;
    this.destroyCapability = null;
    this._networkStream = i2;
    this._fullReader = null;
    this._lastProgress = null;
    this.downloadInfoCapability = Promise.withResolvers();
    this.setupMessageHandler();
  }
  get annotationStorage() {
    return shadow(this, "annotationStorage", new AnnotationStorage());
  }
  getRenderingIntent(t2, e2 = c.ENABLE, i2 = null, u2 = false, p2 = false) {
    let g2 = n, f2 = j;
    switch (t2) {
      case "any":
        g2 = s;
        break;
      case "display":
        break;
      case "print":
        g2 = a;
        break;
      default:
        warn(`getRenderingIntent - invalid intent: ${t2}`);
    }
    const m2 = g2 & a && i2 instanceof PrintAnnotationStorage ? i2 : this.annotationStorage;
    switch (e2) {
      case c.DISABLE:
        g2 += l;
        break;
      case c.ENABLE:
        break;
      case c.ENABLE_FORMS:
        g2 += r;
        break;
      case c.ENABLE_STORAGE:
        g2 += o;
        f2 = m2.serializable;
        break;
      default:
        warn(`getRenderingIntent - invalid annotationMode: ${e2}`);
    }
    u2 && (g2 += h);
    p2 && (g2 += d);
    const { ids: b2, hash: A2 } = m2.modifiedIds;
    return { renderingIntent: g2, cacheKey: [g2, f2.hash, A2].join("_"), annotationStorageSerializable: f2, modifiedIds: b2 };
  }
  destroy() {
    var _a5;
    if (this.destroyCapability) return this.destroyCapability.promise;
    this.destroyed = true;
    this.destroyCapability = Promise.withResolvers();
    (_a5 = __privateGet(this, _Vs)) == null ? void 0 : _a5.reject(new Error("Worker was destroyed during onPassword callback"));
    const t2 = [];
    for (const e3 of __privateGet(this, _Gs).values()) t2.push(e3._destroy());
    __privateGet(this, _Gs).clear();
    __privateGet(this, _$s).clear();
    __privateGet(this, _Ws).clear();
    this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
    const e2 = this.messageHandler.sendWithPromise("Terminate", null);
    t2.push(e2);
    Promise.all(t2).then(() => {
      var _a6, _b;
      this.commonObjs.clear();
      this.fontLoader.clear();
      __privateGet(this, _zs).clear();
      this.filterFactory.destroy();
      TextLayer.cleanup();
      (_a6 = this._networkStream) == null ? void 0 : _a6.cancelAllRequests(new AbortException("Worker was terminated."));
      (_b = this.messageHandler) == null ? void 0 : _b.destroy();
      this.messageHandler = null;
      this.destroyCapability.resolve();
    }, this.destroyCapability.reject);
    return this.destroyCapability.promise;
  }
  setupMessageHandler() {
    const { messageHandler: t2, loadingTask: e2 } = this;
    t2.on("GetReader", (t3, e3) => {
      assert(this._networkStream, "GetReader - no `IPDFStream` instance available.");
      this._fullReader = this._networkStream.getFullReader();
      this._fullReader.onProgress = (t4) => {
        this._lastProgress = { loaded: t4.loaded, total: t4.total };
      };
      e3.onPull = () => {
        this._fullReader.read().then(function({ value: t4, done: i2 }) {
          if (i2) e3.close();
          else {
            assert(t4 instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer.");
            e3.enqueue(new Uint8Array(t4), 1, [t4]);
          }
        }).catch((t4) => {
          e3.error(t4);
        });
      };
      e3.onCancel = (t4) => {
        this._fullReader.cancel(t4);
        e3.ready.catch((t5) => {
          if (!this.destroyed) throw t5;
        });
      };
    });
    t2.on("ReaderHeadersReady", async (t3) => {
      var _a5;
      await this._fullReader.headersReady;
      const { isStreamingSupported: i2, isRangeSupported: s2, contentLength: n2 } = this._fullReader;
      if (!i2 || !s2) {
        this._lastProgress && ((_a5 = e2.onProgress) == null ? void 0 : _a5.call(e2, this._lastProgress));
        this._fullReader.onProgress = (t4) => {
          var _a6;
          (_a6 = e2.onProgress) == null ? void 0 : _a6.call(e2, { loaded: t4.loaded, total: t4.total });
        };
      }
      return { isStreamingSupported: i2, isRangeSupported: s2, contentLength: n2 };
    });
    t2.on("GetRangeReader", (t3, e3) => {
      assert(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
      const i2 = this._networkStream.getRangeReader(t3.begin, t3.end);
      if (i2) {
        e3.onPull = () => {
          i2.read().then(function({ value: t4, done: i3 }) {
            if (i3) e3.close();
            else {
              assert(t4 instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer.");
              e3.enqueue(new Uint8Array(t4), 1, [t4]);
            }
          }).catch((t4) => {
            e3.error(t4);
          });
        };
        e3.onCancel = (t4) => {
          i2.cancel(t4);
          e3.ready.catch((t5) => {
            if (!this.destroyed) throw t5;
          });
        };
      } else e3.close();
    });
    t2.on("GetDoc", ({ pdfInfo: t3 }) => {
      this._numPages = t3.numPages;
      this._htmlForXfa = t3.htmlForXfa;
      delete t3.htmlForXfa;
      e2._capability.resolve(new PDFDocumentProxy(t3, this));
    });
    t2.on("DocException", (t3) => {
      e2._capability.reject(wrapReason(t3));
    });
    t2.on("PasswordRequest", (t3) => {
      __privateSet(this, _Vs, Promise.withResolvers());
      try {
        if (!e2.onPassword) throw wrapReason(t3);
        const updatePassword = (t4) => {
          t4 instanceof Error ? __privateGet(this, _Vs).reject(t4) : __privateGet(this, _Vs).resolve({ password: t4 });
        };
        e2.onPassword(updatePassword, t3.code);
      } catch (t4) {
        __privateGet(this, _Vs).reject(t4);
      }
      return __privateGet(this, _Vs).promise;
    });
    t2.on("DataLoaded", (t3) => {
      var _a5;
      (_a5 = e2.onProgress) == null ? void 0 : _a5.call(e2, { loaded: t3.length, total: t3.length });
      this.downloadInfoCapability.resolve(t3);
    });
    t2.on("StartRenderPage", (t3) => {
      if (this.destroyed) return;
      __privateGet(this, _Gs).get(t3.pageIndex)._startRenderPage(t3.transparency, t3.cacheKey);
    });
    t2.on("commonobj", ([e3, i2, s2]) => {
      var _a5;
      if (this.destroyed) return null;
      if (this.commonObjs.has(e3)) return null;
      switch (i2) {
        case "Font":
          if ("error" in s2) {
            const t3 = s2.error;
            warn(`Error during font loading: ${t3}`);
            this.commonObjs.resolve(e3, t3);
            break;
          }
          const n2 = this._params.pdfBug && ((_a5 = globalThis.FontInspector) == null ? void 0 : _a5.enabled) ? (t3, e4) => globalThis.FontInspector.fontAdded(t3, e4) : null, a2 = new FontFaceObject(s2, n2);
          this.fontLoader.bind(a2).catch(() => t2.sendWithPromise("FontFallback", { id: e3 })).finally(() => {
            !a2.fontExtraProperties && a2.data && (a2.data = null);
            this.commonObjs.resolve(e3, a2);
          });
          break;
        case "CopyLocalImage":
          const { imageRef: r2 } = s2;
          assert(r2, "The imageRef must be defined.");
          for (const t3 of __privateGet(this, _Gs).values()) for (const [, i3] of t3.objs) if ((i3 == null ? void 0 : i3.ref) === r2) {
            if (!i3.dataLen) return null;
            this.commonObjs.resolve(e3, structuredClone(i3));
            return i3.dataLen;
          }
          break;
        case "FontPath":
        case "Image":
        case "Pattern":
          this.commonObjs.resolve(e3, s2);
          break;
        default:
          throw new Error(`Got unknown common object type ${i2}`);
      }
      return null;
    });
    t2.on("obj", ([t3, e3, i2, s2]) => {
      var _a5;
      if (this.destroyed) return;
      const n2 = __privateGet(this, _Gs).get(e3);
      if (!n2.objs.has(t3)) if (0 !== n2._intentStates.size) switch (i2) {
        case "Image":
        case "Pattern":
          n2.objs.resolve(t3, s2);
          break;
        default:
          throw new Error(`Got unknown object type ${i2}`);
      }
      else (_a5 = s2 == null ? void 0 : s2.bitmap) == null ? void 0 : _a5.close();
    });
    t2.on("DocProgress", (t3) => {
      var _a5;
      this.destroyed || ((_a5 = e2.onProgress) == null ? void 0 : _a5.call(e2, { loaded: t3.loaded, total: t3.total }));
    });
    t2.on("FetchBinaryData", async (t3) => {
      if (this.destroyed) throw new Error("Worker was destroyed.");
      const e3 = this[t3.type];
      if (!e3) throw new Error(`${t3.type} not initialized, see the \`useWorkerFetch\` parameter.`);
      return e3.fetch(t3);
    });
  }
  getData() {
    return this.messageHandler.sendWithPromise("GetData", null);
  }
  saveDocument() {
    var _a5;
    this.annotationStorage.size <= 0 && warn("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
    const { map: t2, transfer: e2 } = this.annotationStorage.serializable;
    return this.messageHandler.sendWithPromise("SaveDocument", { isPureXfa: !!this._htmlForXfa, numPages: this._numPages, annotationStorage: t2, filename: ((_a5 = this._fullReader) == null ? void 0 : _a5.filename) ?? null }, e2).finally(() => {
      this.annotationStorage.resetModified();
    });
  }
  getPage(t2) {
    if (!Number.isInteger(t2) || t2 <= 0 || t2 > this._numPages) return Promise.reject(new Error("Invalid page request."));
    const e2 = t2 - 1, i2 = __privateGet(this, _$s).get(e2);
    if (i2) return i2;
    const s2 = this.messageHandler.sendWithPromise("GetPage", { pageIndex: e2 }).then((i3) => {
      if (this.destroyed) throw new Error("Transport destroyed");
      i3.refStr && __privateGet(this, _Ws).set(i3.refStr, t2);
      const s3 = new PDFPageProxy(e2, i3, this, this._params.pdfBug);
      __privateGet(this, _Gs).set(e2, s3);
      return s3;
    });
    __privateGet(this, _$s).set(e2, s2);
    return s2;
  }
  getPageIndex(t2) {
    return isRefProxy(t2) ? this.messageHandler.sendWithPromise("GetPageIndex", { num: t2.num, gen: t2.gen }) : Promise.reject(new Error("Invalid pageIndex request."));
  }
  getAnnotations(t2, e2) {
    return this.messageHandler.sendWithPromise("GetAnnotations", { pageIndex: t2, intent: e2 });
  }
  getFieldObjects() {
    return __privateMethod(this, _WorkerTransport_instances, js_fn).call(this, "GetFieldObjects");
  }
  hasJSActions() {
    return __privateMethod(this, _WorkerTransport_instances, js_fn).call(this, "HasJSActions");
  }
  getCalculationOrderIds() {
    return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
  }
  getDestinations() {
    return this.messageHandler.sendWithPromise("GetDestinations", null);
  }
  getDestination(t2) {
    return "string" != typeof t2 ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", { id: t2 });
  }
  getPageLabels() {
    return this.messageHandler.sendWithPromise("GetPageLabels", null);
  }
  getPageLayout() {
    return this.messageHandler.sendWithPromise("GetPageLayout", null);
  }
  getPageMode() {
    return this.messageHandler.sendWithPromise("GetPageMode", null);
  }
  getViewerPreferences() {
    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
  }
  getOpenAction() {
    return this.messageHandler.sendWithPromise("GetOpenAction", null);
  }
  getAttachments() {
    return this.messageHandler.sendWithPromise("GetAttachments", null);
  }
  getDocJSActions() {
    return __privateMethod(this, _WorkerTransport_instances, js_fn).call(this, "GetDocJSActions");
  }
  getPageJSActions(t2) {
    return this.messageHandler.sendWithPromise("GetPageJSActions", { pageIndex: t2 });
  }
  getStructTree(t2) {
    return this.messageHandler.sendWithPromise("GetStructTree", { pageIndex: t2 });
  }
  getOutline() {
    return this.messageHandler.sendWithPromise("GetOutline", null);
  }
  getOptionalContentConfig(t2) {
    return __privateMethod(this, _WorkerTransport_instances, js_fn).call(this, "GetOptionalContentConfig").then((e2) => new OptionalContentConfig(e2, t2));
  }
  getPermissions() {
    return this.messageHandler.sendWithPromise("GetPermissions", null);
  }
  getMetadata() {
    const t2 = "GetMetadata", e2 = __privateGet(this, _zs).get(t2);
    if (e2) return e2;
    const i2 = this.messageHandler.sendWithPromise(t2, null).then((t3) => {
      var _a5, _b;
      return { info: t3[0], metadata: t3[1] ? new Metadata(t3[1]) : null, contentDispositionFilename: ((_a5 = this._fullReader) == null ? void 0 : _a5.filename) ?? null, contentLength: ((_b = this._fullReader) == null ? void 0 : _b.contentLength) ?? null };
    });
    __privateGet(this, _zs).set(t2, i2);
    return i2;
  }
  getMarkInfo() {
    return this.messageHandler.sendWithPromise("GetMarkInfo", null);
  }
  async startCleanup(t2 = false) {
    if (!this.destroyed) {
      await this.messageHandler.sendWithPromise("Cleanup", null);
      for (const t3 of __privateGet(this, _Gs).values()) {
        if (!t3.cleanup()) throw new Error(`startCleanup: Page ${t3.pageNumber} is currently rendering.`);
      }
      this.commonObjs.clear();
      t2 || this.fontLoader.clear();
      __privateGet(this, _zs).clear();
      this.filterFactory.destroy(true);
      TextLayer.cleanup();
    }
  }
  cachedPageNumber(t2) {
    if (!isRefProxy(t2)) return null;
    const e2 = 0 === t2.gen ? `${t2.num}R` : `${t2.num}R${t2.gen}`;
    return __privateGet(this, _Ws).get(e2) ?? null;
  }
};
_zs = new WeakMap();
_Gs = new WeakMap();
_$s = new WeakMap();
_Ws = new WeakMap();
_Vs = new WeakMap();
_WorkerTransport_instances = new WeakSet();
js_fn = function(t2, e2 = null) {
  const i2 = __privateGet(this, _zs).get(t2);
  if (i2) return i2;
  const s2 = this.messageHandler.sendWithPromise(t2, e2);
  __privateGet(this, _zs).set(t2, s2);
  return s2;
};
var _qs;
var RenderTask = class {
  constructor(t2) {
    __privateAdd(this, _qs, null);
    __publicField(this, "onContinue", null);
    __publicField(this, "onError", null);
    __privateSet(this, _qs, t2);
  }
  get promise() {
    return __privateGet(this, _qs).capability.promise;
  }
  cancel(t2 = 0) {
    __privateGet(this, _qs).cancel(null, t2);
  }
  get separateAnnots() {
    const { separateAnnots: t2 } = __privateGet(this, _qs).operatorList;
    if (!t2) return false;
    const { annotationCanvasMap: e2 } = __privateGet(this, _qs);
    return t2.form || t2.canvas && (e2 == null ? void 0 : e2.size) > 0;
  }
};
_qs = new WeakMap();
var _Xs, _Ks;
var _InternalRenderTask = class _InternalRenderTask {
  constructor({ callback: t2, params: e2, objs: i2, commonObjs: s2, annotationCanvasMap: n2, operatorList: a2, pageIndex: r2, canvasFactory: o2, filterFactory: l2, useRequestAnimationFrame: h2 = false, pdfBug: d2 = false, pageColors: c2 = null }) {
    __privateAdd(this, _Xs, null);
    this.callback = t2;
    this.params = e2;
    this.objs = i2;
    this.commonObjs = s2;
    this.annotationCanvasMap = n2;
    this.operatorListIdx = null;
    this.operatorList = a2;
    this._pageIndex = r2;
    this.canvasFactory = o2;
    this.filterFactory = l2;
    this._pdfBug = d2;
    this.pageColors = c2;
    this.running = false;
    this.graphicsReadyCallback = null;
    this.graphicsReady = false;
    this._useRequestAnimationFrame = true === h2 && "undefined" != typeof window;
    this.cancelled = false;
    this.capability = Promise.withResolvers();
    this.task = new RenderTask(this);
    this._cancelBound = this.cancel.bind(this);
    this._continueBound = this._continue.bind(this);
    this._scheduleNextBound = this._scheduleNext.bind(this);
    this._nextBound = this._next.bind(this);
    this._canvas = e2.canvasContext.canvas;
  }
  get completed() {
    return this.capability.promise.catch(function() {
    });
  }
  initializeGraphics({ transparency: t2 = false, optionalContentConfig: e2 }) {
    var _a5, _b;
    if (this.cancelled) return;
    if (this._canvas) {
      if (__privateGet(_InternalRenderTask, _Ks).has(this._canvas)) throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
      __privateGet(_InternalRenderTask, _Ks).add(this._canvas);
    }
    if (this._pdfBug && ((_a5 = globalThis.StepperManager) == null ? void 0 : _a5.enabled)) {
      this.stepper = globalThis.StepperManager.create(this._pageIndex);
      this.stepper.init(this.operatorList);
      this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
    }
    const { canvasContext: i2, viewport: s2, transform: n2, background: a2 } = this.params;
    this.gfx = new CanvasGraphics(i2, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, { optionalContentConfig: e2 }, this.annotationCanvasMap, this.pageColors);
    this.gfx.beginDrawing({ transform: n2, viewport: s2, transparency: t2, background: a2 });
    this.operatorListIdx = 0;
    this.graphicsReady = true;
    (_b = this.graphicsReadyCallback) == null ? void 0 : _b.call(this);
  }
  cancel(t2 = null, e2 = 0) {
    var _a5, _b, _c;
    this.running = false;
    this.cancelled = true;
    (_a5 = this.gfx) == null ? void 0 : _a5.endDrawing();
    if (__privateGet(this, _Xs)) {
      window.cancelAnimationFrame(__privateGet(this, _Xs));
      __privateSet(this, _Xs, null);
    }
    __privateGet(_InternalRenderTask, _Ks).delete(this._canvas);
    t2 || (t2 = new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, e2));
    this.callback(t2);
    (_c = (_b = this.task).onError) == null ? void 0 : _c.call(_b, t2);
  }
  operatorListChanged() {
    var _a5;
    if (this.graphicsReady) {
      (_a5 = this.stepper) == null ? void 0 : _a5.updateOperatorList(this.operatorList);
      this.running || this._continue();
    } else this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
  }
  _continue() {
    this.running = true;
    this.cancelled || (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
  }
  _scheduleNext() {
    this._useRequestAnimationFrame ? __privateSet(this, _Xs, window.requestAnimationFrame(() => {
      __privateSet(this, _Xs, null);
      this._nextBound().catch(this._cancelBound);
    })) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
  }
  async _next() {
    if (!this.cancelled) {
      this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
      if (this.operatorListIdx === this.operatorList.argsArray.length) {
        this.running = false;
        if (this.operatorList.lastChunk) {
          this.gfx.endDrawing();
          __privateGet(_InternalRenderTask, _Ks).delete(this._canvas);
          this.callback();
        }
      }
    }
  }
};
_Xs = new WeakMap();
_Ks = new WeakMap();
__privateAdd(_InternalRenderTask, _Ks, /* @__PURE__ */ new WeakSet());
var InternalRenderTask = _InternalRenderTask;
var yt = "5.3.31";
var vt = "47ad820d9";
function makeColorComp(t2) {
  return Math.floor(255 * Math.max(0, Math.min(1, t2))).toString(16).padStart(2, "0");
}
function scaleAndClamp(t2) {
  return Math.max(0, Math.min(255, 255 * t2));
}
var ColorConverters = class {
  static CMYK_G([t2, e2, i2, s2]) {
    return ["G", 1 - Math.min(1, 0.3 * t2 + 0.59 * i2 + 0.11 * e2 + s2)];
  }
  static G_CMYK([t2]) {
    return ["CMYK", 0, 0, 0, 1 - t2];
  }
  static G_RGB([t2]) {
    return ["RGB", t2, t2, t2];
  }
  static G_rgb([t2]) {
    return [t2 = scaleAndClamp(t2), t2, t2];
  }
  static G_HTML([t2]) {
    const e2 = makeColorComp(t2);
    return `#${e2}${e2}${e2}`;
  }
  static RGB_G([t2, e2, i2]) {
    return ["G", 0.3 * t2 + 0.59 * e2 + 0.11 * i2];
  }
  static RGB_rgb(t2) {
    return t2.map(scaleAndClamp);
  }
  static RGB_HTML(t2) {
    return `#${t2.map(makeColorComp).join("")}`;
  }
  static T_HTML() {
    return "#00000000";
  }
  static T_rgb() {
    return [null];
  }
  static CMYK_RGB([t2, e2, i2, s2]) {
    return ["RGB", 1 - Math.min(1, t2 + s2), 1 - Math.min(1, i2 + s2), 1 - Math.min(1, e2 + s2)];
  }
  static CMYK_rgb([t2, e2, i2, s2]) {
    return [scaleAndClamp(1 - Math.min(1, t2 + s2)), scaleAndClamp(1 - Math.min(1, i2 + s2)), scaleAndClamp(1 - Math.min(1, e2 + s2))];
  }
  static CMYK_HTML(t2) {
    const e2 = this.CMYK_RGB(t2).slice(1);
    return this.RGB_HTML(e2);
  }
  static RGB_CMYK([t2, e2, i2]) {
    const s2 = 1 - t2, n2 = 1 - e2, a2 = 1 - i2;
    return ["CMYK", s2, n2, a2, Math.min(s2, n2, a2)];
  }
};
var BaseSVGFactory = class {
  create(t2, e2, i2 = false) {
    if (t2 <= 0 || e2 <= 0) throw new Error("Invalid SVG dimensions");
    const s2 = this._createSVG("svg:svg");
    s2.setAttribute("version", "1.1");
    if (!i2) {
      s2.setAttribute("width", `${t2}px`);
      s2.setAttribute("height", `${e2}px`);
    }
    s2.setAttribute("preserveAspectRatio", "none");
    s2.setAttribute("viewBox", `0 0 ${t2} ${e2}`);
    return s2;
  }
  createElement(t2) {
    if ("string" != typeof t2) throw new Error("Invalid SVG element type");
    return this._createSVG(t2);
  }
  _createSVG(t2) {
    unreachable("Abstract method `_createSVG` called.");
  }
};
var DOMSVGFactory = class extends BaseSVGFactory {
  _createSVG(t2) {
    return document.createElementNS(z, t2);
  }
};
var XfaLayer = class {
  static setupStorage(t2, e2, i2, s2, n2) {
    const a2 = s2.getValue(e2, { value: null });
    switch (i2.name) {
      case "textarea":
        null !== a2.value && (t2.textContent = a2.value);
        if ("print" === n2) break;
        t2.addEventListener("input", (t3) => {
          s2.setValue(e2, { value: t3.target.value });
        });
        break;
      case "input":
        if ("radio" === i2.attributes.type || "checkbox" === i2.attributes.type) {
          a2.value === i2.attributes.xfaOn ? t2.setAttribute("checked", true) : a2.value === i2.attributes.xfaOff && t2.removeAttribute("checked");
          if ("print" === n2) break;
          t2.addEventListener("change", (t3) => {
            s2.setValue(e2, { value: t3.target.checked ? t3.target.getAttribute("xfaOn") : t3.target.getAttribute("xfaOff") });
          });
        } else {
          null !== a2.value && t2.setAttribute("value", a2.value);
          if ("print" === n2) break;
          t2.addEventListener("input", (t3) => {
            s2.setValue(e2, { value: t3.target.value });
          });
        }
        break;
      case "select":
        if (null !== a2.value) {
          t2.setAttribute("value", a2.value);
          for (const t3 of i2.children) t3.attributes.value === a2.value ? t3.attributes.selected = true : t3.attributes.hasOwnProperty("selected") && delete t3.attributes.selected;
        }
        t2.addEventListener("input", (t3) => {
          const i3 = t3.target.options, n3 = -1 === i3.selectedIndex ? "" : i3[i3.selectedIndex].value;
          s2.setValue(e2, { value: n3 });
        });
    }
  }
  static setAttributes({ html: t2, element: e2, storage: i2 = null, intent: s2, linkService: n2 }) {
    const { attributes: a2 } = e2, r2 = t2 instanceof HTMLAnchorElement;
    "radio" === a2.type && (a2.name = `${a2.name}-${s2}`);
    for (const [e3, i3] of Object.entries(a2)) if (null != i3) switch (e3) {
      case "class":
        i3.length && t2.setAttribute(e3, i3.join(" "));
        break;
      case "dataId":
        break;
      case "id":
        t2.setAttribute("data-element-id", i3);
        break;
      case "style":
        Object.assign(t2.style, i3);
        break;
      case "textContent":
        t2.textContent = i3;
        break;
      default:
        (!r2 || "href" !== e3 && "newWindow" !== e3) && t2.setAttribute(e3, i3);
    }
    r2 && n2.addLinkAttributes(t2, a2.href, a2.newWindow);
    i2 && a2.dataId && this.setupStorage(t2, a2.dataId, e2, i2);
  }
  static render(t2) {
    var _a5, _b;
    const e2 = t2.annotationStorage, i2 = t2.linkService, s2 = t2.xfaHtml, n2 = t2.intent || "display", a2 = document.createElement(s2.name);
    s2.attributes && this.setAttributes({ html: a2, element: s2, intent: n2, linkService: i2 });
    const r2 = "richText" !== n2, o2 = t2.div;
    o2.append(a2);
    if (t2.viewport) {
      const e3 = `matrix(${t2.viewport.transform.join(",")})`;
      o2.style.transform = e3;
    }
    r2 && o2.setAttribute("class", "xfaLayer xfaFont");
    const l2 = [];
    if (0 === s2.children.length) {
      if (s2.value) {
        const t3 = document.createTextNode(s2.value);
        a2.append(t3);
        r2 && XfaText.shouldBuildText(s2.name) && l2.push(t3);
      }
      return { textDivs: l2 };
    }
    const h2 = [[s2, -1, a2]];
    for (; h2.length > 0; ) {
      const [t3, s3, a3] = h2.at(-1);
      if (s3 + 1 === t3.children.length) {
        h2.pop();
        continue;
      }
      const o3 = t3.children[++h2.at(-1)[1]];
      if (null === o3) continue;
      const { name: d2 } = o3;
      if ("#text" === d2) {
        const t4 = document.createTextNode(o3.value);
        l2.push(t4);
        a3.append(t4);
        continue;
      }
      const c2 = ((_a5 = o3 == null ? void 0 : o3.attributes) == null ? void 0 : _a5.xmlns) ? document.createElementNS(o3.attributes.xmlns, d2) : document.createElement(d2);
      a3.append(c2);
      o3.attributes && this.setAttributes({ html: c2, element: o3, storage: e2, intent: n2, linkService: i2 });
      if (((_b = o3.children) == null ? void 0 : _b.length) > 0) h2.push([o3, -1, c2]);
      else if (o3.value) {
        const t4 = document.createTextNode(o3.value);
        r2 && XfaText.shouldBuildText(d2) && l2.push(t4);
        c2.append(t4);
      }
    }
    for (const t3 of o2.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) t3.setAttribute("readOnly", true);
    return { textDivs: l2 };
  }
  static update(t2) {
    const e2 = `matrix(${t2.viewport.transform.join(",")})`;
    t2.div.style.transform = e2;
    t2.div.hidden = false;
  }
};
var xt = 1e3;
var Et = /* @__PURE__ */ new WeakSet();
var AnnotationElementFactory = class {
  static create(t2) {
    switch (t2.data.annotationType) {
      case x.LINK:
        return new LinkAnnotationElement(t2);
      case x.TEXT:
        return new TextAnnotationElement(t2);
      case x.WIDGET:
        switch (t2.data.fieldType) {
          case "Tx":
            return new TextWidgetAnnotationElement(t2);
          case "Btn":
            return t2.data.radioButton ? new RadioButtonWidgetAnnotationElement(t2) : t2.data.checkBox ? new CheckboxWidgetAnnotationElement(t2) : new PushButtonWidgetAnnotationElement(t2);
          case "Ch":
            return new ChoiceWidgetAnnotationElement(t2);
          case "Sig":
            return new SignatureWidgetAnnotationElement(t2);
        }
        return new WidgetAnnotationElement(t2);
      case x.POPUP:
        return new PopupAnnotationElement(t2);
      case x.FREETEXT:
        return new FreeTextAnnotationElement(t2);
      case x.LINE:
        return new LineAnnotationElement(t2);
      case x.SQUARE:
        return new SquareAnnotationElement(t2);
      case x.CIRCLE:
        return new CircleAnnotationElement(t2);
      case x.POLYLINE:
        return new PolylineAnnotationElement(t2);
      case x.CARET:
        return new CaretAnnotationElement(t2);
      case x.INK:
        return new InkAnnotationElement(t2);
      case x.POLYGON:
        return new PolygonAnnotationElement(t2);
      case x.HIGHLIGHT:
        return new HighlightAnnotationElement(t2);
      case x.UNDERLINE:
        return new UnderlineAnnotationElement(t2);
      case x.SQUIGGLY:
        return new SquigglyAnnotationElement(t2);
      case x.STRIKEOUT:
        return new StrikeOutAnnotationElement(t2);
      case x.STAMP:
        return new StampAnnotationElement(t2);
      case x.FILEATTACHMENT:
        return new FileAttachmentAnnotationElement(t2);
      default:
        return new AnnotationElement(t2);
    }
  }
};
var _Ys, _Qs, _Js, _AnnotationElement_instances, Zs_fn;
var _AnnotationElement = class _AnnotationElement {
  constructor(t2, { isRenderable: e2 = false, ignoreBorder: i2 = false, createQuadrilaterals: s2 = false } = {}) {
    __privateAdd(this, _AnnotationElement_instances);
    __privateAdd(this, _Ys, null);
    __privateAdd(this, _Qs, false);
    __privateAdd(this, _Js, null);
    this.isRenderable = e2;
    this.data = t2.data;
    this.layer = t2.layer;
    this.linkService = t2.linkService;
    this.downloadManager = t2.downloadManager;
    this.imageResourcesPath = t2.imageResourcesPath;
    this.renderForms = t2.renderForms;
    this.svgFactory = t2.svgFactory;
    this.annotationStorage = t2.annotationStorage;
    this.enableScripting = t2.enableScripting;
    this.hasJSActions = t2.hasJSActions;
    this._fieldObjects = t2.fieldObjects;
    this.parent = t2.parent;
    e2 && (this.container = this._createContainer(i2));
    s2 && this._createQuadrilaterals();
  }
  static _hasPopupData({ titleObj: t2, contentsObj: e2, richText: i2 }) {
    return !!((t2 == null ? void 0 : t2.str) || (e2 == null ? void 0 : e2.str) || (i2 == null ? void 0 : i2.str));
  }
  get _isEditable() {
    return this.data.isEditable;
  }
  get hasPopupData() {
    return _AnnotationElement._hasPopupData(this.data);
  }
  updateEdited(t2) {
    var _a5;
    if (!this.container) return;
    __privateGet(this, _Ys) || __privateSet(this, _Ys, { rect: this.data.rect.slice(0) });
    const { rect: e2 } = t2;
    e2 && __privateMethod(this, _AnnotationElement_instances, Zs_fn).call(this, e2);
    (_a5 = __privateGet(this, _Js)) == null ? void 0 : _a5.popup.updateEdited(t2);
  }
  resetEdited() {
    var _a5;
    if (__privateGet(this, _Ys)) {
      __privateMethod(this, _AnnotationElement_instances, Zs_fn).call(this, __privateGet(this, _Ys).rect);
      (_a5 = __privateGet(this, _Js)) == null ? void 0 : _a5.popup.resetEdited();
      __privateSet(this, _Ys, null);
    }
  }
  _createContainer(t2) {
    const { data: e2, parent: { page: i2, viewport: s2 } } = this, n2 = document.createElement("section");
    n2.setAttribute("data-annotation-id", e2.id);
    this instanceof WidgetAnnotationElement || (n2.tabIndex = xt);
    const { style: a2 } = n2;
    a2.zIndex = this.parent.zIndex++;
    e2.alternativeText && (n2.title = e2.alternativeText);
    e2.noRotate && n2.classList.add("norotate");
    if (!e2.rect || this instanceof PopupAnnotationElement) {
      const { rotation: t3 } = e2;
      e2.hasOwnCanvas || 0 === t3 || this.setRotation(t3, n2);
      return n2;
    }
    const { width: r2, height: o2 } = this;
    if (!t2 && e2.borderStyle.width > 0) {
      a2.borderWidth = `${e2.borderStyle.width}px`;
      const t3 = e2.borderStyle.horizontalCornerRadius, i3 = e2.borderStyle.verticalCornerRadius;
      if (t3 > 0 || i3 > 0) {
        const e3 = `calc(${t3}px * var(--total-scale-factor)) / calc(${i3}px * var(--total-scale-factor))`;
        a2.borderRadius = e3;
      } else if (this instanceof RadioButtonWidgetAnnotationElement) {
        const t4 = `calc(${r2}px * var(--total-scale-factor)) / calc(${o2}px * var(--total-scale-factor))`;
        a2.borderRadius = t4;
      }
      switch (e2.borderStyle.style) {
        case E:
          a2.borderStyle = "solid";
          break;
        case _:
          a2.borderStyle = "dashed";
          break;
        case S:
          warn("Unimplemented border style: beveled");
          break;
        case C:
          warn("Unimplemented border style: inset");
          break;
        case T:
          a2.borderBottomStyle = "solid";
      }
      const s3 = e2.borderColor || null;
      if (s3) {
        __privateSet(this, _Qs, true);
        a2.borderColor = Util.makeHexColor(0 | s3[0], 0 | s3[1], 0 | s3[2]);
      } else a2.borderWidth = 0;
    }
    const l2 = Util.normalizeRect([e2.rect[0], i2.view[3] - e2.rect[1] + i2.view[1], e2.rect[2], i2.view[3] - e2.rect[3] + i2.view[1]]), { pageWidth: h2, pageHeight: d2, pageX: c2, pageY: u2 } = s2.rawDims;
    a2.left = 100 * (l2[0] - c2) / h2 + "%";
    a2.top = 100 * (l2[1] - u2) / d2 + "%";
    const { rotation: p2 } = e2;
    if (e2.hasOwnCanvas || 0 === p2) {
      a2.width = 100 * r2 / h2 + "%";
      a2.height = 100 * o2 / d2 + "%";
    } else this.setRotation(p2, n2);
    return n2;
  }
  setRotation(t2, e2 = this.container) {
    if (!this.data.rect) return;
    const { pageWidth: i2, pageHeight: s2 } = this.parent.viewport.rawDims;
    let { width: n2, height: a2 } = this;
    t2 % 180 != 0 && ([n2, a2] = [a2, n2]);
    e2.style.width = 100 * n2 / i2 + "%";
    e2.style.height = 100 * a2 / s2 + "%";
    e2.setAttribute("data-main-rotation", (360 - t2) % 360);
  }
  get _commonActions() {
    const setColor = (t2, e2, i2) => {
      const s2 = i2.detail[t2], n2 = s2[0], a2 = s2.slice(1);
      i2.target.style[e2] = ColorConverters[`${n2}_HTML`](a2);
      this.annotationStorage.setValue(this.data.id, { [e2]: ColorConverters[`${n2}_rgb`](a2) });
    };
    return shadow(this, "_commonActions", { display: (t2) => {
      const { display: e2 } = t2.detail, i2 = e2 % 2 == 1;
      this.container.style.visibility = i2 ? "hidden" : "visible";
      this.annotationStorage.setValue(this.data.id, { noView: i2, noPrint: 1 === e2 || 2 === e2 });
    }, print: (t2) => {
      this.annotationStorage.setValue(this.data.id, { noPrint: !t2.detail.print });
    }, hidden: (t2) => {
      const { hidden: e2 } = t2.detail;
      this.container.style.visibility = e2 ? "hidden" : "visible";
      this.annotationStorage.setValue(this.data.id, { noPrint: e2, noView: e2 });
    }, focus: (t2) => {
      setTimeout(() => t2.target.focus({ preventScroll: false }), 0);
    }, userName: (t2) => {
      t2.target.title = t2.detail.userName;
    }, readonly: (t2) => {
      t2.target.disabled = t2.detail.readonly;
    }, required: (t2) => {
      this._setRequired(t2.target, t2.detail.required);
    }, bgColor: (t2) => {
      setColor("bgColor", "backgroundColor", t2);
    }, fillColor: (t2) => {
      setColor("fillColor", "backgroundColor", t2);
    }, fgColor: (t2) => {
      setColor("fgColor", "color", t2);
    }, textColor: (t2) => {
      setColor("textColor", "color", t2);
    }, borderColor: (t2) => {
      setColor("borderColor", "borderColor", t2);
    }, strokeColor: (t2) => {
      setColor("strokeColor", "borderColor", t2);
    }, rotation: (t2) => {
      const e2 = t2.detail.rotation;
      this.setRotation(e2);
      this.annotationStorage.setValue(this.data.id, { rotation: e2 });
    } });
  }
  _dispatchEventFromSandbox(t2, e2) {
    const i2 = this._commonActions;
    for (const s2 of Object.keys(e2.detail)) {
      const n2 = t2[s2] || i2[s2];
      n2 == null ? void 0 : n2(e2);
    }
  }
  _setDefaultPropertiesFromJS(t2) {
    if (!this.enableScripting) return;
    const e2 = this.annotationStorage.getRawValue(this.data.id);
    if (!e2) return;
    const i2 = this._commonActions;
    for (const [s2, n2] of Object.entries(e2)) {
      const a2 = i2[s2];
      if (a2) {
        a2({ detail: { [s2]: n2 }, target: t2 });
        delete e2[s2];
      }
    }
  }
  _createQuadrilaterals() {
    if (!this.container) return;
    const { quadPoints: t2 } = this.data;
    if (!t2) return;
    const [e2, i2, s2, n2] = this.data.rect.map((t3) => Math.fround(t3));
    if (8 === t2.length) {
      const [a3, r3, o3, l3] = t2.subarray(2, 6);
      if (s2 === a3 && n2 === r3 && e2 === o3 && i2 === l3) return;
    }
    const { style: a2 } = this.container;
    let r2;
    if (__privateGet(this, _Qs)) {
      const { borderColor: t3, borderWidth: e3 } = a2;
      a2.borderWidth = 0;
      r2 = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${t3}" stroke-width="${e3}">`];
      this.container.classList.add("hasBorder");
    }
    const o2 = s2 - e2, l2 = n2 - i2, { svgFactory: h2 } = this, d2 = h2.createElement("svg");
    d2.classList.add("quadrilateralsContainer");
    d2.setAttribute("width", 0);
    d2.setAttribute("height", 0);
    const c2 = h2.createElement("defs");
    d2.append(c2);
    const u2 = h2.createElement("clipPath"), p2 = `clippath_${this.data.id}`;
    u2.setAttribute("id", p2);
    u2.setAttribute("clipPathUnits", "objectBoundingBox");
    c2.append(u2);
    for (let i3 = 2, s3 = t2.length; i3 < s3; i3 += 8) {
      const s4 = t2[i3], a3 = t2[i3 + 1], d3 = t2[i3 + 2], c3 = t2[i3 + 3], p3 = h2.createElement("rect"), g2 = (d3 - e2) / o2, f2 = (n2 - a3) / l2, m2 = (s4 - d3) / o2, b2 = (a3 - c3) / l2;
      p3.setAttribute("x", g2);
      p3.setAttribute("y", f2);
      p3.setAttribute("width", m2);
      p3.setAttribute("height", b2);
      u2.append(p3);
      r2 == null ? void 0 : r2.push(`<rect vector-effect="non-scaling-stroke" x="${g2}" y="${f2}" width="${m2}" height="${b2}"/>`);
    }
    if (__privateGet(this, _Qs)) {
      r2.push("</g></svg>')");
      a2.backgroundImage = r2.join("");
    }
    this.container.append(d2);
    this.container.style.clipPath = `url(#${p2})`;
  }
  _createPopup() {
    const { data: t2 } = this, e2 = __privateSet(this, _Js, new PopupAnnotationElement({ data: { color: t2.color, titleObj: t2.titleObj, modificationDate: t2.modificationDate, contentsObj: t2.contentsObj, richText: t2.richText, parentRect: t2.rect, borderStyle: 0, id: `popup_${t2.id}`, rotation: t2.rotation }, parent: this.parent, elements: [this] }));
    this.parent.div.append(e2.render());
  }
  render() {
    unreachable("Abstract method `AnnotationElement.render` called");
  }
  _getElementsByName(t2, e2 = null) {
    const i2 = [];
    if (this._fieldObjects) {
      const s2 = this._fieldObjects[t2];
      if (s2) for (const { page: t3, id: n2, exportValues: a2 } of s2) {
        if (-1 === t3) continue;
        if (n2 === e2) continue;
        const s3 = "string" == typeof a2 ? a2 : null, r2 = document.querySelector(`[data-element-id="${n2}"]`);
        !r2 || Et.has(r2) ? i2.push({ id: n2, exportValue: s3, domElement: r2 }) : warn(`_getElementsByName - element not allowed: ${n2}`);
      }
      return i2;
    }
    for (const s2 of document.getElementsByName(t2)) {
      const { exportValue: t3 } = s2, n2 = s2.getAttribute("data-element-id");
      n2 !== e2 && (Et.has(s2) && i2.push({ id: n2, exportValue: t3, domElement: s2 }));
    }
    return i2;
  }
  show() {
    var _a5;
    this.container && (this.container.hidden = false);
    (_a5 = this.popup) == null ? void 0 : _a5.maybeShow();
  }
  hide() {
    var _a5;
    this.container && (this.container.hidden = true);
    (_a5 = this.popup) == null ? void 0 : _a5.forceHide();
  }
  getElementsToTriggerPopup() {
    return this.container;
  }
  addHighlightArea() {
    const t2 = this.getElementsToTriggerPopup();
    if (Array.isArray(t2)) for (const e2 of t2) e2.classList.add("highlightArea");
    else t2.classList.add("highlightArea");
  }
  _editOnDoubleClick() {
    if (!this._isEditable) return;
    const { annotationEditorType: t2, data: { id: e2 } } = this;
    this.container.addEventListener("dblclick", () => {
      var _a5;
      (_a5 = this.linkService.eventBus) == null ? void 0 : _a5.dispatch("switchannotationeditormode", { source: this, mode: t2, editId: e2 });
    });
  }
  get width() {
    return this.data.rect[2] - this.data.rect[0];
  }
  get height() {
    return this.data.rect[3] - this.data.rect[1];
  }
};
_Ys = new WeakMap();
_Qs = new WeakMap();
_Js = new WeakMap();
_AnnotationElement_instances = new WeakSet();
Zs_fn = function(t2) {
  const { container: { style: e2 }, data: { rect: i2, rotation: s2 }, parent: { viewport: { rawDims: { pageWidth: n2, pageHeight: a2, pageX: r2, pageY: o2 } } } } = this;
  i2 == null ? void 0 : i2.splice(0, 4, ...t2);
  e2.left = 100 * (t2[0] - r2) / n2 + "%";
  e2.top = 100 * (a2 - t2[3] + o2) / a2 + "%";
  if (0 === s2) {
    e2.width = 100 * (t2[2] - t2[0]) / n2 + "%";
    e2.height = 100 * (t2[3] - t2[1]) / a2 + "%";
  } else this.setRotation(s2);
};
var AnnotationElement = _AnnotationElement;
var _LinkAnnotationElement_instances, in_fn, tn_fn, en_fn;
var LinkAnnotationElement = class extends AnnotationElement {
  constructor(t2, e2 = null) {
    super(t2, { isRenderable: true, ignoreBorder: !!(e2 == null ? void 0 : e2.ignoreBorder), createQuadrilaterals: true });
    __privateAdd(this, _LinkAnnotationElement_instances);
    this.isTooltipOnly = t2.data.isTooltipOnly;
  }
  render() {
    const { data: t2, linkService: e2 } = this, i2 = document.createElement("a");
    i2.setAttribute("data-element-id", t2.id);
    let s2 = false;
    if (t2.url) {
      e2.addLinkAttributes(i2, t2.url, t2.newWindow);
      s2 = true;
    } else if (t2.action) {
      this._bindNamedAction(i2, t2.action);
      s2 = true;
    } else if (t2.attachment) {
      __privateMethod(this, _LinkAnnotationElement_instances, tn_fn).call(this, i2, t2.attachment, t2.attachmentDest);
      s2 = true;
    } else if (t2.setOCGState) {
      __privateMethod(this, _LinkAnnotationElement_instances, en_fn).call(this, i2, t2.setOCGState);
      s2 = true;
    } else if (t2.dest) {
      this._bindLink(i2, t2.dest);
      s2 = true;
    } else {
      if (t2.actions && (t2.actions.Action || t2.actions["Mouse Up"] || t2.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
        this._bindJSAction(i2, t2);
        s2 = true;
      }
      if (t2.resetForm) {
        this._bindResetFormAction(i2, t2.resetForm);
        s2 = true;
      } else if (this.isTooltipOnly && !s2) {
        this._bindLink(i2, "");
        s2 = true;
      }
    }
    this.container.classList.add("linkAnnotation");
    s2 && this.container.append(i2);
    return this.container;
  }
  _bindLink(t2, e2) {
    t2.href = this.linkService.getDestinationHash(e2);
    t2.onclick = () => {
      e2 && this.linkService.goToDestination(e2);
      return false;
    };
    (e2 || "" === e2) && __privateMethod(this, _LinkAnnotationElement_instances, in_fn).call(this);
  }
  _bindNamedAction(t2, e2) {
    t2.href = this.linkService.getAnchorUrl("");
    t2.onclick = () => {
      this.linkService.executeNamedAction(e2);
      return false;
    };
    __privateMethod(this, _LinkAnnotationElement_instances, in_fn).call(this);
  }
  _bindJSAction(t2, e2) {
    t2.href = this.linkService.getAnchorUrl("");
    const i2 = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
    for (const s2 of Object.keys(e2.actions)) {
      const n2 = i2.get(s2);
      n2 && (t2[n2] = () => {
        var _a5;
        (_a5 = this.linkService.eventBus) == null ? void 0 : _a5.dispatch("dispatcheventinsandbox", { source: this, detail: { id: e2.id, name: s2 } });
        return false;
      });
    }
    t2.onclick || (t2.onclick = () => false);
    __privateMethod(this, _LinkAnnotationElement_instances, in_fn).call(this);
  }
  _bindResetFormAction(t2, e2) {
    const i2 = t2.onclick;
    i2 || (t2.href = this.linkService.getAnchorUrl(""));
    __privateMethod(this, _LinkAnnotationElement_instances, in_fn).call(this);
    if (this._fieldObjects) t2.onclick = () => {
      var _a5;
      i2 == null ? void 0 : i2();
      const { fields: t3, refs: s2, include: n2 } = e2, a2 = [];
      if (0 !== t3.length || 0 !== s2.length) {
        const e3 = new Set(s2);
        for (const i3 of t3) {
          const t4 = this._fieldObjects[i3] || [];
          for (const { id: i4 } of t4) e3.add(i4);
        }
        for (const t4 of Object.values(this._fieldObjects)) for (const i3 of t4) e3.has(i3.id) === n2 && a2.push(i3);
      } else for (const t4 of Object.values(this._fieldObjects)) a2.push(...t4);
      const r2 = this.annotationStorage, o2 = [];
      for (const t4 of a2) {
        const { id: e3 } = t4;
        o2.push(e3);
        switch (t4.type) {
          case "text": {
            const i4 = t4.defaultValue || "";
            r2.setValue(e3, { value: i4 });
            break;
          }
          case "checkbox":
          case "radiobutton": {
            const i4 = t4.defaultValue === t4.exportValues;
            r2.setValue(e3, { value: i4 });
            break;
          }
          case "combobox":
          case "listbox": {
            const i4 = t4.defaultValue || "";
            r2.setValue(e3, { value: i4 });
            break;
          }
          default:
            continue;
        }
        const i3 = document.querySelector(`[data-element-id="${e3}"]`);
        i3 && (Et.has(i3) ? i3.dispatchEvent(new Event("resetform")) : warn(`_bindResetFormAction - element not allowed: ${e3}`));
      }
      this.enableScripting && ((_a5 = this.linkService.eventBus) == null ? void 0 : _a5.dispatch("dispatcheventinsandbox", { source: this, detail: { id: "app", ids: o2, name: "ResetForm" } }));
      return false;
    };
    else {
      warn('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.');
      i2 || (t2.onclick = () => false);
    }
  }
};
_LinkAnnotationElement_instances = new WeakSet();
in_fn = function() {
  this.container.setAttribute("data-internal-link", "");
};
tn_fn = function(t2, e2, i2 = null) {
  t2.href = this.linkService.getAnchorUrl("");
  e2.description && (t2.title = e2.description);
  t2.onclick = () => {
    var _a5;
    (_a5 = this.downloadManager) == null ? void 0 : _a5.openOrDownloadData(e2.content, e2.filename, i2);
    return false;
  };
  __privateMethod(this, _LinkAnnotationElement_instances, in_fn).call(this);
};
en_fn = function(t2, e2) {
  t2.href = this.linkService.getAnchorUrl("");
  t2.onclick = () => {
    this.linkService.executeSetOCGState(e2);
    return false;
  };
  __privateMethod(this, _LinkAnnotationElement_instances, in_fn).call(this);
};
var TextAnnotationElement = class extends AnnotationElement {
  constructor(t2) {
    super(t2, { isRenderable: true });
  }
  render() {
    this.container.classList.add("textAnnotation");
    const t2 = document.createElement("img");
    t2.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
    t2.setAttribute("data-l10n-id", "pdfjs-text-annotation-type");
    t2.setAttribute("data-l10n-args", JSON.stringify({ type: this.data.name }));
    !this.data.popupRef && this.hasPopupData && this._createPopup();
    this.container.append(t2);
    return this.container;
  }
};
var WidgetAnnotationElement = class extends AnnotationElement {
  render() {
    return this.container;
  }
  showElementAndHideCanvas(t2) {
    var _a5;
    if (this.data.hasOwnCanvas) {
      "CANVAS" === ((_a5 = t2.previousSibling) == null ? void 0 : _a5.nodeName) && (t2.previousSibling.hidden = true);
      t2.hidden = false;
    }
  }
  _getKeyModifier(t2) {
    return util_FeatureTest.platform.isMac ? t2.metaKey : t2.ctrlKey;
  }
  _setEventListener(t2, e2, i2, s2, n2) {
    i2.includes("mouse") ? t2.addEventListener(i2, (t3) => {
      var _a5;
      (_a5 = this.linkService.eventBus) == null ? void 0 : _a5.dispatch("dispatcheventinsandbox", { source: this, detail: { id: this.data.id, name: s2, value: n2(t3), shift: t3.shiftKey, modifier: this._getKeyModifier(t3) } });
    }) : t2.addEventListener(i2, (t3) => {
      var _a5;
      if ("blur" === i2) {
        if (!e2.focused || !t3.relatedTarget) return;
        e2.focused = false;
      } else if ("focus" === i2) {
        if (e2.focused) return;
        e2.focused = true;
      }
      n2 && ((_a5 = this.linkService.eventBus) == null ? void 0 : _a5.dispatch("dispatcheventinsandbox", { source: this, detail: { id: this.data.id, name: s2, value: n2(t3) } }));
    });
  }
  _setEventListeners(t2, e2, i2, s2) {
    var _a5, _b, _c;
    for (const [n2, a2] of i2) if ("Action" === a2 || ((_a5 = this.data.actions) == null ? void 0 : _a5[a2])) {
      "Focus" !== a2 && "Blur" !== a2 || (e2 || (e2 = { focused: false }));
      this._setEventListener(t2, e2, n2, a2, s2);
      "Focus" !== a2 || ((_b = this.data.actions) == null ? void 0 : _b.Blur) ? "Blur" !== a2 || ((_c = this.data.actions) == null ? void 0 : _c.Focus) || this._setEventListener(t2, e2, "focus", "Focus", null) : this._setEventListener(t2, e2, "blur", "Blur", null);
    }
  }
  _setBackgroundColor(t2) {
    const e2 = this.data.backgroundColor || null;
    t2.style.backgroundColor = null === e2 ? "transparent" : Util.makeHexColor(e2[0], e2[1], e2[2]);
  }
  _setTextStyle(t2) {
    const e2 = ["left", "center", "right"], { fontColor: s2 } = this.data.defaultAppearanceData, n2 = this.data.defaultAppearanceData.fontSize || 9, a2 = t2.style;
    let r2;
    const roundToOneDecimal = (t3) => Math.round(10 * t3) / 10;
    if (this.data.multiLine) {
      const t3 = Math.abs(this.data.rect[3] - this.data.rect[1] - 2), e3 = t3 / (Math.round(t3 / (i * n2)) || 1);
      r2 = Math.min(n2, roundToOneDecimal(e3 / i));
    } else {
      const t3 = Math.abs(this.data.rect[3] - this.data.rect[1] - 2);
      r2 = Math.min(n2, roundToOneDecimal(t3 / i));
    }
    a2.fontSize = `calc(${r2}px * var(--total-scale-factor))`;
    a2.color = Util.makeHexColor(s2[0], s2[1], s2[2]);
    null !== this.data.textAlignment && (a2.textAlign = e2[this.data.textAlignment]);
  }
  _setRequired(t2, e2) {
    e2 ? t2.setAttribute("required", true) : t2.removeAttribute("required");
    t2.setAttribute("aria-required", e2);
  }
};
var TextWidgetAnnotationElement = class extends WidgetAnnotationElement {
  constructor(t2) {
    super(t2, { isRenderable: t2.renderForms || t2.data.hasOwnCanvas || !t2.data.hasAppearance && !!t2.data.fieldValue });
  }
  setPropertyOnSiblings(t2, e2, i2, s2) {
    const n2 = this.annotationStorage;
    for (const a2 of this._getElementsByName(t2.name, t2.id)) {
      a2.domElement && (a2.domElement[e2] = i2);
      n2.setValue(a2.id, { [s2]: i2 });
    }
  }
  render() {
    var _a5, _b;
    const t2 = this.annotationStorage, e2 = this.data.id;
    this.container.classList.add("textWidgetAnnotation");
    let i2 = null;
    if (this.renderForms) {
      const s2 = t2.getValue(e2, { value: this.data.fieldValue });
      let n2 = s2.value || "";
      const a2 = t2.getValue(e2, { charLimit: this.data.maxLen }).charLimit;
      a2 && n2.length > a2 && (n2 = n2.slice(0, a2));
      let r2 = s2.formattedValue || ((_a5 = this.data.textContent) == null ? void 0 : _a5.join("\n")) || null;
      r2 && this.data.comb && (r2 = r2.replaceAll(/\s+/g, ""));
      const o2 = { userValue: n2, formattedValue: r2, lastCommittedValue: null, commitKey: 1, focused: false };
      if (this.data.multiLine) {
        i2 = document.createElement("textarea");
        i2.textContent = r2 ?? n2;
        this.data.doNotScroll && (i2.style.overflowY = "hidden");
      } else {
        i2 = document.createElement("input");
        i2.type = this.data.password ? "password" : "text";
        i2.setAttribute("value", r2 ?? n2);
        this.data.doNotScroll && (i2.style.overflowX = "hidden");
      }
      this.data.hasOwnCanvas && (i2.hidden = true);
      Et.add(i2);
      i2.setAttribute("data-element-id", e2);
      i2.disabled = this.data.readOnly;
      i2.name = this.data.fieldName;
      i2.tabIndex = xt;
      this._setRequired(i2, this.data.required);
      a2 && (i2.maxLength = a2);
      i2.addEventListener("input", (s3) => {
        t2.setValue(e2, { value: s3.target.value });
        this.setPropertyOnSiblings(i2, "value", s3.target.value, "value");
        o2.formattedValue = null;
      });
      i2.addEventListener("resetform", (t3) => {
        const e3 = this.data.defaultFieldValue ?? "";
        i2.value = o2.userValue = e3;
        o2.formattedValue = null;
      });
      let blurListener = (t3) => {
        const { formattedValue: e3 } = o2;
        null != e3 && (t3.target.value = e3);
        t3.target.scrollLeft = 0;
      };
      if (this.enableScripting && this.hasJSActions) {
        i2.addEventListener("focus", (t3) => {
          var _a6;
          if (o2.focused) return;
          const { target: e3 } = t3;
          o2.userValue && (e3.value = o2.userValue);
          o2.lastCommittedValue = e3.value;
          o2.commitKey = 1;
          ((_a6 = this.data.actions) == null ? void 0 : _a6.Focus) || (o2.focused = true);
        });
        i2.addEventListener("updatefromsandbox", (i3) => {
          this.showElementAndHideCanvas(i3.target);
          const s4 = { value(i4) {
            o2.userValue = i4.detail.value ?? "";
            t2.setValue(e2, { value: o2.userValue.toString() });
            i4.target.value = o2.userValue;
          }, formattedValue(i4) {
            const { formattedValue: s5 } = i4.detail;
            o2.formattedValue = s5;
            null != s5 && i4.target !== document.activeElement && (i4.target.value = s5);
            t2.setValue(e2, { formattedValue: s5 });
          }, selRange(t3) {
            t3.target.setSelectionRange(...t3.detail.selRange);
          }, charLimit: (i4) => {
            var _a6;
            const { charLimit: s5 } = i4.detail, { target: n3 } = i4;
            if (0 === s5) {
              n3.removeAttribute("maxLength");
              return;
            }
            n3.setAttribute("maxLength", s5);
            let a3 = o2.userValue;
            if (a3 && !(a3.length <= s5)) {
              a3 = a3.slice(0, s5);
              n3.value = o2.userValue = a3;
              t2.setValue(e2, { value: a3 });
              (_a6 = this.linkService.eventBus) == null ? void 0 : _a6.dispatch("dispatcheventinsandbox", { source: this, detail: { id: e2, name: "Keystroke", value: a3, willCommit: true, commitKey: 1, selStart: n3.selectionStart, selEnd: n3.selectionEnd } });
            }
          } };
          this._dispatchEventFromSandbox(s4, i3);
        });
        i2.addEventListener("keydown", (t3) => {
          var _a6;
          o2.commitKey = 1;
          let i3 = -1;
          "Escape" === t3.key ? i3 = 0 : "Enter" !== t3.key || this.data.multiLine ? "Tab" === t3.key && (o2.commitKey = 3) : i3 = 2;
          if (-1 === i3) return;
          const { value: s4 } = t3.target;
          if (o2.lastCommittedValue !== s4) {
            o2.lastCommittedValue = s4;
            o2.userValue = s4;
            (_a6 = this.linkService.eventBus) == null ? void 0 : _a6.dispatch("dispatcheventinsandbox", { source: this, detail: { id: e2, name: "Keystroke", value: s4, willCommit: true, commitKey: i3, selStart: t3.target.selectionStart, selEnd: t3.target.selectionEnd } });
          }
        });
        const s3 = blurListener;
        blurListener = null;
        i2.addEventListener("blur", (t3) => {
          var _a6, _b2;
          if (!o2.focused || !t3.relatedTarget) return;
          ((_a6 = this.data.actions) == null ? void 0 : _a6.Blur) || (o2.focused = false);
          const { value: i3 } = t3.target;
          o2.userValue = i3;
          o2.lastCommittedValue !== i3 && ((_b2 = this.linkService.eventBus) == null ? void 0 : _b2.dispatch("dispatcheventinsandbox", { source: this, detail: { id: e2, name: "Keystroke", value: i3, willCommit: true, commitKey: o2.commitKey, selStart: t3.target.selectionStart, selEnd: t3.target.selectionEnd } }));
          s3(t3);
        });
        ((_b = this.data.actions) == null ? void 0 : _b.Keystroke) && i2.addEventListener("beforeinput", (t3) => {
          var _a6;
          o2.lastCommittedValue = null;
          const { data: i3, target: s4 } = t3, { value: n3, selectionStart: a3, selectionEnd: r3 } = s4;
          let l2 = a3, h2 = r3;
          switch (t3.inputType) {
            case "deleteWordBackward": {
              const t4 = n3.substring(0, a3).match(/\w*[^\w]*$/);
              t4 && (l2 -= t4[0].length);
              break;
            }
            case "deleteWordForward": {
              const t4 = n3.substring(a3).match(/^[^\w]*\w*/);
              t4 && (h2 += t4[0].length);
              break;
            }
            case "deleteContentBackward":
              a3 === r3 && (l2 -= 1);
              break;
            case "deleteContentForward":
              a3 === r3 && (h2 += 1);
          }
          t3.preventDefault();
          (_a6 = this.linkService.eventBus) == null ? void 0 : _a6.dispatch("dispatcheventinsandbox", { source: this, detail: { id: e2, name: "Keystroke", value: n3, change: i3 || "", willCommit: false, selStart: l2, selEnd: h2 } });
        });
        this._setEventListeners(i2, o2, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (t3) => t3.target.value);
      }
      blurListener && i2.addEventListener("blur", blurListener);
      if (this.data.comb) {
        const t3 = (this.data.rect[2] - this.data.rect[0]) / a2;
        i2.classList.add("comb");
        i2.style.letterSpacing = `calc(${t3}px * var(--total-scale-factor) - 1ch)`;
      }
    } else {
      i2 = document.createElement("div");
      i2.textContent = this.data.fieldValue;
      i2.style.verticalAlign = "middle";
      i2.style.display = "table-cell";
      this.data.hasOwnCanvas && (i2.hidden = true);
    }
    this._setTextStyle(i2);
    this._setBackgroundColor(i2);
    this._setDefaultPropertiesFromJS(i2);
    this.container.append(i2);
    return this.container;
  }
};
var SignatureWidgetAnnotationElement = class extends WidgetAnnotationElement {
  constructor(t2) {
    super(t2, { isRenderable: !!t2.data.hasOwnCanvas });
  }
};
var CheckboxWidgetAnnotationElement = class extends WidgetAnnotationElement {
  constructor(t2) {
    super(t2, { isRenderable: t2.renderForms });
  }
  render() {
    const t2 = this.annotationStorage, e2 = this.data, i2 = e2.id;
    let s2 = t2.getValue(i2, { value: e2.exportValue === e2.fieldValue }).value;
    if ("string" == typeof s2) {
      s2 = "Off" !== s2;
      t2.setValue(i2, { value: s2 });
    }
    this.container.classList.add("buttonWidgetAnnotation", "checkBox");
    const n2 = document.createElement("input");
    Et.add(n2);
    n2.setAttribute("data-element-id", i2);
    n2.disabled = e2.readOnly;
    this._setRequired(n2, this.data.required);
    n2.type = "checkbox";
    n2.name = e2.fieldName;
    s2 && n2.setAttribute("checked", true);
    n2.setAttribute("exportValue", e2.exportValue);
    n2.tabIndex = xt;
    n2.addEventListener("change", (s3) => {
      const { name: n3, checked: a2 } = s3.target;
      for (const s4 of this._getElementsByName(n3, i2)) {
        const i3 = a2 && s4.exportValue === e2.exportValue;
        s4.domElement && (s4.domElement.checked = i3);
        t2.setValue(s4.id, { value: i3 });
      }
      t2.setValue(i2, { value: a2 });
    });
    n2.addEventListener("resetform", (t3) => {
      const i3 = e2.defaultFieldValue || "Off";
      t3.target.checked = i3 === e2.exportValue;
    });
    if (this.enableScripting && this.hasJSActions) {
      n2.addEventListener("updatefromsandbox", (e3) => {
        const s3 = { value(e4) {
          e4.target.checked = "Off" !== e4.detail.value;
          t2.setValue(i2, { value: e4.target.checked });
        } };
        this._dispatchEventFromSandbox(s3, e3);
      });
      this._setEventListeners(n2, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (t3) => t3.target.checked);
    }
    this._setBackgroundColor(n2);
    this._setDefaultPropertiesFromJS(n2);
    this.container.append(n2);
    return this.container;
  }
};
var RadioButtonWidgetAnnotationElement = class extends WidgetAnnotationElement {
  constructor(t2) {
    super(t2, { isRenderable: t2.renderForms });
  }
  render() {
    this.container.classList.add("buttonWidgetAnnotation", "radioButton");
    const t2 = this.annotationStorage, e2 = this.data, i2 = e2.id;
    let s2 = t2.getValue(i2, { value: e2.fieldValue === e2.buttonValue }).value;
    if ("string" == typeof s2) {
      s2 = s2 !== e2.buttonValue;
      t2.setValue(i2, { value: s2 });
    }
    if (s2) for (const s3 of this._getElementsByName(e2.fieldName, i2)) t2.setValue(s3.id, { value: false });
    const n2 = document.createElement("input");
    Et.add(n2);
    n2.setAttribute("data-element-id", i2);
    n2.disabled = e2.readOnly;
    this._setRequired(n2, this.data.required);
    n2.type = "radio";
    n2.name = e2.fieldName;
    s2 && n2.setAttribute("checked", true);
    n2.tabIndex = xt;
    n2.addEventListener("change", (e3) => {
      const { name: s3, checked: n3 } = e3.target;
      for (const e4 of this._getElementsByName(s3, i2)) t2.setValue(e4.id, { value: false });
      t2.setValue(i2, { value: n3 });
    });
    n2.addEventListener("resetform", (t3) => {
      const i3 = e2.defaultFieldValue;
      t3.target.checked = null != i3 && i3 === e2.buttonValue;
    });
    if (this.enableScripting && this.hasJSActions) {
      const s3 = e2.buttonValue;
      n2.addEventListener("updatefromsandbox", (e3) => {
        const n3 = { value: (e4) => {
          const n4 = s3 === e4.detail.value;
          for (const s4 of this._getElementsByName(e4.target.name)) {
            const e5 = n4 && s4.id === i2;
            s4.domElement && (s4.domElement.checked = e5);
            t2.setValue(s4.id, { value: e5 });
          }
        } };
        this._dispatchEventFromSandbox(n3, e3);
      });
      this._setEventListeners(n2, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (t3) => t3.target.checked);
    }
    this._setBackgroundColor(n2);
    this._setDefaultPropertiesFromJS(n2);
    this.container.append(n2);
    return this.container;
  }
};
var PushButtonWidgetAnnotationElement = class extends LinkAnnotationElement {
  constructor(t2) {
    super(t2, { ignoreBorder: t2.data.hasAppearance });
  }
  render() {
    const t2 = super.render();
    t2.classList.add("buttonWidgetAnnotation", "pushButton");
    const e2 = t2.lastChild;
    if (this.enableScripting && this.hasJSActions && e2) {
      this._setDefaultPropertiesFromJS(e2);
      e2.addEventListener("updatefromsandbox", (t3) => {
        this._dispatchEventFromSandbox({}, t3);
      });
    }
    return t2;
  }
};
var ChoiceWidgetAnnotationElement = class extends WidgetAnnotationElement {
  constructor(t2) {
    super(t2, { isRenderable: t2.renderForms });
  }
  render() {
    this.container.classList.add("choiceWidgetAnnotation");
    const t2 = this.annotationStorage, e2 = this.data.id, i2 = t2.getValue(e2, { value: this.data.fieldValue }), s2 = document.createElement("select");
    Et.add(s2);
    s2.setAttribute("data-element-id", e2);
    s2.disabled = this.data.readOnly;
    this._setRequired(s2, this.data.required);
    s2.name = this.data.fieldName;
    s2.tabIndex = xt;
    let n2 = this.data.combo && this.data.options.length > 0;
    if (!this.data.combo) {
      s2.size = this.data.options.length;
      this.data.multiSelect && (s2.multiple = true);
    }
    s2.addEventListener("resetform", (t3) => {
      const e3 = this.data.defaultFieldValue;
      for (const t4 of s2.options) t4.selected = t4.value === e3;
    });
    for (const t3 of this.data.options) {
      const e3 = document.createElement("option");
      e3.textContent = t3.displayValue;
      e3.value = t3.exportValue;
      if (i2.value.includes(t3.exportValue)) {
        e3.setAttribute("selected", true);
        n2 = false;
      }
      s2.append(e3);
    }
    let a2 = null;
    if (n2) {
      const t3 = document.createElement("option");
      t3.value = " ";
      t3.setAttribute("hidden", true);
      t3.setAttribute("selected", true);
      s2.prepend(t3);
      a2 = () => {
        t3.remove();
        s2.removeEventListener("input", a2);
        a2 = null;
      };
      s2.addEventListener("input", a2);
    }
    const getValue = (t3) => {
      const e3 = t3 ? "value" : "textContent", { options: i3, multiple: n3 } = s2;
      return n3 ? Array.prototype.filter.call(i3, (t4) => t4.selected).map((t4) => t4[e3]) : -1 === i3.selectedIndex ? null : i3[i3.selectedIndex][e3];
    };
    let r2 = getValue(false);
    const getItems = (t3) => {
      const e3 = t3.target.options;
      return Array.prototype.map.call(e3, (t4) => ({ displayValue: t4.textContent, exportValue: t4.value }));
    };
    if (this.enableScripting && this.hasJSActions) {
      s2.addEventListener("updatefromsandbox", (i3) => {
        const n3 = { value(i4) {
          a2 == null ? void 0 : a2();
          const n4 = i4.detail.value, o2 = new Set(Array.isArray(n4) ? n4 : [n4]);
          for (const t3 of s2.options) t3.selected = o2.has(t3.value);
          t2.setValue(e2, { value: getValue(true) });
          r2 = getValue(false);
        }, multipleSelection(t3) {
          s2.multiple = true;
        }, remove(i4) {
          const n4 = s2.options, a3 = i4.detail.remove;
          n4[a3].selected = false;
          s2.remove(a3);
          if (n4.length > 0) {
            -1 === Array.prototype.findIndex.call(n4, (t3) => t3.selected) && (n4[0].selected = true);
          }
          t2.setValue(e2, { value: getValue(true), items: getItems(i4) });
          r2 = getValue(false);
        }, clear(i4) {
          for (; 0 !== s2.length; ) s2.remove(0);
          t2.setValue(e2, { value: null, items: [] });
          r2 = getValue(false);
        }, insert(i4) {
          const { index: n4, displayValue: a3, exportValue: o2 } = i4.detail.insert, l2 = s2.children[n4], h2 = document.createElement("option");
          h2.textContent = a3;
          h2.value = o2;
          l2 ? l2.before(h2) : s2.append(h2);
          t2.setValue(e2, { value: getValue(true), items: getItems(i4) });
          r2 = getValue(false);
        }, items(i4) {
          const { items: n4 } = i4.detail;
          for (; 0 !== s2.length; ) s2.remove(0);
          for (const t3 of n4) {
            const { displayValue: e3, exportValue: i5 } = t3, n5 = document.createElement("option");
            n5.textContent = e3;
            n5.value = i5;
            s2.append(n5);
          }
          s2.options.length > 0 && (s2.options[0].selected = true);
          t2.setValue(e2, { value: getValue(true), items: getItems(i4) });
          r2 = getValue(false);
        }, indices(i4) {
          const s3 = new Set(i4.detail.indices);
          for (const t3 of i4.target.options) t3.selected = s3.has(t3.index);
          t2.setValue(e2, { value: getValue(true) });
          r2 = getValue(false);
        }, editable(t3) {
          t3.target.disabled = !t3.detail.editable;
        } };
        this._dispatchEventFromSandbox(n3, i3);
      });
      s2.addEventListener("input", (i3) => {
        var _a5;
        const s3 = getValue(true), n3 = getValue(false);
        t2.setValue(e2, { value: s3 });
        i3.preventDefault();
        (_a5 = this.linkService.eventBus) == null ? void 0 : _a5.dispatch("dispatcheventinsandbox", { source: this, detail: { id: e2, name: "Keystroke", value: r2, change: n3, changeEx: s3, willCommit: false, commitKey: 1, keyDown: false } });
      });
      this._setEventListeners(s2, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (t3) => t3.target.value);
    } else s2.addEventListener("input", function(i3) {
      t2.setValue(e2, { value: getValue(true) });
    });
    this.data.combo && this._setTextStyle(s2);
    this._setBackgroundColor(s2);
    this._setDefaultPropertiesFromJS(s2);
    this.container.append(s2);
    return this.container;
  }
};
var PopupAnnotationElement = class extends AnnotationElement {
  constructor(t2) {
    const { data: e2, elements: i2 } = t2;
    super(t2, { isRenderable: AnnotationElement._hasPopupData(e2) });
    this.elements = i2;
    this.popup = null;
  }
  render() {
    this.container.classList.add("popupAnnotation");
    const t2 = this.popup = new PopupElement({ container: this.container, color: this.data.color, titleObj: this.data.titleObj, modificationDate: this.data.modificationDate, contentsObj: this.data.contentsObj, richText: this.data.richText, rect: this.data.rect, parentRect: this.data.parentRect || null, parent: this.parent, elements: this.elements, open: this.data.open }), e2 = [];
    for (const i2 of this.elements) {
      i2.popup = t2;
      i2.container.ariaHasPopup = "dialog";
      e2.push(i2.data.id);
      i2.addHighlightArea();
    }
    this.container.setAttribute("aria-controls", e2.map((t3) => `${U}${t3}`).join(","));
    return this.container;
  }
};
var _sn, _an, _on, _hn, _cn, _mt4, _un, _pn, _gn, _fn, _mn, _bn, _An, _T2, _wn, _yn, _vn, _Ys2, _xn, _PopupElement_instances, En_get, _n_get, Sn_get, Cn_fn, nn_fn, Tn_fn, dn_fn, ln_fn, rn_fn;
var PopupElement = class {
  constructor({ container: t2, color: e2, elements: i2, titleObj: s2, modificationDate: n2, contentsObj: a2, richText: r2, parent: o2, rect: l2, parentRect: h2, open: d2 }) {
    __privateAdd(this, _PopupElement_instances);
    __privateAdd(this, _sn, __privateMethod(this, _PopupElement_instances, nn_fn).bind(this));
    __privateAdd(this, _an, __privateMethod(this, _PopupElement_instances, rn_fn).bind(this));
    __privateAdd(this, _on, __privateMethod(this, _PopupElement_instances, ln_fn).bind(this));
    __privateAdd(this, _hn, __privateMethod(this, _PopupElement_instances, dn_fn).bind(this));
    __privateAdd(this, _cn, null);
    __privateAdd(this, _mt4, null);
    __privateAdd(this, _un, null);
    __privateAdd(this, _pn, null);
    __privateAdd(this, _gn, null);
    __privateAdd(this, _fn, null);
    __privateAdd(this, _mn, null);
    __privateAdd(this, _bn, false);
    __privateAdd(this, _An, null);
    __privateAdd(this, _T2, null);
    __privateAdd(this, _wn, null);
    __privateAdd(this, _yn, null);
    __privateAdd(this, _vn, null);
    __privateAdd(this, _Ys2, null);
    __privateAdd(this, _xn, false);
    var _a5;
    __privateSet(this, _mt4, t2);
    __privateSet(this, _vn, s2);
    __privateSet(this, _un, a2);
    __privateSet(this, _yn, r2);
    __privateSet(this, _fn, o2);
    __privateSet(this, _cn, e2);
    __privateSet(this, _wn, l2);
    __privateSet(this, _mn, h2);
    __privateSet(this, _gn, i2);
    __privateSet(this, _pn, PDFDateString.toDateObject(n2));
    this.trigger = i2.flatMap((t3) => t3.getElementsToTriggerPopup());
    for (const t3 of this.trigger) {
      t3.addEventListener("click", __privateGet(this, _hn));
      t3.addEventListener("mouseenter", __privateGet(this, _on));
      t3.addEventListener("mouseleave", __privateGet(this, _an));
      t3.classList.add("popupTriggerArea");
    }
    for (const t3 of i2) (_a5 = t3.container) == null ? void 0 : _a5.addEventListener("keydown", __privateGet(this, _sn));
    __privateGet(this, _mt4).hidden = true;
    d2 && __privateMethod(this, _PopupElement_instances, dn_fn).call(this);
  }
  render() {
    if (__privateGet(this, _An)) return;
    const t2 = __privateSet(this, _An, document.createElement("div"));
    t2.className = "popup";
    if (__privateGet(this, _cn)) {
      const e3 = t2.style.outlineColor = Util.makeHexColor(...__privateGet(this, _cn));
      t2.style.backgroundColor = `color-mix(in srgb, ${e3} 30%, white)`;
    }
    const e2 = document.createElement("span");
    e2.className = "header";
    const i2 = document.createElement("h1");
    e2.append(i2);
    ({ dir: i2.dir, str: i2.textContent } = __privateGet(this, _vn));
    t2.append(e2);
    if (__privateGet(this, _pn)) {
      const t3 = document.createElement("span");
      t3.classList.add("popupDate");
      t3.setAttribute("data-l10n-id", "pdfjs-annotation-date-time-string");
      t3.setAttribute("data-l10n-args", JSON.stringify({ dateObj: __privateGet(this, _pn).valueOf() }));
      e2.append(t3);
    }
    const s2 = __privateGet(this, _PopupElement_instances, En_get);
    if (s2) {
      XfaLayer.render({ xfaHtml: s2, intent: "richText", div: t2 });
      t2.lastChild.classList.add("richText", "popupContent");
    } else {
      const e3 = this._formatContents(__privateGet(this, _un));
      t2.append(e3);
    }
    __privateGet(this, _mt4).append(t2);
  }
  _formatContents({ str: t2, dir: e2 }) {
    const i2 = document.createElement("p");
    i2.classList.add("popupContent");
    i2.dir = e2;
    const s2 = t2.split(/(?:\r\n?|\n)/);
    for (let t3 = 0, e3 = s2.length; t3 < e3; ++t3) {
      const n2 = s2[t3];
      i2.append(document.createTextNode(n2));
      t3 < e3 - 1 && i2.append(document.createElement("br"));
    }
    return i2;
  }
  updateEdited({ rect: t2, popupContent: e2 }) {
    var _a5;
    __privateGet(this, _Ys2) || __privateSet(this, _Ys2, { contentsObj: __privateGet(this, _un), richText: __privateGet(this, _yn) });
    t2 && __privateSet(this, _T2, null);
    if (e2) {
      __privateSet(this, _yn, __privateMethod(this, _PopupElement_instances, Cn_fn).call(this, e2));
      __privateSet(this, _un, null);
    }
    (_a5 = __privateGet(this, _An)) == null ? void 0 : _a5.remove();
    __privateSet(this, _An, null);
  }
  resetEdited() {
    var _a5;
    if (__privateGet(this, _Ys2)) {
      ({ contentsObj: __privateWrapper(this, _un)._, richText: __privateWrapper(this, _yn)._ } = __privateGet(this, _Ys2));
      __privateSet(this, _Ys2, null);
      (_a5 = __privateGet(this, _An)) == null ? void 0 : _a5.remove();
      __privateSet(this, _An, null);
      __privateSet(this, _T2, null);
    }
  }
  forceHide() {
    __privateSet(this, _xn, this.isVisible);
    __privateGet(this, _xn) && (__privateGet(this, _mt4).hidden = true);
  }
  maybeShow() {
    if (__privateGet(this, _xn)) {
      __privateGet(this, _An) || __privateMethod(this, _PopupElement_instances, ln_fn).call(this);
      __privateSet(this, _xn, false);
      __privateGet(this, _mt4).hidden = false;
    }
  }
  get isVisible() {
    return false === __privateGet(this, _mt4).hidden;
  }
};
_sn = new WeakMap();
_an = new WeakMap();
_on = new WeakMap();
_hn = new WeakMap();
_cn = new WeakMap();
_mt4 = new WeakMap();
_un = new WeakMap();
_pn = new WeakMap();
_gn = new WeakMap();
_fn = new WeakMap();
_mn = new WeakMap();
_bn = new WeakMap();
_An = new WeakMap();
_T2 = new WeakMap();
_wn = new WeakMap();
_yn = new WeakMap();
_vn = new WeakMap();
_Ys2 = new WeakMap();
_xn = new WeakMap();
_PopupElement_instances = new WeakSet();
En_get = function() {
  const t2 = __privateGet(this, _yn), e2 = __privateGet(this, _un);
  return !(t2 == null ? void 0 : t2.str) || (e2 == null ? void 0 : e2.str) && e2.str !== t2.str ? null : __privateGet(this, _yn).html || null;
};
_n_get = function() {
  var _a5, _b, _c;
  return ((_c = (_b = (_a5 = __privateGet(this, _PopupElement_instances, En_get)) == null ? void 0 : _a5.attributes) == null ? void 0 : _b.style) == null ? void 0 : _c.fontSize) || 0;
};
Sn_get = function() {
  var _a5, _b, _c;
  return ((_c = (_b = (_a5 = __privateGet(this, _PopupElement_instances, En_get)) == null ? void 0 : _a5.attributes) == null ? void 0 : _b.style) == null ? void 0 : _c.color) || null;
};
Cn_fn = function(t2) {
  const e2 = [], i2 = { str: t2, html: { name: "div", attributes: { dir: "auto" }, children: [{ name: "p", children: e2 }] } }, s2 = { style: { color: __privateGet(this, _PopupElement_instances, Sn_get), fontSize: __privateGet(this, _PopupElement_instances, _n_get) ? `calc(${__privateGet(this, _PopupElement_instances, _n_get)}px * var(--total-scale-factor))` : "" } };
  for (const i3 of t2.split("\n")) e2.push({ name: "span", value: i3, attributes: s2 });
  return i2;
};
nn_fn = function(t2) {
  t2.altKey || t2.shiftKey || t2.ctrlKey || t2.metaKey || ("Enter" === t2.key || "Escape" === t2.key && __privateGet(this, _bn)) && __privateMethod(this, _PopupElement_instances, dn_fn).call(this);
};
Tn_fn = function() {
  if (null !== __privateGet(this, _T2)) return;
  const { page: { view: t2 }, viewport: { rawDims: { pageWidth: e2, pageHeight: i2, pageX: s2, pageY: n2 } } } = __privateGet(this, _fn);
  let a2 = !!__privateGet(this, _mn), r2 = a2 ? __privateGet(this, _mn) : __privateGet(this, _wn);
  for (const t3 of __privateGet(this, _gn)) if (!r2 || null !== Util.intersect(t3.data.rect, r2)) {
    r2 = t3.data.rect;
    a2 = true;
    break;
  }
  const o2 = Util.normalizeRect([r2[0], t2[3] - r2[1] + t2[1], r2[2], t2[3] - r2[3] + t2[1]]), l2 = a2 ? r2[2] - r2[0] + 5 : 0, h2 = o2[0] + l2, d2 = o2[1];
  __privateSet(this, _T2, [100 * (h2 - s2) / e2, 100 * (d2 - n2) / i2]);
  const { style: c2 } = __privateGet(this, _mt4);
  c2.left = `${__privateGet(this, _T2)[0]}%`;
  c2.top = `${__privateGet(this, _T2)[1]}%`;
};
dn_fn = function() {
  __privateSet(this, _bn, !__privateGet(this, _bn));
  if (__privateGet(this, _bn)) {
    __privateMethod(this, _PopupElement_instances, ln_fn).call(this);
    __privateGet(this, _mt4).addEventListener("click", __privateGet(this, _hn));
    __privateGet(this, _mt4).addEventListener("keydown", __privateGet(this, _sn));
  } else {
    __privateMethod(this, _PopupElement_instances, rn_fn).call(this);
    __privateGet(this, _mt4).removeEventListener("click", __privateGet(this, _hn));
    __privateGet(this, _mt4).removeEventListener("keydown", __privateGet(this, _sn));
  }
};
ln_fn = function() {
  __privateGet(this, _An) || this.render();
  if (this.isVisible) __privateGet(this, _bn) && __privateGet(this, _mt4).classList.add("focused");
  else {
    __privateMethod(this, _PopupElement_instances, Tn_fn).call(this);
    __privateGet(this, _mt4).hidden = false;
    __privateGet(this, _mt4).style.zIndex = parseInt(__privateGet(this, _mt4).style.zIndex) + 1e3;
  }
};
rn_fn = function() {
  __privateGet(this, _mt4).classList.remove("focused");
  if (!__privateGet(this, _bn) && this.isVisible) {
    __privateGet(this, _mt4).hidden = true;
    __privateGet(this, _mt4).style.zIndex = parseInt(__privateGet(this, _mt4).style.zIndex) - 1e3;
  }
};
var FreeTextAnnotationElement = class extends AnnotationElement {
  constructor(t2) {
    super(t2, { isRenderable: true, ignoreBorder: true });
    this.textContent = t2.data.textContent;
    this.textPosition = t2.data.textPosition;
    this.annotationEditorType = u.FREETEXT;
  }
  render() {
    this.container.classList.add("freeTextAnnotation");
    if (this.textContent) {
      const t2 = document.createElement("div");
      t2.classList.add("annotationTextContent");
      t2.setAttribute("role", "comment");
      for (const e2 of this.textContent) {
        const i2 = document.createElement("span");
        i2.textContent = e2;
        t2.append(i2);
      }
      this.container.append(t2);
    }
    !this.data.popupRef && this.hasPopupData && this._createPopup();
    this._editOnDoubleClick();
    return this.container;
  }
};
var _Mn;
var LineAnnotationElement = class extends AnnotationElement {
  constructor(t2) {
    super(t2, { isRenderable: true, ignoreBorder: true });
    __privateAdd(this, _Mn, null);
  }
  render() {
    this.container.classList.add("lineAnnotation");
    const { data: t2, width: e2, height: i2 } = this, s2 = this.svgFactory.create(e2, i2, true), n2 = __privateSet(this, _Mn, this.svgFactory.createElement("svg:line"));
    n2.setAttribute("x1", t2.rect[2] - t2.lineCoordinates[0]);
    n2.setAttribute("y1", t2.rect[3] - t2.lineCoordinates[1]);
    n2.setAttribute("x2", t2.rect[2] - t2.lineCoordinates[2]);
    n2.setAttribute("y2", t2.rect[3] - t2.lineCoordinates[3]);
    n2.setAttribute("stroke-width", t2.borderStyle.width || 1);
    n2.setAttribute("stroke", "transparent");
    n2.setAttribute("fill", "transparent");
    s2.append(n2);
    this.container.append(s2);
    !t2.popupRef && this.hasPopupData && this._createPopup();
    return this.container;
  }
  getElementsToTriggerPopup() {
    return __privateGet(this, _Mn);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
_Mn = new WeakMap();
var _Dn;
var SquareAnnotationElement = class extends AnnotationElement {
  constructor(t2) {
    super(t2, { isRenderable: true, ignoreBorder: true });
    __privateAdd(this, _Dn, null);
  }
  render() {
    this.container.classList.add("squareAnnotation");
    const { data: t2, width: e2, height: i2 } = this, s2 = this.svgFactory.create(e2, i2, true), n2 = t2.borderStyle.width, a2 = __privateSet(this, _Dn, this.svgFactory.createElement("svg:rect"));
    a2.setAttribute("x", n2 / 2);
    a2.setAttribute("y", n2 / 2);
    a2.setAttribute("width", e2 - n2);
    a2.setAttribute("height", i2 - n2);
    a2.setAttribute("stroke-width", n2 || 1);
    a2.setAttribute("stroke", "transparent");
    a2.setAttribute("fill", "transparent");
    s2.append(a2);
    this.container.append(s2);
    !t2.popupRef && this.hasPopupData && this._createPopup();
    return this.container;
  }
  getElementsToTriggerPopup() {
    return __privateGet(this, _Dn);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
_Dn = new WeakMap();
var _Pn;
var CircleAnnotationElement = class extends AnnotationElement {
  constructor(t2) {
    super(t2, { isRenderable: true, ignoreBorder: true });
    __privateAdd(this, _Pn, null);
  }
  render() {
    this.container.classList.add("circleAnnotation");
    const { data: t2, width: e2, height: i2 } = this, s2 = this.svgFactory.create(e2, i2, true), n2 = t2.borderStyle.width, a2 = __privateSet(this, _Pn, this.svgFactory.createElement("svg:ellipse"));
    a2.setAttribute("cx", e2 / 2);
    a2.setAttribute("cy", i2 / 2);
    a2.setAttribute("rx", e2 / 2 - n2 / 2);
    a2.setAttribute("ry", i2 / 2 - n2 / 2);
    a2.setAttribute("stroke-width", n2 || 1);
    a2.setAttribute("stroke", "transparent");
    a2.setAttribute("fill", "transparent");
    s2.append(a2);
    this.container.append(s2);
    !t2.popupRef && this.hasPopupData && this._createPopup();
    return this.container;
  }
  getElementsToTriggerPopup() {
    return __privateGet(this, _Pn);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
_Pn = new WeakMap();
var _kn;
var PolylineAnnotationElement = class extends AnnotationElement {
  constructor(t2) {
    super(t2, { isRenderable: true, ignoreBorder: true });
    __privateAdd(this, _kn, null);
    this.containerClassName = "polylineAnnotation";
    this.svgElementName = "svg:polyline";
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const { data: { rect: t2, vertices: e2, borderStyle: i2, popupRef: s2 }, width: n2, height: a2 } = this;
    if (!e2) return this.container;
    const r2 = this.svgFactory.create(n2, a2, true);
    let o2 = [];
    for (let i3 = 0, s3 = e2.length; i3 < s3; i3 += 2) {
      const s4 = e2[i3] - t2[0], n3 = t2[3] - e2[i3 + 1];
      o2.push(`${s4},${n3}`);
    }
    o2 = o2.join(" ");
    const l2 = __privateSet(this, _kn, this.svgFactory.createElement(this.svgElementName));
    l2.setAttribute("points", o2);
    l2.setAttribute("stroke-width", i2.width || 1);
    l2.setAttribute("stroke", "transparent");
    l2.setAttribute("fill", "transparent");
    r2.append(l2);
    this.container.append(r2);
    !s2 && this.hasPopupData && this._createPopup();
    return this.container;
  }
  getElementsToTriggerPopup() {
    return __privateGet(this, _kn);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
_kn = new WeakMap();
var PolygonAnnotationElement = class extends PolylineAnnotationElement {
  constructor(t2) {
    super(t2);
    this.containerClassName = "polygonAnnotation";
    this.svgElementName = "svg:polygon";
  }
};
var CaretAnnotationElement = class extends AnnotationElement {
  constructor(t2) {
    super(t2, { isRenderable: true, ignoreBorder: true });
  }
  render() {
    this.container.classList.add("caretAnnotation");
    !this.data.popupRef && this.hasPopupData && this._createPopup();
    return this.container;
  }
};
var _In, _Rn, _InkAnnotationElement_instances, Fn_fn;
var InkAnnotationElement = class extends AnnotationElement {
  constructor(t2) {
    super(t2, { isRenderable: true, ignoreBorder: true });
    __privateAdd(this, _InkAnnotationElement_instances);
    __privateAdd(this, _In, null);
    __privateAdd(this, _Rn, []);
    this.containerClassName = "inkAnnotation";
    this.svgElementName = "svg:polyline";
    this.annotationEditorType = "InkHighlight" === this.data.it ? u.HIGHLIGHT : u.INK;
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const { data: { rect: t2, rotation: e2, inkLists: i2, borderStyle: s2, popupRef: n2 } } = this, { transform: a2, width: r2, height: o2 } = __privateMethod(this, _InkAnnotationElement_instances, Fn_fn).call(this, e2, t2), l2 = this.svgFactory.create(r2, o2, true), h2 = __privateSet(this, _In, this.svgFactory.createElement("svg:g"));
    l2.append(h2);
    h2.setAttribute("stroke-width", s2.width || 1);
    h2.setAttribute("stroke-linecap", "round");
    h2.setAttribute("stroke-linejoin", "round");
    h2.setAttribute("stroke-miterlimit", 10);
    h2.setAttribute("stroke", "transparent");
    h2.setAttribute("fill", "transparent");
    h2.setAttribute("transform", a2);
    for (let t3 = 0, e3 = i2.length; t3 < e3; t3++) {
      const e4 = this.svgFactory.createElement(this.svgElementName);
      __privateGet(this, _Rn).push(e4);
      e4.setAttribute("points", i2[t3].join(","));
      h2.append(e4);
    }
    !n2 && this.hasPopupData && this._createPopup();
    this.container.append(l2);
    this._editOnDoubleClick();
    return this.container;
  }
  updateEdited(t2) {
    super.updateEdited(t2);
    const { thickness: e2, points: i2, rect: s2 } = t2, n2 = __privateGet(this, _In);
    e2 >= 0 && n2.setAttribute("stroke-width", e2 || 1);
    if (i2) for (let t3 = 0, e3 = __privateGet(this, _Rn).length; t3 < e3; t3++) __privateGet(this, _Rn)[t3].setAttribute("points", i2[t3].join(","));
    if (s2) {
      const { transform: t3, width: e3, height: i3 } = __privateMethod(this, _InkAnnotationElement_instances, Fn_fn).call(this, this.data.rotation, s2);
      n2.parentElement.setAttribute("viewBox", `0 0 ${e3} ${i3}`);
      n2.setAttribute("transform", t3);
    }
  }
  getElementsToTriggerPopup() {
    return __privateGet(this, _Rn);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
_In = new WeakMap();
_Rn = new WeakMap();
_InkAnnotationElement_instances = new WeakSet();
Fn_fn = function(t2, e2) {
  switch (t2) {
    case 90:
      return { transform: `rotate(90) translate(${-e2[0]},${e2[1]}) scale(1,-1)`, width: e2[3] - e2[1], height: e2[2] - e2[0] };
    case 180:
      return { transform: `rotate(180) translate(${-e2[2]},${e2[1]}) scale(1,-1)`, width: e2[2] - e2[0], height: e2[3] - e2[1] };
    case 270:
      return { transform: `rotate(270) translate(${-e2[2]},${e2[3]}) scale(1,-1)`, width: e2[3] - e2[1], height: e2[2] - e2[0] };
    default:
      return { transform: `translate(${-e2[0]},${e2[3]}) scale(1,-1)`, width: e2[2] - e2[0], height: e2[3] - e2[1] };
  }
};
var HighlightAnnotationElement = class extends AnnotationElement {
  constructor(t2) {
    super(t2, { isRenderable: true, ignoreBorder: true, createQuadrilaterals: true });
    this.annotationEditorType = u.HIGHLIGHT;
  }
  render() {
    !this.data.popupRef && this.hasPopupData && this._createPopup();
    this.container.classList.add("highlightAnnotation");
    this._editOnDoubleClick();
    return this.container;
  }
};
var UnderlineAnnotationElement = class extends AnnotationElement {
  constructor(t2) {
    super(t2, { isRenderable: true, ignoreBorder: true, createQuadrilaterals: true });
  }
  render() {
    !this.data.popupRef && this.hasPopupData && this._createPopup();
    this.container.classList.add("underlineAnnotation");
    return this.container;
  }
};
var SquigglyAnnotationElement = class extends AnnotationElement {
  constructor(t2) {
    super(t2, { isRenderable: true, ignoreBorder: true, createQuadrilaterals: true });
  }
  render() {
    !this.data.popupRef && this.hasPopupData && this._createPopup();
    this.container.classList.add("squigglyAnnotation");
    return this.container;
  }
};
var StrikeOutAnnotationElement = class extends AnnotationElement {
  constructor(t2) {
    super(t2, { isRenderable: true, ignoreBorder: true, createQuadrilaterals: true });
  }
  render() {
    !this.data.popupRef && this.hasPopupData && this._createPopup();
    this.container.classList.add("strikeoutAnnotation");
    return this.container;
  }
};
var StampAnnotationElement = class extends AnnotationElement {
  constructor(t2) {
    super(t2, { isRenderable: true, ignoreBorder: true });
    this.annotationEditorType = u.STAMP;
  }
  render() {
    this.container.classList.add("stampAnnotation");
    this.container.setAttribute("role", "img");
    !this.data.popupRef && this.hasPopupData && this._createPopup();
    this._editOnDoubleClick();
    return this.container;
  }
};
var _Ln, _FileAttachmentAnnotationElement_instances, On_fn;
var FileAttachmentAnnotationElement = class extends AnnotationElement {
  constructor(t2) {
    var _a5;
    super(t2, { isRenderable: true });
    __privateAdd(this, _FileAttachmentAnnotationElement_instances);
    __privateAdd(this, _Ln, null);
    const { file: e2 } = this.data;
    this.filename = e2.filename;
    this.content = e2.content;
    (_a5 = this.linkService.eventBus) == null ? void 0 : _a5.dispatch("fileattachmentannotation", { source: this, ...e2 });
  }
  render() {
    this.container.classList.add("fileAttachmentAnnotation");
    const { container: t2, data: e2 } = this;
    let i2;
    if (e2.hasAppearance || 0 === e2.fillAlpha) i2 = document.createElement("div");
    else {
      i2 = document.createElement("img");
      i2.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(e2.name) ? "paperclip" : "pushpin"}.svg`;
      e2.fillAlpha && e2.fillAlpha < 1 && (i2.style = `filter: opacity(${Math.round(100 * e2.fillAlpha)}%);`);
    }
    i2.addEventListener("dblclick", __privateMethod(this, _FileAttachmentAnnotationElement_instances, On_fn).bind(this));
    __privateSet(this, _Ln, i2);
    const { isMac: s2 } = util_FeatureTest.platform;
    t2.addEventListener("keydown", (t3) => {
      "Enter" === t3.key && (s2 ? t3.metaKey : t3.ctrlKey) && __privateMethod(this, _FileAttachmentAnnotationElement_instances, On_fn).call(this);
    });
    !e2.popupRef && this.hasPopupData ? this._createPopup() : i2.classList.add("popupTriggerArea");
    t2.append(i2);
    return t2;
  }
  getElementsToTriggerPopup() {
    return __privateGet(this, _Ln);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
_Ln = new WeakMap();
_FileAttachmentAnnotationElement_instances = new WeakSet();
On_fn = function() {
  var _a5;
  (_a5 = this.downloadManager) == null ? void 0 : _a5.openOrDownloadData(this.content, this.filename);
};
var _Nn, _Bn, _Hn, _Un, _AnnotationLayer_instances, zn_fn, Gn_fn;
var _AnnotationLayer = class _AnnotationLayer {
  constructor({ div: t2, accessibilityManager: e2, annotationCanvasMap: i2, annotationEditorUIManager: s2, page: n2, viewport: a2, structTreeLayer: r2 }) {
    __privateAdd(this, _AnnotationLayer_instances);
    __privateAdd(this, _Nn, null);
    __privateAdd(this, _Bn, null);
    __privateAdd(this, _Hn, /* @__PURE__ */ new Map());
    __privateAdd(this, _Un, null);
    this.div = t2;
    __privateSet(this, _Nn, e2);
    __privateSet(this, _Bn, i2);
    __privateSet(this, _Un, r2 || null);
    this.page = n2;
    this.viewport = a2;
    this.zIndex = 0;
    this._annotationEditorUIManager = s2;
  }
  hasEditableAnnotations() {
    return __privateGet(this, _Hn).size > 0;
  }
  async render(t2) {
    var _a5;
    const { annotations: e2 } = t2, i2 = this.div;
    setLayerDimensions(i2, this.viewport);
    const s2 = /* @__PURE__ */ new Map(), n2 = { data: null, layer: i2, linkService: t2.linkService, downloadManager: t2.downloadManager, imageResourcesPath: t2.imageResourcesPath || "", renderForms: false !== t2.renderForms, svgFactory: new DOMSVGFactory(), annotationStorage: t2.annotationStorage || new AnnotationStorage(), enableScripting: true === t2.enableScripting, hasJSActions: t2.hasJSActions, fieldObjects: t2.fieldObjects, parent: this, elements: null };
    for (const t3 of e2) {
      if (t3.noHTML) continue;
      const e3 = t3.annotationType === x.POPUP;
      if (e3) {
        const e4 = s2.get(t3.id);
        if (!e4) continue;
        n2.elements = e4;
      } else if (t3.rect[2] === t3.rect[0] || t3.rect[3] === t3.rect[1]) continue;
      n2.data = t3;
      const i3 = AnnotationElementFactory.create(n2);
      if (!i3.isRenderable) continue;
      if (!e3 && t3.popupRef) {
        const e4 = s2.get(t3.popupRef);
        e4 ? e4.push(i3) : s2.set(t3.popupRef, [i3]);
      }
      const a2 = i3.render();
      t3.hidden && (a2.style.visibility = "hidden");
      await __privateMethod(this, _AnnotationLayer_instances, zn_fn).call(this, a2, t3.id);
      if (i3._isEditable) {
        __privateGet(this, _Hn).set(i3.data.id, i3);
        (_a5 = this._annotationEditorUIManager) == null ? void 0 : _a5.renderAnnotationElement(i3);
      }
    }
    __privateMethod(this, _AnnotationLayer_instances, Gn_fn).call(this);
  }
  async addLinkAnnotations(t2, e2) {
    const i2 = { data: null, layer: this.div, linkService: e2, svgFactory: new DOMSVGFactory(), parent: this };
    for (const e3 of t2) {
      e3.borderStyle || (e3.borderStyle = _AnnotationLayer._defaultBorderStyle);
      i2.data = e3;
      const t3 = AnnotationElementFactory.create(i2);
      if (!t3.isRenderable) continue;
      const s2 = t3.render();
      await __privateMethod(this, _AnnotationLayer_instances, zn_fn).call(this, s2, e3.id);
    }
  }
  update({ viewport: t2 }) {
    const e2 = this.div;
    this.viewport = t2;
    setLayerDimensions(e2, { rotation: t2.rotation });
    __privateMethod(this, _AnnotationLayer_instances, Gn_fn).call(this);
    e2.hidden = false;
  }
  getEditableAnnotations() {
    return Array.from(__privateGet(this, _Hn).values());
  }
  getEditableAnnotation(t2) {
    return __privateGet(this, _Hn).get(t2);
  }
  static get _defaultBorderStyle() {
    return shadow(this, "_defaultBorderStyle", Object.freeze({ width: 1, rawWidth: 1, style: E, dashArray: [3], horizontalCornerRadius: 0, verticalCornerRadius: 0 }));
  }
};
_Nn = new WeakMap();
_Bn = new WeakMap();
_Hn = new WeakMap();
_Un = new WeakMap();
_AnnotationLayer_instances = new WeakSet();
zn_fn = async function(t2, e2) {
  var _a5, _b;
  const i2 = t2.firstChild || t2, s2 = i2.id = `${U}${e2}`, n2 = await ((_a5 = __privateGet(this, _Un)) == null ? void 0 : _a5.getAriaAttributes(s2));
  if (n2) for (const [t3, e3] of n2) i2.setAttribute(t3, e3);
  this.div.append(t2);
  (_b = __privateGet(this, _Nn)) == null ? void 0 : _b.moveElementInDOM(this.div, t2, i2, false);
};
Gn_fn = function() {
  var _a5;
  if (!__privateGet(this, _Bn)) return;
  const t2 = this.div;
  for (const [e2, i2] of __privateGet(this, _Bn)) {
    const s2 = t2.querySelector(`[data-annotation-id="${e2}"]`);
    if (!s2) continue;
    i2.className = "annotationContent";
    const { firstChild: n2 } = s2;
    n2 ? "CANVAS" === n2.nodeName ? n2.replaceWith(i2) : n2.classList.contains("annotationContent") ? n2.after(i2) : n2.before(i2) : s2.append(i2);
    const a2 = __privateGet(this, _Hn).get(e2);
    if (a2) if (a2._hasNoCanvas) {
      (_a5 = this._annotationEditorUIManager) == null ? void 0 : _a5.setMissingCanvas(e2, s2.id, i2);
      a2._hasNoCanvas = false;
    } else a2.canvas = i2;
  }
  __privateGet(this, _Bn).clear();
};
var AnnotationLayer = _AnnotationLayer;
var _t = /\r\n?|\n/g;
var _cn2, _$n, _Wn, _Vn, __n, _FreeTextEditor_instances, jn_fn, qn_fn, Kn_fn, Xn_fn, _FreeTextEditor_static, Yn_fn, Qn_fn, Zn_fn, Jn_fn, ta_fn;
var _FreeTextEditor = class _FreeTextEditor extends AnnotationEditor {
  constructor(t2) {
    super({ ...t2, name: "freeTextEditor" });
    __privateAdd(this, _FreeTextEditor_instances);
    __privateAdd(this, _cn2);
    __privateAdd(this, _$n, "");
    __privateAdd(this, _Wn, `${this.id}-editor`);
    __privateAdd(this, _Vn, null);
    __privateAdd(this, __n);
    __privateSet(this, _cn2, t2.color || _FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor);
    __privateSet(this, __n, t2.fontSize || _FreeTextEditor._defaultFontSize);
  }
  static get _keyboardManager() {
    const t2 = _FreeTextEditor.prototype, arrowChecker = (t3) => t3.isEmpty(), e2 = AnnotationEditorUIManager.TRANSLATE_SMALL, i2 = AnnotationEditorUIManager.TRANSLATE_BIG;
    return shadow(this, "_keyboardManager", new KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], t2.commitOrRemove, { bubbles: true }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], t2.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], t2._translateEmpty, { args: [-e2, 0], checker: arrowChecker }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], t2._translateEmpty, { args: [-i2, 0], checker: arrowChecker }], [["ArrowRight", "mac+ArrowRight"], t2._translateEmpty, { args: [e2, 0], checker: arrowChecker }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], t2._translateEmpty, { args: [i2, 0], checker: arrowChecker }], [["ArrowUp", "mac+ArrowUp"], t2._translateEmpty, { args: [0, -e2], checker: arrowChecker }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], t2._translateEmpty, { args: [0, -i2], checker: arrowChecker }], [["ArrowDown", "mac+ArrowDown"], t2._translateEmpty, { args: [0, e2], checker: arrowChecker }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], t2._translateEmpty, { args: [0, i2], checker: arrowChecker }]]));
  }
  static initialize(t2, e2) {
    AnnotationEditor.initialize(t2, e2);
    const i2 = getComputedStyle(document.documentElement);
    this._internalPadding = parseFloat(i2.getPropertyValue("--freetext-padding"));
  }
  static updateDefaultParams(t2, e2) {
    switch (t2) {
      case p.FREETEXT_SIZE:
        _FreeTextEditor._defaultFontSize = e2;
        break;
      case p.FREETEXT_COLOR:
        _FreeTextEditor._defaultColor = e2;
    }
  }
  updateParams(t2, e2) {
    switch (t2) {
      case p.FREETEXT_SIZE:
        __privateMethod(this, _FreeTextEditor_instances, jn_fn).call(this, e2);
        break;
      case p.FREETEXT_COLOR:
        __privateMethod(this, _FreeTextEditor_instances, qn_fn).call(this, e2);
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[p.FREETEXT_SIZE, _FreeTextEditor._defaultFontSize], [p.FREETEXT_COLOR, _FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor]];
  }
  get propertiesToUpdate() {
    return [[p.FREETEXT_SIZE, __privateGet(this, __n)], [p.FREETEXT_COLOR, __privateGet(this, _cn2)]];
  }
  _translateEmpty(t2, e2) {
    this._uiManager.translateSelectedEditors(t2, e2, true);
  }
  getInitialTranslation() {
    const t2 = this.parentScale;
    return [-_FreeTextEditor._internalPadding * t2, -(_FreeTextEditor._internalPadding + __privateGet(this, __n)) * t2];
  }
  rebuild() {
    if (this.parent) {
      super.rebuild();
      null !== this.div && (this.isAttachedToDOM || this.parent.add(this));
    }
  }
  enableEditMode() {
    if (!super.enableEditMode()) return false;
    this.overlayDiv.classList.remove("enabled");
    this.editorDiv.contentEditable = true;
    this._isDraggable = false;
    this.div.removeAttribute("aria-activedescendant");
    __privateSet(this, _Vn, new AbortController());
    const t2 = this._uiManager.combinedSignal(__privateGet(this, _Vn));
    this.editorDiv.addEventListener("keydown", this.editorDivKeydown.bind(this), { signal: t2 });
    this.editorDiv.addEventListener("focus", this.editorDivFocus.bind(this), { signal: t2 });
    this.editorDiv.addEventListener("blur", this.editorDivBlur.bind(this), { signal: t2 });
    this.editorDiv.addEventListener("input", this.editorDivInput.bind(this), { signal: t2 });
    this.editorDiv.addEventListener("paste", this.editorDivPaste.bind(this), { signal: t2 });
    return true;
  }
  disableEditMode() {
    var _a5;
    if (!super.disableEditMode()) return false;
    this.overlayDiv.classList.add("enabled");
    this.editorDiv.contentEditable = false;
    this.div.setAttribute("aria-activedescendant", __privateGet(this, _Wn));
    this._isDraggable = true;
    (_a5 = __privateGet(this, _Vn)) == null ? void 0 : _a5.abort();
    __privateSet(this, _Vn, null);
    this.div.focus({ preventScroll: true });
    this.isEditing = false;
    this.parent.div.classList.add("freetextEditing");
    return true;
  }
  focusin(t2) {
    if (this._focusEventsAllowed) {
      super.focusin(t2);
      t2.target !== this.editorDiv && this.editorDiv.focus();
    }
  }
  onceAdded(t2) {
    var _a5;
    if (!this.width) {
      this.enableEditMode();
      t2 && this.editorDiv.focus();
      ((_a5 = this._initialOptions) == null ? void 0 : _a5.isCentered) && this.center();
      this._initialOptions = null;
    }
  }
  isEmpty() {
    return !this.editorDiv || "" === this.editorDiv.innerText.trim();
  }
  remove() {
    this.isEditing = false;
    if (this.parent) {
      this.parent.setEditingState(true);
      this.parent.div.classList.add("freetextEditing");
    }
    super.remove();
  }
  commit() {
    if (!this.isInEditMode()) return;
    super.commit();
    this.disableEditMode();
    const t2 = __privateGet(this, _$n), e2 = __privateSet(this, _$n, __privateMethod(this, _FreeTextEditor_instances, Kn_fn).call(this).trimEnd());
    if (t2 === e2) return;
    const setText = (t3) => {
      __privateSet(this, _$n, t3);
      if (t3) {
        __privateMethod(this, _FreeTextEditor_instances, Qn_fn).call(this);
        this._uiManager.rebuild(this);
        __privateMethod(this, _FreeTextEditor_instances, Xn_fn).call(this);
      } else this.remove();
    };
    this.addCommands({ cmd: () => {
      setText(e2);
    }, undo: () => {
      setText(t2);
    }, mustExec: false });
    __privateMethod(this, _FreeTextEditor_instances, Xn_fn).call(this);
  }
  shouldGetKeyboardEvents() {
    return this.isInEditMode();
  }
  enterInEditMode() {
    this.enableEditMode();
    this.editorDiv.focus();
  }
  keydown(t2) {
    if (t2.target === this.div && "Enter" === t2.key) {
      this.enterInEditMode();
      t2.preventDefault();
    }
  }
  editorDivKeydown(t2) {
    _FreeTextEditor._keyboardManager.exec(this, t2);
  }
  editorDivFocus(t2) {
    this.isEditing = true;
  }
  editorDivBlur(t2) {
    this.isEditing = false;
  }
  editorDivInput(t2) {
    this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
  }
  disableEditing() {
    this.editorDiv.setAttribute("role", "comment");
    this.editorDiv.removeAttribute("aria-multiline");
  }
  enableEditing() {
    this.editorDiv.setAttribute("role", "textbox");
    this.editorDiv.setAttribute("aria-multiline", true);
  }
  get canChangeContent() {
    return true;
  }
  render() {
    if (this.div) return this.div;
    let t2, e2;
    if (this._isCopy || this.annotationElementId) {
      t2 = this.x;
      e2 = this.y;
    }
    super.render();
    this.editorDiv = document.createElement("div");
    this.editorDiv.className = "internal";
    this.editorDiv.setAttribute("id", __privateGet(this, _Wn));
    this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text2");
    this.editorDiv.setAttribute("data-l10n-attrs", "default-content");
    this.enableEditing();
    this.editorDiv.contentEditable = true;
    const { style: i2 } = this.editorDiv;
    i2.fontSize = `calc(${__privateGet(this, __n)}px * var(--total-scale-factor))`;
    i2.color = __privateGet(this, _cn2);
    this.div.append(this.editorDiv);
    this.overlayDiv = document.createElement("div");
    this.overlayDiv.classList.add("overlay", "enabled");
    this.div.append(this.overlayDiv);
    if (this._isCopy || this.annotationElementId) {
      const [i3, s2] = this.parentDimensions;
      if (this.annotationElementId) {
        const { position: n2 } = this._initialData;
        let [a2, r2] = this.getInitialTranslation();
        [a2, r2] = this.pageTranslationToScreen(a2, r2);
        const [o2, l2] = this.pageDimensions, [h2, d2] = this.pageTranslation;
        let c2, u2;
        switch (this.rotation) {
          case 0:
            c2 = t2 + (n2[0] - h2) / o2;
            u2 = e2 + this.height - (n2[1] - d2) / l2;
            break;
          case 90:
            c2 = t2 + (n2[0] - h2) / o2;
            u2 = e2 - (n2[1] - d2) / l2;
            [a2, r2] = [r2, -a2];
            break;
          case 180:
            c2 = t2 - this.width + (n2[0] - h2) / o2;
            u2 = e2 - (n2[1] - d2) / l2;
            [a2, r2] = [-a2, -r2];
            break;
          case 270:
            c2 = t2 + (n2[0] - h2 - this.height * l2) / o2;
            u2 = e2 + (n2[1] - d2 - this.width * o2) / l2;
            [a2, r2] = [-r2, a2];
        }
        this.setAt(c2 * i3, u2 * s2, a2, r2);
      } else this._moveAfterPaste(t2, e2);
      __privateMethod(this, _FreeTextEditor_instances, Qn_fn).call(this);
      this._isDraggable = true;
      this.editorDiv.contentEditable = false;
    } else {
      this._isDraggable = false;
      this.editorDiv.contentEditable = true;
    }
    return this.div;
  }
  editorDivPaste(t2) {
    var _a5, _b, _c;
    const e2 = t2.clipboardData || window.clipboardData, { types: i2 } = e2;
    if (1 === i2.length && "text/plain" === i2[0]) return;
    t2.preventDefault();
    const s2 = __privateMethod(_a5 = _FreeTextEditor, _FreeTextEditor_static, Jn_fn).call(_a5, e2.getData("text") || "").replaceAll(_t, "\n");
    if (!s2) return;
    const n2 = window.getSelection();
    if (!n2.rangeCount) return;
    this.editorDiv.normalize();
    n2.deleteFromDocument();
    const a2 = n2.getRangeAt(0);
    if (!s2.includes("\n")) {
      a2.insertNode(document.createTextNode(s2));
      this.editorDiv.normalize();
      n2.collapseToStart();
      return;
    }
    const { startContainer: r2, startOffset: o2 } = a2, l2 = [], h2 = [];
    if (r2.nodeType === Node.TEXT_NODE) {
      const t3 = r2.parentElement;
      h2.push(r2.nodeValue.slice(o2).replaceAll(_t, ""));
      if (t3 !== this.editorDiv) {
        let e3 = l2;
        for (const i3 of this.editorDiv.childNodes) i3 !== t3 ? e3.push(__privateMethod(_b = _FreeTextEditor, _FreeTextEditor_static, Yn_fn).call(_b, i3)) : e3 = h2;
      }
      l2.push(r2.nodeValue.slice(0, o2).replaceAll(_t, ""));
    } else if (r2 === this.editorDiv) {
      let t3 = l2, e3 = 0;
      for (const i3 of this.editorDiv.childNodes) {
        e3++ === o2 && (t3 = h2);
        t3.push(__privateMethod(_c = _FreeTextEditor, _FreeTextEditor_static, Yn_fn).call(_c, i3));
      }
    }
    __privateSet(this, _$n, `${l2.join("\n")}${s2}${h2.join("\n")}`);
    __privateMethod(this, _FreeTextEditor_instances, Qn_fn).call(this);
    const d2 = new Range();
    let c2 = Math.sumPrecise(l2.map((t3) => t3.length));
    for (const { firstChild: t3 } of this.editorDiv.childNodes) if (t3.nodeType === Node.TEXT_NODE) {
      const e3 = t3.nodeValue.length;
      if (c2 <= e3) {
        d2.setStart(t3, c2);
        d2.setEnd(t3, c2);
        break;
      }
      c2 -= e3;
    }
    n2.removeAllRanges();
    n2.addRange(d2);
  }
  get contentDiv() {
    return this.editorDiv;
  }
  static async deserialize(t2, e2, i2) {
    var _a5;
    let s2 = null;
    if (t2 instanceof FreeTextAnnotationElement) {
      const { data: { defaultAppearanceData: { fontSize: e3, fontColor: i3 }, rect: n3, rotation: a2, id: r2, popupRef: o2 }, textContent: l2, textPosition: h2, parent: { page: { pageNumber: d2 } } } = t2;
      if (!l2 || 0 === l2.length) return null;
      s2 = t2 = { annotationType: u.FREETEXT, color: Array.from(i3), fontSize: e3, value: l2.join("\n"), position: h2, pageIndex: d2 - 1, rect: n3.slice(0), rotation: a2, id: r2, deleted: false, popupRef: o2 };
    }
    const n2 = await super.deserialize(t2, e2, i2);
    __privateSet(n2, __n, t2.fontSize);
    __privateSet(n2, _cn2, Util.makeHexColor(...t2.color));
    __privateSet(n2, _$n, __privateMethod(_a5 = _FreeTextEditor, _FreeTextEditor_static, Jn_fn).call(_a5, t2.value));
    n2.annotationElementId = t2.id || null;
    n2._initialData = s2;
    return n2;
  }
  serialize(t2 = false) {
    if (this.isEmpty()) return null;
    if (this.deleted) return this.serializeDeleted();
    const e2 = _FreeTextEditor._internalPadding * this.parentScale, i2 = this.getRect(e2, e2), s2 = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : __privateGet(this, _cn2)), n2 = { annotationType: u.FREETEXT, color: s2, fontSize: __privateGet(this, __n), value: __privateMethod(this, _FreeTextEditor_instances, Zn_fn).call(this), pageIndex: this.pageIndex, rect: i2, rotation: this.rotation, structTreeParentId: this._structTreeParentId };
    if (t2) {
      n2.isCopy = true;
      return n2;
    }
    if (this.annotationElementId && !__privateMethod(this, _FreeTextEditor_instances, ta_fn).call(this, n2)) return null;
    n2.id = this.annotationElementId;
    return n2;
  }
  renderAnnotationElement(t2) {
    const e2 = super.renderAnnotationElement(t2);
    if (this.deleted) return e2;
    const { style: i2 } = e2;
    i2.fontSize = `calc(${__privateGet(this, __n)}px * var(--total-scale-factor))`;
    i2.color = __privateGet(this, _cn2);
    e2.replaceChildren();
    for (const t3 of __privateGet(this, _$n).split("\n")) {
      const i3 = document.createElement("div");
      i3.append(t3 ? document.createTextNode(t3) : document.createElement("br"));
      e2.append(i3);
    }
    const s2 = _FreeTextEditor._internalPadding * this.parentScale;
    t2.updateEdited({ rect: this.getRect(s2, s2), popupContent: __privateGet(this, _$n) });
    return e2;
  }
  resetAnnotationElement(t2) {
    super.resetAnnotationElement(t2);
    t2.resetEdited();
  }
};
_cn2 = new WeakMap();
_$n = new WeakMap();
_Wn = new WeakMap();
_Vn = new WeakMap();
__n = new WeakMap();
_FreeTextEditor_instances = new WeakSet();
jn_fn = function(t2) {
  const setFontsize = (t3) => {
    this.editorDiv.style.fontSize = `calc(${t3}px * var(--total-scale-factor))`;
    this.translate(0, -(t3 - __privateGet(this, __n)) * this.parentScale);
    __privateSet(this, __n, t3);
    __privateMethod(this, _FreeTextEditor_instances, Xn_fn).call(this);
  }, e2 = __privateGet(this, __n);
  this.addCommands({ cmd: setFontsize.bind(this, t2), undo: setFontsize.bind(this, e2), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: true, type: p.FREETEXT_SIZE, overwriteIfSameType: true, keepUndo: true });
};
qn_fn = function(t2) {
  const setColor = (t3) => {
    __privateSet(this, _cn2, this.editorDiv.style.color = t3);
  }, e2 = __privateGet(this, _cn2);
  this.addCommands({ cmd: setColor.bind(this, t2), undo: setColor.bind(this, e2), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: true, type: p.FREETEXT_COLOR, overwriteIfSameType: true, keepUndo: true });
};
Kn_fn = function() {
  var _a5;
  const t2 = [];
  this.editorDiv.normalize();
  let e2 = null;
  for (const i2 of this.editorDiv.childNodes) if ((e2 == null ? void 0 : e2.nodeType) !== Node.TEXT_NODE || "BR" !== i2.nodeName) {
    t2.push(__privateMethod(_a5 = _FreeTextEditor, _FreeTextEditor_static, Yn_fn).call(_a5, i2));
    e2 = i2;
  }
  return t2.join("\n");
};
Xn_fn = function() {
  const [t2, e2] = this.parentDimensions;
  let i2;
  if (this.isAttachedToDOM) i2 = this.div.getBoundingClientRect();
  else {
    const { currentLayer: t3, div: e3 } = this, s2 = e3.style.display, n2 = e3.classList.contains("hidden");
    e3.classList.remove("hidden");
    e3.style.display = "hidden";
    t3.div.append(this.div);
    i2 = e3.getBoundingClientRect();
    e3.remove();
    e3.style.display = s2;
    e3.classList.toggle("hidden", n2);
  }
  if (this.rotation % 180 == this.parentRotation % 180) {
    this.width = i2.width / t2;
    this.height = i2.height / e2;
  } else {
    this.width = i2.height / t2;
    this.height = i2.width / e2;
  }
  this.fixAndSetPosition();
};
_FreeTextEditor_static = new WeakSet();
Yn_fn = function(t2) {
  return (t2.nodeType === Node.TEXT_NODE ? t2.nodeValue : t2.innerText).replaceAll(_t, "");
};
Qn_fn = function() {
  this.editorDiv.replaceChildren();
  if (__privateGet(this, _$n)) for (const t2 of __privateGet(this, _$n).split("\n")) {
    const e2 = document.createElement("div");
    e2.append(t2 ? document.createTextNode(t2) : document.createElement("br"));
    this.editorDiv.append(e2);
  }
};
Zn_fn = function() {
  return __privateGet(this, _$n).replaceAll(" ", " ");
};
Jn_fn = function(t2) {
  return t2.replaceAll(" ", " ");
};
ta_fn = function(t2) {
  const { value: e2, fontSize: i2, color: s2, pageIndex: n2 } = this._initialData;
  return this._hasBeenMoved || t2.value !== e2 || t2.fontSize !== i2 || t2.color.some((t3, e3) => t3 !== s2[e3]) || t2.pageIndex !== n2;
};
__privateAdd(_FreeTextEditor, _FreeTextEditor_static);
__publicField(_FreeTextEditor, "_freeTextDefaultContent", "");
__publicField(_FreeTextEditor, "_internalPadding", 0);
__publicField(_FreeTextEditor, "_defaultColor", null);
__publicField(_FreeTextEditor, "_defaultFontSize", 10);
__publicField(_FreeTextEditor, "_type", "freetext");
__publicField(_FreeTextEditor, "_editorType", u.FREETEXT);
var FreeTextEditor = _FreeTextEditor;
var Outline = class {
  toSVGPath() {
    unreachable("Abstract method `toSVGPath` must be implemented.");
  }
  get box() {
    unreachable("Abstract getter `box` must be implemented.");
  }
  serialize(t2, e2) {
    unreachable("Abstract method `serialize` must be implemented.");
  }
  static _rescale(t2, e2, i2, s2, n2, a2) {
    a2 || (a2 = new Float32Array(t2.length));
    for (let r2 = 0, o2 = t2.length; r2 < o2; r2 += 2) {
      a2[r2] = e2 + t2[r2] * s2;
      a2[r2 + 1] = i2 + t2[r2 + 1] * n2;
    }
    return a2;
  }
  static _rescaleAndSwap(t2, e2, i2, s2, n2, a2) {
    a2 || (a2 = new Float32Array(t2.length));
    for (let r2 = 0, o2 = t2.length; r2 < o2; r2 += 2) {
      a2[r2] = e2 + t2[r2 + 1] * s2;
      a2[r2 + 1] = i2 + t2[r2] * n2;
    }
    return a2;
  }
  static _translate(t2, e2, i2, s2) {
    s2 || (s2 = new Float32Array(t2.length));
    for (let n2 = 0, a2 = t2.length; n2 < a2; n2 += 2) {
      s2[n2] = e2 + t2[n2];
      s2[n2 + 1] = i2 + t2[n2 + 1];
    }
    return s2;
  }
  static svgRound(t2) {
    return Math.round(1e4 * t2);
  }
  static _normalizePoint(t2, e2, i2, s2, n2) {
    switch (n2) {
      case 90:
        return [1 - e2 / i2, t2 / s2];
      case 180:
        return [1 - t2 / i2, 1 - e2 / s2];
      case 270:
        return [e2 / i2, 1 - t2 / s2];
      default:
        return [t2 / i2, e2 / s2];
    }
  }
  static _normalizePagePoint(t2, e2, i2) {
    switch (i2) {
      case 90:
        return [1 - e2, t2];
      case 180:
        return [1 - t2, 1 - e2];
      case 270:
        return [e2, 1 - t2];
      default:
        return [t2, e2];
    }
  }
  static createBezierPoints(t2, e2, i2, s2, n2, a2) {
    return [(t2 + 5 * i2) / 6, (e2 + 5 * s2) / 6, (5 * i2 + n2) / 6, (5 * s2 + a2) / 6, (i2 + n2) / 2, (s2 + a2) / 2];
  }
};
__publicField(Outline, "PRECISION", 1e-4);
var _ea, _ia, _sa, _na, _aa, _ra, _oa, _la, _ha, _da, _ca, _ua, _pa, _ga, _fa, _ma, _FreeDrawOutliner_instances, ba_fn, Aa_fn, ya_fn, wa_fn, va_fn, Ea_fn, xa_fn;
var _FreeDrawOutliner = class _FreeDrawOutliner {
  constructor({ x: t2, y: e2 }, i2, s2, n2, a2, r2 = 0) {
    __privateAdd(this, _FreeDrawOutliner_instances);
    __privateAdd(this, _ea);
    __privateAdd(this, _ia, []);
    __privateAdd(this, _sa);
    __privateAdd(this, _na);
    __privateAdd(this, _aa, []);
    __privateAdd(this, _ra, new Float32Array(18));
    __privateAdd(this, _oa);
    __privateAdd(this, _la);
    __privateAdd(this, _ha);
    __privateAdd(this, _da);
    __privateAdd(this, _ca);
    __privateAdd(this, _ua);
    __privateAdd(this, _pa, []);
    __privateSet(this, _ea, i2);
    __privateSet(this, _ua, n2 * s2);
    __privateSet(this, _na, a2);
    __privateGet(this, _ra).set([NaN, NaN, NaN, NaN, t2, e2], 6);
    __privateSet(this, _sa, r2);
    __privateSet(this, _da, __privateGet(_FreeDrawOutliner, _ga) * s2);
    __privateSet(this, _ha, __privateGet(_FreeDrawOutliner, _ma) * s2);
    __privateSet(this, _ca, s2);
    __privateGet(this, _pa).push(t2, e2);
  }
  isEmpty() {
    return isNaN(__privateGet(this, _ra)[8]);
  }
  add({ x: t2, y: e2 }) {
    var _a5;
    __privateSet(this, _oa, t2);
    __privateSet(this, _la, e2);
    const [i2, s2, n2, a2] = __privateGet(this, _ea);
    let [r2, o2, l2, h2] = __privateGet(this, _ra).subarray(8, 12);
    const d2 = t2 - l2, c2 = e2 - h2, u2 = Math.hypot(d2, c2);
    if (u2 < __privateGet(this, _ha)) return false;
    const p2 = u2 - __privateGet(this, _da), g2 = p2 / u2, f2 = g2 * d2, m2 = g2 * c2;
    let b2 = r2, A2 = o2;
    r2 = l2;
    o2 = h2;
    l2 += f2;
    h2 += m2;
    (_a5 = __privateGet(this, _pa)) == null ? void 0 : _a5.push(t2, e2);
    const w2 = f2 / p2, y2 = -m2 / p2 * __privateGet(this, _ua), v2 = w2 * __privateGet(this, _ua);
    __privateGet(this, _ra).set(__privateGet(this, _ra).subarray(2, 8), 0);
    __privateGet(this, _ra).set([l2 + y2, h2 + v2], 4);
    __privateGet(this, _ra).set(__privateGet(this, _ra).subarray(14, 18), 12);
    __privateGet(this, _ra).set([l2 - y2, h2 - v2], 16);
    if (isNaN(__privateGet(this, _ra)[6])) {
      if (0 === __privateGet(this, _aa).length) {
        __privateGet(this, _ra).set([r2 + y2, o2 + v2], 2);
        __privateGet(this, _aa).push(NaN, NaN, NaN, NaN, (r2 + y2 - i2) / n2, (o2 + v2 - s2) / a2);
        __privateGet(this, _ra).set([r2 - y2, o2 - v2], 14);
        __privateGet(this, _ia).push(NaN, NaN, NaN, NaN, (r2 - y2 - i2) / n2, (o2 - v2 - s2) / a2);
      }
      __privateGet(this, _ra).set([b2, A2, r2, o2, l2, h2], 6);
      return !this.isEmpty();
    }
    __privateGet(this, _ra).set([b2, A2, r2, o2, l2, h2], 6);
    if (Math.abs(Math.atan2(A2 - o2, b2 - r2) - Math.atan2(m2, f2)) < Math.PI / 2) {
      [r2, o2, l2, h2] = __privateGet(this, _ra).subarray(2, 6);
      __privateGet(this, _aa).push(NaN, NaN, NaN, NaN, ((r2 + l2) / 2 - i2) / n2, ((o2 + h2) / 2 - s2) / a2);
      [r2, o2, b2, A2] = __privateGet(this, _ra).subarray(14, 18);
      __privateGet(this, _ia).push(NaN, NaN, NaN, NaN, ((b2 + r2) / 2 - i2) / n2, ((A2 + o2) / 2 - s2) / a2);
      return true;
    }
    [b2, A2, r2, o2, l2, h2] = __privateGet(this, _ra).subarray(0, 6);
    __privateGet(this, _aa).push(((b2 + 5 * r2) / 6 - i2) / n2, ((A2 + 5 * o2) / 6 - s2) / a2, ((5 * r2 + l2) / 6 - i2) / n2, ((5 * o2 + h2) / 6 - s2) / a2, ((r2 + l2) / 2 - i2) / n2, ((o2 + h2) / 2 - s2) / a2);
    [l2, h2, r2, o2, b2, A2] = __privateGet(this, _ra).subarray(12, 18);
    __privateGet(this, _ia).push(((b2 + 5 * r2) / 6 - i2) / n2, ((A2 + 5 * o2) / 6 - s2) / a2, ((5 * r2 + l2) / 6 - i2) / n2, ((5 * o2 + h2) / 6 - s2) / a2, ((r2 + l2) / 2 - i2) / n2, ((o2 + h2) / 2 - s2) / a2);
    return true;
  }
  toSVGPath() {
    if (this.isEmpty()) return "";
    const t2 = __privateGet(this, _aa), e2 = __privateGet(this, _ia);
    if (isNaN(__privateGet(this, _ra)[6]) && !this.isEmpty()) return __privateMethod(this, _FreeDrawOutliner_instances, Aa_fn).call(this);
    const i2 = [];
    i2.push(`M${t2[4]} ${t2[5]}`);
    for (let e3 = 6; e3 < t2.length; e3 += 6) isNaN(t2[e3]) ? i2.push(`L${t2[e3 + 4]} ${t2[e3 + 5]}`) : i2.push(`C${t2[e3]} ${t2[e3 + 1]} ${t2[e3 + 2]} ${t2[e3 + 3]} ${t2[e3 + 4]} ${t2[e3 + 5]}`);
    __privateMethod(this, _FreeDrawOutliner_instances, wa_fn).call(this, i2);
    for (let t3 = e2.length - 6; t3 >= 6; t3 -= 6) isNaN(e2[t3]) ? i2.push(`L${e2[t3 + 4]} ${e2[t3 + 5]}`) : i2.push(`C${e2[t3]} ${e2[t3 + 1]} ${e2[t3 + 2]} ${e2[t3 + 3]} ${e2[t3 + 4]} ${e2[t3 + 5]}`);
    __privateMethod(this, _FreeDrawOutliner_instances, ya_fn).call(this, i2);
    return i2.join(" ");
  }
  newFreeDrawOutline(t2, e2, i2, s2, n2, a2) {
    return new FreeDrawOutline(t2, e2, i2, s2, n2, a2);
  }
  getOutlines() {
    var _a5;
    const t2 = __privateGet(this, _aa), e2 = __privateGet(this, _ia), i2 = __privateGet(this, _ra), [s2, n2, a2, r2] = __privateGet(this, _ea), o2 = new Float32Array((((_a5 = __privateGet(this, _pa)) == null ? void 0 : _a5.length) ?? 0) + 2);
    for (let t3 = 0, e3 = o2.length - 2; t3 < e3; t3 += 2) {
      o2[t3] = (__privateGet(this, _pa)[t3] - s2) / a2;
      o2[t3 + 1] = (__privateGet(this, _pa)[t3 + 1] - n2) / r2;
    }
    o2[o2.length - 2] = (__privateGet(this, _oa) - s2) / a2;
    o2[o2.length - 1] = (__privateGet(this, _la) - n2) / r2;
    if (isNaN(i2[6]) && !this.isEmpty()) return __privateMethod(this, _FreeDrawOutliner_instances, va_fn).call(this, o2);
    const l2 = new Float32Array(__privateGet(this, _aa).length + 24 + __privateGet(this, _ia).length);
    let h2 = t2.length;
    for (let e3 = 0; e3 < h2; e3 += 2) if (isNaN(t2[e3])) l2[e3] = l2[e3 + 1] = NaN;
    else {
      l2[e3] = t2[e3];
      l2[e3 + 1] = t2[e3 + 1];
    }
    h2 = __privateMethod(this, _FreeDrawOutliner_instances, xa_fn).call(this, l2, h2);
    for (let t3 = e2.length - 6; t3 >= 6; t3 -= 6) for (let i3 = 0; i3 < 6; i3 += 2) if (isNaN(e2[t3 + i3])) {
      l2[h2] = l2[h2 + 1] = NaN;
      h2 += 2;
    } else {
      l2[h2] = e2[t3 + i3];
      l2[h2 + 1] = e2[t3 + i3 + 1];
      h2 += 2;
    }
    __privateMethod(this, _FreeDrawOutliner_instances, Ea_fn).call(this, l2, h2);
    return this.newFreeDrawOutline(l2, o2, __privateGet(this, _ea), __privateGet(this, _ca), __privateGet(this, _sa), __privateGet(this, _na));
  }
};
_ea = new WeakMap();
_ia = new WeakMap();
_sa = new WeakMap();
_na = new WeakMap();
_aa = new WeakMap();
_ra = new WeakMap();
_oa = new WeakMap();
_la = new WeakMap();
_ha = new WeakMap();
_da = new WeakMap();
_ca = new WeakMap();
_ua = new WeakMap();
_pa = new WeakMap();
_ga = new WeakMap();
_fa = new WeakMap();
_ma = new WeakMap();
_FreeDrawOutliner_instances = new WeakSet();
ba_fn = function() {
  const t2 = __privateGet(this, _ra).subarray(4, 6), e2 = __privateGet(this, _ra).subarray(16, 18), [i2, s2, n2, a2] = __privateGet(this, _ea);
  return [(__privateGet(this, _oa) + (t2[0] - e2[0]) / 2 - i2) / n2, (__privateGet(this, _la) + (t2[1] - e2[1]) / 2 - s2) / a2, (__privateGet(this, _oa) + (e2[0] - t2[0]) / 2 - i2) / n2, (__privateGet(this, _la) + (e2[1] - t2[1]) / 2 - s2) / a2];
};
Aa_fn = function() {
  const [t2, e2, i2, s2] = __privateGet(this, _ea), [n2, a2, r2, o2] = __privateMethod(this, _FreeDrawOutliner_instances, ba_fn).call(this);
  return `M${(__privateGet(this, _ra)[2] - t2) / i2} ${(__privateGet(this, _ra)[3] - e2) / s2} L${(__privateGet(this, _ra)[4] - t2) / i2} ${(__privateGet(this, _ra)[5] - e2) / s2} L${n2} ${a2} L${r2} ${o2} L${(__privateGet(this, _ra)[16] - t2) / i2} ${(__privateGet(this, _ra)[17] - e2) / s2} L${(__privateGet(this, _ra)[14] - t2) / i2} ${(__privateGet(this, _ra)[15] - e2) / s2} Z`;
};
ya_fn = function(t2) {
  const e2 = __privateGet(this, _ia);
  t2.push(`L${e2[4]} ${e2[5]} Z`);
};
wa_fn = function(t2) {
  const [e2, i2, s2, n2] = __privateGet(this, _ea), a2 = __privateGet(this, _ra).subarray(4, 6), r2 = __privateGet(this, _ra).subarray(16, 18), [o2, l2, h2, d2] = __privateMethod(this, _FreeDrawOutliner_instances, ba_fn).call(this);
  t2.push(`L${(a2[0] - e2) / s2} ${(a2[1] - i2) / n2} L${o2} ${l2} L${h2} ${d2} L${(r2[0] - e2) / s2} ${(r2[1] - i2) / n2}`);
};
va_fn = function(t2) {
  const e2 = __privateGet(this, _ra), [i2, s2, n2, a2] = __privateGet(this, _ea), [r2, o2, l2, h2] = __privateMethod(this, _FreeDrawOutliner_instances, ba_fn).call(this), d2 = new Float32Array(36);
  d2.set([NaN, NaN, NaN, NaN, (e2[2] - i2) / n2, (e2[3] - s2) / a2, NaN, NaN, NaN, NaN, (e2[4] - i2) / n2, (e2[5] - s2) / a2, NaN, NaN, NaN, NaN, r2, o2, NaN, NaN, NaN, NaN, l2, h2, NaN, NaN, NaN, NaN, (e2[16] - i2) / n2, (e2[17] - s2) / a2, NaN, NaN, NaN, NaN, (e2[14] - i2) / n2, (e2[15] - s2) / a2], 0);
  return this.newFreeDrawOutline(d2, t2, __privateGet(this, _ea), __privateGet(this, _ca), __privateGet(this, _sa), __privateGet(this, _na));
};
Ea_fn = function(t2, e2) {
  const i2 = __privateGet(this, _ia);
  t2.set([NaN, NaN, NaN, NaN, i2[4], i2[5]], e2);
  return e2 + 6;
};
xa_fn = function(t2, e2) {
  const i2 = __privateGet(this, _ra).subarray(4, 6), s2 = __privateGet(this, _ra).subarray(16, 18), [n2, a2, r2, o2] = __privateGet(this, _ea), [l2, h2, d2, c2] = __privateMethod(this, _FreeDrawOutliner_instances, ba_fn).call(this);
  t2.set([NaN, NaN, NaN, NaN, (i2[0] - n2) / r2, (i2[1] - a2) / o2, NaN, NaN, NaN, NaN, l2, h2, NaN, NaN, NaN, NaN, d2, c2, NaN, NaN, NaN, NaN, (s2[0] - n2) / r2, (s2[1] - a2) / o2], e2);
  return e2 + 24;
};
__privateAdd(_FreeDrawOutliner, _ga, 8);
__privateAdd(_FreeDrawOutliner, _fa, 2);
__privateAdd(_FreeDrawOutliner, _ma, __privateGet(_FreeDrawOutliner, _ga) + __privateGet(_FreeDrawOutliner, _fa));
var FreeDrawOutliner = _FreeDrawOutliner;
var _ea2, __a, _sa2, _na2, _pa2, _ca2, _Sa, _FreeDrawOutline_instances, Ca_fn;
var FreeDrawOutline = class extends Outline {
  constructor(t2, e2, i2, s2, n2, a2) {
    super();
    __privateAdd(this, _FreeDrawOutline_instances);
    __privateAdd(this, _ea2);
    __privateAdd(this, __a, new Float32Array(4));
    __privateAdd(this, _sa2);
    __privateAdd(this, _na2);
    __privateAdd(this, _pa2);
    __privateAdd(this, _ca2);
    __privateAdd(this, _Sa);
    __privateSet(this, _Sa, t2);
    __privateSet(this, _pa2, e2);
    __privateSet(this, _ea2, i2);
    __privateSet(this, _ca2, s2);
    __privateSet(this, _sa2, n2);
    __privateSet(this, _na2, a2);
    this.lastPoint = [NaN, NaN];
    __privateMethod(this, _FreeDrawOutline_instances, Ca_fn).call(this, a2);
    const [r2, o2, l2, h2] = __privateGet(this, __a);
    for (let e3 = 0, i3 = t2.length; e3 < i3; e3 += 2) {
      t2[e3] = (t2[e3] - r2) / l2;
      t2[e3 + 1] = (t2[e3 + 1] - o2) / h2;
    }
    for (let t3 = 0, i3 = e2.length; t3 < i3; t3 += 2) {
      e2[t3] = (e2[t3] - r2) / l2;
      e2[t3 + 1] = (e2[t3 + 1] - o2) / h2;
    }
  }
  toSVGPath() {
    const t2 = [`M${__privateGet(this, _Sa)[4]} ${__privateGet(this, _Sa)[5]}`];
    for (let e2 = 6, i2 = __privateGet(this, _Sa).length; e2 < i2; e2 += 6) isNaN(__privateGet(this, _Sa)[e2]) ? t2.push(`L${__privateGet(this, _Sa)[e2 + 4]} ${__privateGet(this, _Sa)[e2 + 5]}`) : t2.push(`C${__privateGet(this, _Sa)[e2]} ${__privateGet(this, _Sa)[e2 + 1]} ${__privateGet(this, _Sa)[e2 + 2]} ${__privateGet(this, _Sa)[e2 + 3]} ${__privateGet(this, _Sa)[e2 + 4]} ${__privateGet(this, _Sa)[e2 + 5]}`);
    t2.push("Z");
    return t2.join(" ");
  }
  serialize([t2, e2, i2, s2], n2) {
    const a2 = i2 - t2, r2 = s2 - e2;
    let o2, l2;
    switch (n2) {
      case 0:
        o2 = Outline._rescale(__privateGet(this, _Sa), t2, s2, a2, -r2);
        l2 = Outline._rescale(__privateGet(this, _pa2), t2, s2, a2, -r2);
        break;
      case 90:
        o2 = Outline._rescaleAndSwap(__privateGet(this, _Sa), t2, e2, a2, r2);
        l2 = Outline._rescaleAndSwap(__privateGet(this, _pa2), t2, e2, a2, r2);
        break;
      case 180:
        o2 = Outline._rescale(__privateGet(this, _Sa), i2, e2, -a2, r2);
        l2 = Outline._rescale(__privateGet(this, _pa2), i2, e2, -a2, r2);
        break;
      case 270:
        o2 = Outline._rescaleAndSwap(__privateGet(this, _Sa), i2, s2, -a2, -r2);
        l2 = Outline._rescaleAndSwap(__privateGet(this, _pa2), i2, s2, -a2, -r2);
    }
    return { outline: Array.from(o2), points: [Array.from(l2)] };
  }
  get box() {
    return __privateGet(this, __a);
  }
  newOutliner(t2, e2, i2, s2, n2, a2 = 0) {
    return new FreeDrawOutliner(t2, e2, i2, s2, n2, a2);
  }
  getNewOutline(t2, e2) {
    const [i2, s2, n2, a2] = __privateGet(this, __a), [r2, o2, l2, h2] = __privateGet(this, _ea2), d2 = n2 * l2, c2 = a2 * h2, u2 = i2 * l2 + r2, p2 = s2 * h2 + o2, g2 = this.newOutliner({ x: __privateGet(this, _pa2)[0] * d2 + u2, y: __privateGet(this, _pa2)[1] * c2 + p2 }, __privateGet(this, _ea2), __privateGet(this, _ca2), t2, __privateGet(this, _na2), e2 ?? __privateGet(this, _sa2));
    for (let t3 = 2; t3 < __privateGet(this, _pa2).length; t3 += 2) g2.add({ x: __privateGet(this, _pa2)[t3] * d2 + u2, y: __privateGet(this, _pa2)[t3 + 1] * c2 + p2 });
    return g2.getOutlines();
  }
};
_ea2 = new WeakMap();
__a = new WeakMap();
_sa2 = new WeakMap();
_na2 = new WeakMap();
_pa2 = new WeakMap();
_ca2 = new WeakMap();
_Sa = new WeakMap();
_FreeDrawOutline_instances = new WeakSet();
Ca_fn = function(t2) {
  const e2 = __privateGet(this, _Sa);
  let i2 = e2[4], s2 = e2[5];
  const n2 = [i2, s2, i2, s2];
  let a2 = i2, r2 = s2;
  const o2 = t2 ? Math.max : Math.min;
  for (let t3 = 6, l3 = e2.length; t3 < l3; t3 += 6) {
    const l4 = e2[t3 + 4], h2 = e2[t3 + 5];
    if (isNaN(e2[t3])) {
      Util.pointBoundingBox(l4, h2, n2);
      if (r2 < h2) {
        a2 = l4;
        r2 = h2;
      } else r2 === h2 && (a2 = o2(a2, l4));
    } else {
      const l5 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      Util.bezierBoundingBox(i2, s2, ...e2.slice(t3, t3 + 6), l5);
      Util.rectBoundingBox(...l5, n2);
      if (r2 < l5[3]) {
        a2 = l5[2];
        r2 = l5[3];
      } else r2 === l5[3] && (a2 = o2(a2, l5[2]));
    }
    i2 = l4;
    s2 = h2;
  }
  const l2 = __privateGet(this, __a);
  l2[0] = n2[0] - __privateGet(this, _sa2);
  l2[1] = n2[1] - __privateGet(this, _sa2);
  l2[2] = n2[2] - n2[0] + 2 * __privateGet(this, _sa2);
  l2[3] = n2[3] - n2[1] + 2 * __privateGet(this, _sa2);
  this.lastPoint = [a2, r2];
};
var _ea3, _Ta, _Ma, _Da, _HighlightOutliner_instances, Ra_fn, Fa_fn, ka_fn, Ia_fn, Pa_fn;
var HighlightOutliner = class {
  constructor(t2, e2 = 0, i2 = 0, s2 = true) {
    __privateAdd(this, _HighlightOutliner_instances);
    __privateAdd(this, _ea3);
    __privateAdd(this, _Ta);
    __privateAdd(this, _Ma, []);
    __privateAdd(this, _Da, []);
    const n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], a2 = 10 ** -4;
    for (const { x: i3, y: s3, width: r3, height: o3 } of t2) {
      const t3 = Math.floor((i3 - e2) / a2) * a2, l3 = Math.ceil((i3 + r3 + e2) / a2) * a2, h3 = Math.floor((s3 - e2) / a2) * a2, d3 = Math.ceil((s3 + o3 + e2) / a2) * a2, c3 = [t3, h3, d3, true], u2 = [l3, h3, d3, false];
      __privateGet(this, _Ma).push(c3, u2);
      Util.rectBoundingBox(t3, h3, l3, d3, n2);
    }
    const r2 = n2[2] - n2[0] + 2 * i2, o2 = n2[3] - n2[1] + 2 * i2, l2 = n2[0] - i2, h2 = n2[1] - i2, d2 = __privateGet(this, _Ma).at(s2 ? -1 : -2), c2 = [d2[0], d2[2]];
    for (const t3 of __privateGet(this, _Ma)) {
      const [e3, i3, s3] = t3;
      t3[0] = (e3 - l2) / r2;
      t3[1] = (i3 - h2) / o2;
      t3[2] = (s3 - h2) / o2;
    }
    __privateSet(this, _ea3, new Float32Array([l2, h2, r2, o2]));
    __privateSet(this, _Ta, c2);
  }
  getOutlines() {
    __privateGet(this, _Ma).sort((t3, e2) => t3[0] - e2[0] || t3[1] - e2[1] || t3[2] - e2[2]);
    const t2 = [];
    for (const e2 of __privateGet(this, _Ma)) if (e2[3]) {
      t2.push(...__privateMethod(this, _HighlightOutliner_instances, Pa_fn).call(this, e2));
      __privateMethod(this, _HighlightOutliner_instances, ka_fn).call(this, e2);
    } else {
      __privateMethod(this, _HighlightOutliner_instances, Ia_fn).call(this, e2);
      t2.push(...__privateMethod(this, _HighlightOutliner_instances, Pa_fn).call(this, e2));
    }
    return __privateMethod(this, _HighlightOutliner_instances, Ra_fn).call(this, t2);
  }
};
_ea3 = new WeakMap();
_Ta = new WeakMap();
_Ma = new WeakMap();
_Da = new WeakMap();
_HighlightOutliner_instances = new WeakSet();
Ra_fn = function(t2) {
  const e2 = [], i2 = /* @__PURE__ */ new Set();
  for (const i3 of t2) {
    const [t3, s3, n3] = i3;
    e2.push([t3, s3, i3], [t3, n3, i3]);
  }
  e2.sort((t3, e3) => t3[1] - e3[1] || t3[0] - e3[0]);
  for (let t3 = 0, s3 = e2.length; t3 < s3; t3 += 2) {
    const s4 = e2[t3][2], n3 = e2[t3 + 1][2];
    s4.push(n3);
    n3.push(s4);
    i2.add(s4);
    i2.add(n3);
  }
  const s2 = [];
  let n2;
  for (; i2.size > 0; ) {
    const t3 = i2.values().next().value;
    let [e3, a2, r2, o2, l2] = t3;
    i2.delete(t3);
    let h2 = e3, d2 = a2;
    n2 = [e3, r2];
    s2.push(n2);
    for (; ; ) {
      let t4;
      if (i2.has(o2)) t4 = o2;
      else {
        if (!i2.has(l2)) break;
        t4 = l2;
      }
      i2.delete(t4);
      [e3, a2, r2, o2, l2] = t4;
      if (h2 !== e3) {
        n2.push(h2, d2, e3, d2 === a2 ? a2 : r2);
        h2 = e3;
      }
      d2 = d2 === a2 ? r2 : a2;
    }
    n2.push(h2, d2);
  }
  return new HighlightOutline(s2, __privateGet(this, _ea3), __privateGet(this, _Ta));
};
Fa_fn = function(t2) {
  const e2 = __privateGet(this, _Da);
  let i2 = 0, s2 = e2.length - 1;
  for (; i2 <= s2; ) {
    const n2 = i2 + s2 >> 1, a2 = e2[n2][0];
    if (a2 === t2) return n2;
    a2 < t2 ? i2 = n2 + 1 : s2 = n2 - 1;
  }
  return s2 + 1;
};
ka_fn = function([, t2, e2]) {
  const i2 = __privateMethod(this, _HighlightOutliner_instances, Fa_fn).call(this, t2);
  __privateGet(this, _Da).splice(i2, 0, [t2, e2]);
};
Ia_fn = function([, t2, e2]) {
  const i2 = __privateMethod(this, _HighlightOutliner_instances, Fa_fn).call(this, t2);
  for (let s2 = i2; s2 < __privateGet(this, _Da).length; s2++) {
    const [i3, n2] = __privateGet(this, _Da)[s2];
    if (i3 !== t2) break;
    if (i3 === t2 && n2 === e2) {
      __privateGet(this, _Da).splice(s2, 1);
      return;
    }
  }
  for (let s2 = i2 - 1; s2 >= 0; s2--) {
    const [i3, n2] = __privateGet(this, _Da)[s2];
    if (i3 !== t2) break;
    if (i3 === t2 && n2 === e2) {
      __privateGet(this, _Da).splice(s2, 1);
      return;
    }
  }
};
Pa_fn = function(t2) {
  const [e2, i2, s2] = t2, n2 = [[e2, i2, s2]], a2 = __privateMethod(this, _HighlightOutliner_instances, Fa_fn).call(this, s2);
  for (let t3 = 0; t3 < a2; t3++) {
    const [i3, s3] = __privateGet(this, _Da)[t3];
    for (let t4 = 0, a3 = n2.length; t4 < a3; t4++) {
      const [, r2, o2] = n2[t4];
      if (!(s3 <= r2 || o2 <= i3)) if (r2 >= i3) if (o2 > s3) n2[t4][1] = s3;
      else {
        if (1 === a3) return [];
        n2.splice(t4, 1);
        t4--;
        a3--;
      }
      else {
        n2[t4][2] = i3;
        o2 > s3 && n2.push([e2, s3, o2]);
      }
    }
  }
  return n2;
};
var _ea4, _La;
var HighlightOutline = class extends Outline {
  constructor(t2, e2, i2) {
    super();
    __privateAdd(this, _ea4);
    __privateAdd(this, _La);
    __privateSet(this, _La, t2);
    __privateSet(this, _ea4, e2);
    this.lastPoint = i2;
  }
  toSVGPath() {
    const t2 = [];
    for (const e2 of __privateGet(this, _La)) {
      let [i2, s2] = e2;
      t2.push(`M${i2} ${s2}`);
      for (let n2 = 2; n2 < e2.length; n2 += 2) {
        const a2 = e2[n2], r2 = e2[n2 + 1];
        if (a2 === i2) {
          t2.push(`V${r2}`);
          s2 = r2;
        } else if (r2 === s2) {
          t2.push(`H${a2}`);
          i2 = a2;
        }
      }
      t2.push("Z");
    }
    return t2.join(" ");
  }
  serialize([t2, e2, i2, s2], n2) {
    const a2 = [], r2 = i2 - t2, o2 = s2 - e2;
    for (const e3 of __privateGet(this, _La)) {
      const i3 = new Array(e3.length);
      for (let n3 = 0; n3 < e3.length; n3 += 2) {
        i3[n3] = t2 + e3[n3] * r2;
        i3[n3 + 1] = s2 - e3[n3 + 1] * o2;
      }
      a2.push(i3);
    }
    return a2;
  }
  get box() {
    return __privateGet(this, _ea4);
  }
  get classNamesForOutlining() {
    return ["highlightOutline"];
  }
};
_ea4 = new WeakMap();
_La = new WeakMap();
var FreeHighlightOutliner = class extends FreeDrawOutliner {
  newFreeDrawOutline(t2, e2, i2, s2, n2, a2) {
    return new FreeHighlightOutline(t2, e2, i2, s2, n2, a2);
  }
};
var FreeHighlightOutline = class extends FreeDrawOutline {
  newOutliner(t2, e2, i2, s2, n2, a2 = 0) {
    return new FreeHighlightOutliner(t2, e2, i2, s2, n2, a2);
  }
};
var _Oa, _Na, _Ba, _Ha, _Ua, _za, _a4, _Ga, _$a, _m2, _Wa, _Va, _ColorPicker_instances, qa_fn, Xa_fn, nn_fn2, ja_fn, d_fn2, Ka_get;
var _ColorPicker = class _ColorPicker {
  constructor({ editor: t2 = null, uiManager: e2 = null }) {
    __privateAdd(this, _ColorPicker_instances);
    __privateAdd(this, _Oa, null);
    __privateAdd(this, _Na, null);
    __privateAdd(this, _Ba);
    __privateAdd(this, _Ha, null);
    __privateAdd(this, _Ua, false);
    __privateAdd(this, _za, false);
    __privateAdd(this, _a4, null);
    __privateAdd(this, _Ga);
    __privateAdd(this, _$a, null);
    __privateAdd(this, _m2, null);
    __privateAdd(this, _Wa);
    var _a5;
    if (t2) {
      __privateSet(this, _za, false);
      __privateSet(this, _Wa, p.HIGHLIGHT_COLOR);
      __privateSet(this, _a4, t2);
    } else {
      __privateSet(this, _za, true);
      __privateSet(this, _Wa, p.HIGHLIGHT_DEFAULT_COLOR);
    }
    __privateSet(this, _m2, (t2 == null ? void 0 : t2._uiManager) || e2);
    __privateSet(this, _Ga, __privateGet(this, _m2)._eventBus);
    __privateSet(this, _Ba, (t2 == null ? void 0 : t2.color) || ((_a5 = __privateGet(this, _m2)) == null ? void 0 : _a5.highlightColors.values().next().value) || "#FFFF98");
    __privateGet(_ColorPicker, _Va) || __privateSet(_ColorPicker, _Va, Object.freeze({ blue: "pdfjs-editor-colorpicker-blue", green: "pdfjs-editor-colorpicker-green", pink: "pdfjs-editor-colorpicker-pink", red: "pdfjs-editor-colorpicker-red", yellow: "pdfjs-editor-colorpicker-yellow" }));
  }
  static get _keyboardManager() {
    return shadow(this, "_keyboardManager", new KeyboardManager([[["Escape", "mac+Escape"], _ColorPicker.prototype._hideDropdownFromKeyboard], [[" ", "mac+ "], _ColorPicker.prototype._colorSelectFromKeyboard], [["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"], _ColorPicker.prototype._moveToNext], [["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"], _ColorPicker.prototype._moveToPrevious], [["Home", "mac+Home"], _ColorPicker.prototype._moveToBeginning], [["End", "mac+End"], _ColorPicker.prototype._moveToEnd]]));
  }
  renderButton() {
    const t2 = __privateSet(this, _Oa, document.createElement("button"));
    t2.className = "colorPicker";
    t2.tabIndex = "0";
    t2.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button");
    t2.setAttribute("aria-haspopup", true);
    const e2 = __privateGet(this, _m2)._signal;
    t2.addEventListener("click", __privateMethod(this, _ColorPicker_instances, ja_fn).bind(this), { signal: e2 });
    t2.addEventListener("keydown", __privateMethod(this, _ColorPicker_instances, nn_fn2).bind(this), { signal: e2 });
    const i2 = __privateSet(this, _Na, document.createElement("span"));
    i2.className = "swatch";
    i2.setAttribute("aria-hidden", true);
    i2.style.backgroundColor = __privateGet(this, _Ba);
    t2.append(i2);
    return t2;
  }
  renderMainDropdown() {
    const t2 = __privateSet(this, _Ha, __privateMethod(this, _ColorPicker_instances, qa_fn).call(this));
    t2.setAttribute("aria-orientation", "horizontal");
    t2.setAttribute("aria-labelledby", "highlightColorPickerLabel");
    return t2;
  }
  _colorSelectFromKeyboard(t2) {
    if (t2.target === __privateGet(this, _Oa)) {
      __privateMethod(this, _ColorPicker_instances, ja_fn).call(this, t2);
      return;
    }
    const e2 = t2.target.getAttribute("data-color");
    e2 && __privateMethod(this, _ColorPicker_instances, Xa_fn).call(this, e2, t2);
  }
  _moveToNext(t2) {
    var _a5, _b;
    __privateGet(this, _ColorPicker_instances, Ka_get) ? t2.target !== __privateGet(this, _Oa) ? (_a5 = t2.target.nextSibling) == null ? void 0 : _a5.focus() : (_b = __privateGet(this, _Ha).firstChild) == null ? void 0 : _b.focus() : __privateMethod(this, _ColorPicker_instances, ja_fn).call(this, t2);
  }
  _moveToPrevious(t2) {
    var _a5, _b;
    if (t2.target !== ((_a5 = __privateGet(this, _Ha)) == null ? void 0 : _a5.firstChild) && t2.target !== __privateGet(this, _Oa)) {
      __privateGet(this, _ColorPicker_instances, Ka_get) || __privateMethod(this, _ColorPicker_instances, ja_fn).call(this, t2);
      (_b = t2.target.previousSibling) == null ? void 0 : _b.focus();
    } else __privateGet(this, _ColorPicker_instances, Ka_get) && this._hideDropdownFromKeyboard();
  }
  _moveToBeginning(t2) {
    var _a5;
    __privateGet(this, _ColorPicker_instances, Ka_get) ? (_a5 = __privateGet(this, _Ha).firstChild) == null ? void 0 : _a5.focus() : __privateMethod(this, _ColorPicker_instances, ja_fn).call(this, t2);
  }
  _moveToEnd(t2) {
    var _a5;
    __privateGet(this, _ColorPicker_instances, Ka_get) ? (_a5 = __privateGet(this, _Ha).lastChild) == null ? void 0 : _a5.focus() : __privateMethod(this, _ColorPicker_instances, ja_fn).call(this, t2);
  }
  hideDropdown() {
    var _a5, _b;
    (_a5 = __privateGet(this, _Ha)) == null ? void 0 : _a5.classList.add("hidden");
    (_b = __privateGet(this, _$a)) == null ? void 0 : _b.abort();
    __privateSet(this, _$a, null);
  }
  _hideDropdownFromKeyboard() {
    var _a5;
    if (!__privateGet(this, _za)) if (__privateGet(this, _ColorPicker_instances, Ka_get)) {
      this.hideDropdown();
      __privateGet(this, _Oa).focus({ preventScroll: true, focusVisible: __privateGet(this, _Ua) });
    } else (_a5 = __privateGet(this, _a4)) == null ? void 0 : _a5.unselect();
  }
  updateColor(t2) {
    __privateGet(this, _Na) && (__privateGet(this, _Na).style.backgroundColor = t2);
    if (!__privateGet(this, _Ha)) return;
    const e2 = __privateGet(this, _m2).highlightColors.values();
    for (const i2 of __privateGet(this, _Ha).children) i2.setAttribute("aria-selected", e2.next().value === t2);
  }
  destroy() {
    var _a5, _b;
    (_a5 = __privateGet(this, _Oa)) == null ? void 0 : _a5.remove();
    __privateSet(this, _Oa, null);
    __privateSet(this, _Na, null);
    (_b = __privateGet(this, _Ha)) == null ? void 0 : _b.remove();
    __privateSet(this, _Ha, null);
  }
};
_Oa = new WeakMap();
_Na = new WeakMap();
_Ba = new WeakMap();
_Ha = new WeakMap();
_Ua = new WeakMap();
_za = new WeakMap();
_a4 = new WeakMap();
_Ga = new WeakMap();
_$a = new WeakMap();
_m2 = new WeakMap();
_Wa = new WeakMap();
_Va = new WeakMap();
_ColorPicker_instances = new WeakSet();
qa_fn = function() {
  const t2 = document.createElement("div"), e2 = __privateGet(this, _m2)._signal;
  t2.addEventListener("contextmenu", noContextMenu, { signal: e2 });
  t2.className = "dropdown";
  t2.role = "listbox";
  t2.setAttribute("aria-multiselectable", false);
  t2.setAttribute("aria-orientation", "vertical");
  t2.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown");
  for (const [i2, s2] of __privateGet(this, _m2).highlightColors) {
    const n2 = document.createElement("button");
    n2.tabIndex = "0";
    n2.role = "option";
    n2.setAttribute("data-color", s2);
    n2.title = i2;
    n2.setAttribute("data-l10n-id", __privateGet(_ColorPicker, _Va)[i2]);
    const a2 = document.createElement("span");
    n2.append(a2);
    a2.className = "swatch";
    a2.style.backgroundColor = s2;
    n2.setAttribute("aria-selected", s2 === __privateGet(this, _Ba));
    n2.addEventListener("click", __privateMethod(this, _ColorPicker_instances, Xa_fn).bind(this, s2), { signal: e2 });
    t2.append(n2);
  }
  t2.addEventListener("keydown", __privateMethod(this, _ColorPicker_instances, nn_fn2).bind(this), { signal: e2 });
  return t2;
};
Xa_fn = function(t2, e2) {
  e2.stopPropagation();
  __privateGet(this, _Ga).dispatch("switchannotationeditorparams", { source: this, type: __privateGet(this, _Wa), value: t2 });
};
nn_fn2 = function(t2) {
  _ColorPicker._keyboardManager.exec(this, t2);
};
ja_fn = function(t2) {
  if (__privateGet(this, _ColorPicker_instances, Ka_get)) {
    this.hideDropdown();
    return;
  }
  __privateSet(this, _Ua, 0 === t2.detail);
  if (!__privateGet(this, _$a)) {
    __privateSet(this, _$a, new AbortController());
    window.addEventListener("pointerdown", __privateMethod(this, _ColorPicker_instances, d_fn2).bind(this), { signal: __privateGet(this, _m2).combinedSignal(__privateGet(this, _$a)) });
  }
  if (__privateGet(this, _Ha)) {
    __privateGet(this, _Ha).classList.remove("hidden");
    return;
  }
  const e2 = __privateSet(this, _Ha, __privateMethod(this, _ColorPicker_instances, qa_fn).call(this));
  __privateGet(this, _Oa).append(e2);
};
d_fn2 = function(t2) {
  var _a5;
  ((_a5 = __privateGet(this, _Ha)) == null ? void 0 : _a5.contains(t2.target)) || this.hideDropdown();
};
Ka_get = function() {
  return __privateGet(this, _Ha) && !__privateGet(this, _Ha).classList.contains("hidden");
};
__privateAdd(_ColorPicker, _Va, null);
var ColorPicker = _ColorPicker;
var _Ya, _Qa, _Ja, _Za, _n2, _tr, _er, _ir, _sr, _nr, _y4, _ar, _Ta2, _rr, _or, _lr, _ua2, _hr, _HighlightEditor_instances, ur_fn, dr_fn, qn_fn2, gr_fn, fr_fn, br_fn, cr_fn, _HighlightEditor_static, pr_fn, Ar_fn, wr_fn, mr_fn, yr_fn, vr_fn, Er_fn, xr_fn, ta_fn2;
var _HighlightEditor = class _HighlightEditor extends AnnotationEditor {
  constructor(t2) {
    super({ ...t2, name: "highlightEditor" });
    __privateAdd(this, _HighlightEditor_instances);
    __privateAdd(this, _Ya, null);
    __privateAdd(this, _Qa, 0);
    __privateAdd(this, _Ja);
    __privateAdd(this, _Za, null);
    __privateAdd(this, _n2, null);
    __privateAdd(this, _tr, null);
    __privateAdd(this, _er, null);
    __privateAdd(this, _ir, 0);
    __privateAdd(this, _sr, null);
    __privateAdd(this, _nr, null);
    __privateAdd(this, _y4, null);
    __privateAdd(this, _ar, false);
    __privateAdd(this, _Ta2, null);
    __privateAdd(this, _rr);
    __privateAdd(this, _or, null);
    __privateAdd(this, _lr, "");
    __privateAdd(this, _ua2);
    __privateAdd(this, _hr, "");
    this.color = t2.color || _HighlightEditor._defaultColor;
    __privateSet(this, _ua2, t2.thickness || _HighlightEditor._defaultThickness);
    __privateSet(this, _rr, t2.opacity || _HighlightEditor._defaultOpacity);
    __privateSet(this, _Ja, t2.boxes || null);
    __privateSet(this, _hr, t2.methodOfCreation || "");
    __privateSet(this, _lr, t2.text || "");
    this._isDraggable = false;
    this.defaultL10nId = "pdfjs-editor-highlight-editor";
    if (t2.highlightId > -1) {
      __privateSet(this, _ar, true);
      __privateMethod(this, _HighlightEditor_instances, dr_fn).call(this, t2);
      __privateMethod(this, _HighlightEditor_instances, cr_fn).call(this);
    } else if (__privateGet(this, _Ja)) {
      __privateSet(this, _Ya, t2.anchorNode);
      __privateSet(this, _Qa, t2.anchorOffset);
      __privateSet(this, _er, t2.focusNode);
      __privateSet(this, _ir, t2.focusOffset);
      __privateMethod(this, _HighlightEditor_instances, ur_fn).call(this);
      __privateMethod(this, _HighlightEditor_instances, cr_fn).call(this);
      this.rotate(this.rotation);
    }
  }
  static get _keyboardManager() {
    const t2 = _HighlightEditor.prototype;
    return shadow(this, "_keyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], t2._moveCaret, { args: [0] }], [["ArrowRight", "mac+ArrowRight"], t2._moveCaret, { args: [1] }], [["ArrowUp", "mac+ArrowUp"], t2._moveCaret, { args: [2] }], [["ArrowDown", "mac+ArrowDown"], t2._moveCaret, { args: [3] }]]));
  }
  get telemetryInitialData() {
    return { action: "added", type: __privateGet(this, _ar) ? "free_highlight" : "highlight", color: this._uiManager.highlightColorNames.get(this.color), thickness: __privateGet(this, _ua2), methodOfCreation: __privateGet(this, _hr) };
  }
  get telemetryFinalData() {
    return { type: "highlight", color: this._uiManager.highlightColorNames.get(this.color) };
  }
  static computeTelemetryFinalData(t2) {
    return { numberOfColors: t2.get("color").size };
  }
  static initialize(t2, e2) {
    var _a5;
    AnnotationEditor.initialize(t2, e2);
    _HighlightEditor._defaultColor || (_HighlightEditor._defaultColor = ((_a5 = e2.highlightColors) == null ? void 0 : _a5.values().next().value) || "#fff066");
  }
  static updateDefaultParams(t2, e2) {
    switch (t2) {
      case p.HIGHLIGHT_DEFAULT_COLOR:
        _HighlightEditor._defaultColor = e2;
        break;
      case p.HIGHLIGHT_THICKNESS:
        _HighlightEditor._defaultThickness = e2;
    }
  }
  translateInPage(t2, e2) {
  }
  get toolbarPosition() {
    return __privateGet(this, _Ta2);
  }
  updateParams(t2, e2) {
    switch (t2) {
      case p.HIGHLIGHT_COLOR:
        __privateMethod(this, _HighlightEditor_instances, qn_fn2).call(this, e2);
        break;
      case p.HIGHLIGHT_THICKNESS:
        __privateMethod(this, _HighlightEditor_instances, gr_fn).call(this, e2);
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[p.HIGHLIGHT_DEFAULT_COLOR, _HighlightEditor._defaultColor], [p.HIGHLIGHT_THICKNESS, _HighlightEditor._defaultThickness]];
  }
  get propertiesToUpdate() {
    return [[p.HIGHLIGHT_COLOR, this.color || _HighlightEditor._defaultColor], [p.HIGHLIGHT_THICKNESS, __privateGet(this, _ua2) || _HighlightEditor._defaultThickness], [p.HIGHLIGHT_FREE, __privateGet(this, _ar)]];
  }
  async addEditToolbar() {
    const t2 = await super.addEditToolbar();
    if (!t2) return null;
    if (this._uiManager.highlightColors) {
      __privateSet(this, _n2, new ColorPicker({ editor: this }));
      t2.addColorPicker(__privateGet(this, _n2));
    }
    return t2;
  }
  disableEditing() {
    super.disableEditing();
    this.div.classList.toggle("disabled", true);
  }
  enableEditing() {
    super.enableEditing();
    this.div.classList.toggle("disabled", false);
  }
  fixAndSetPosition() {
    return super.fixAndSetPosition(__privateMethod(this, _HighlightEditor_instances, mr_fn).call(this));
  }
  getBaseTranslation() {
    return [0, 0];
  }
  getRect(t2, e2) {
    return super.getRect(t2, e2, __privateMethod(this, _HighlightEditor_instances, mr_fn).call(this));
  }
  onceAdded(t2) {
    this.annotationElementId || this.parent.addUndoableEditor(this);
    t2 && this.div.focus();
  }
  remove() {
    __privateMethod(this, _HighlightEditor_instances, br_fn).call(this);
    this._reportTelemetry({ action: "deleted" });
    super.remove();
  }
  rebuild() {
    if (this.parent) {
      super.rebuild();
      if (null !== this.div) {
        __privateMethod(this, _HighlightEditor_instances, cr_fn).call(this);
        this.isAttachedToDOM || this.parent.add(this);
      }
    }
  }
  setParent(t2) {
    var _a5;
    let e2 = false;
    if (this.parent && !t2) __privateMethod(this, _HighlightEditor_instances, br_fn).call(this);
    else if (t2) {
      __privateMethod(this, _HighlightEditor_instances, cr_fn).call(this, t2);
      e2 = !this.parent && ((_a5 = this.div) == null ? void 0 : _a5.classList.contains("selectedEditor"));
    }
    super.setParent(t2);
    this.show(this._isVisible);
    e2 && this.select();
  }
  rotate(t2) {
    var _a5, _b, _c;
    const { drawLayer: e2 } = this.parent;
    let i2;
    if (__privateGet(this, _ar)) {
      t2 = (t2 - this.rotation + 360) % 360;
      i2 = __privateMethod(_a5 = _HighlightEditor, _HighlightEditor_static, pr_fn).call(_a5, __privateGet(this, _nr).box, t2);
    } else i2 = __privateMethod(_b = _HighlightEditor, _HighlightEditor_static, pr_fn).call(_b, [this.x, this.y, this.width, this.height], t2);
    e2.updateProperties(__privateGet(this, _y4), { bbox: i2, root: { "data-main-rotation": t2 } });
    e2.updateProperties(__privateGet(this, _or), { bbox: __privateMethod(_c = _HighlightEditor, _HighlightEditor_static, pr_fn).call(_c, __privateGet(this, _tr).box, t2), root: { "data-main-rotation": t2 } });
  }
  render() {
    if (this.div) return this.div;
    const t2 = super.render();
    if (__privateGet(this, _lr)) {
      t2.setAttribute("aria-label", __privateGet(this, _lr));
      t2.setAttribute("role", "mark");
    }
    __privateGet(this, _ar) ? t2.classList.add("free") : this.div.addEventListener("keydown", __privateMethod(this, _HighlightEditor_instances, Ar_fn).bind(this), { signal: this._uiManager._signal });
    const e2 = __privateSet(this, _sr, document.createElement("div"));
    t2.append(e2);
    e2.setAttribute("aria-hidden", "true");
    e2.className = "internal";
    e2.style.clipPath = __privateGet(this, _Za);
    const [i2, s2] = this.parentDimensions;
    this.setDims(this.width * i2, this.height * s2);
    bindEvents(this, __privateGet(this, _sr), ["pointerover", "pointerleave"]);
    this.enableEditing();
    return t2;
  }
  pointerover() {
    var _a5;
    this.isSelected || ((_a5 = this.parent) == null ? void 0 : _a5.drawLayer.updateProperties(__privateGet(this, _or), { rootClass: { hovered: true } }));
  }
  pointerleave() {
    var _a5;
    this.isSelected || ((_a5 = this.parent) == null ? void 0 : _a5.drawLayer.updateProperties(__privateGet(this, _or), { rootClass: { hovered: false } }));
  }
  _moveCaret(t2) {
    this.parent.unselect(this);
    switch (t2) {
      case 0:
      case 2:
        __privateMethod(this, _HighlightEditor_instances, wr_fn).call(this, true);
        break;
      case 1:
      case 3:
        __privateMethod(this, _HighlightEditor_instances, wr_fn).call(this, false);
    }
  }
  select() {
    var _a5;
    super.select();
    __privateGet(this, _or) && ((_a5 = this.parent) == null ? void 0 : _a5.drawLayer.updateProperties(__privateGet(this, _or), { rootClass: { hovered: false, selected: true } }));
  }
  unselect() {
    var _a5;
    super.unselect();
    if (__privateGet(this, _or)) {
      (_a5 = this.parent) == null ? void 0 : _a5.drawLayer.updateProperties(__privateGet(this, _or), { rootClass: { selected: false } });
      __privateGet(this, _ar) || __privateMethod(this, _HighlightEditor_instances, wr_fn).call(this, false);
    }
  }
  get _mustFixPosition() {
    return !__privateGet(this, _ar);
  }
  show(t2 = this._isVisible) {
    super.show(t2);
    if (this.parent) {
      this.parent.drawLayer.updateProperties(__privateGet(this, _y4), { rootClass: { hidden: !t2 } });
      this.parent.drawLayer.updateProperties(__privateGet(this, _or), { rootClass: { hidden: !t2 } });
    }
  }
  static startHighlighting(t2, e2, { target: i2, x: s2, y: n2 }) {
    const { x: a2, y: r2, width: o2, height: l2 } = i2.getBoundingClientRect(), h2 = new AbortController(), d2 = t2.combinedSignal(h2), pointerUpCallback = (e3) => {
      h2.abort();
      __privateMethod(this, _HighlightEditor_static, xr_fn).call(this, t2, e3);
    };
    window.addEventListener("blur", pointerUpCallback, { signal: d2 });
    window.addEventListener("pointerup", pointerUpCallback, { signal: d2 });
    window.addEventListener("pointerdown", stopEvent, { capture: true, passive: false, signal: d2 });
    window.addEventListener("contextmenu", noContextMenu, { signal: d2 });
    i2.addEventListener("pointermove", __privateMethod(this, _HighlightEditor_static, Er_fn).bind(this, t2), { signal: d2 });
    this._freeHighlight = new FreeHighlightOutliner({ x: s2, y: n2 }, [a2, r2, o2, l2], t2.scale, this._defaultThickness / 2, e2, 1e-3);
    ({ id: this._freeHighlightId, clipPathId: this._freeHighlightClipId } = t2.drawLayer.draw({ bbox: [0, 0, 1, 1], root: { viewBox: "0 0 1 1", fill: this._defaultColor, "fill-opacity": this._defaultOpacity }, rootClass: { highlight: true, free: true }, path: { d: this._freeHighlight.toSVGPath() } }, true, true));
  }
  static async deserialize(t2, e2, i2) {
    var _a5, _b, _c, _d;
    let s2 = null;
    if (t2 instanceof HighlightAnnotationElement) {
      const { data: { quadPoints: e3, rect: i3, rotation: n3, id: a3, color: r3, opacity: o3, popupRef: l3 }, parent: { page: { pageNumber: h3 } } } = t2;
      s2 = t2 = { annotationType: u.HIGHLIGHT, color: Array.from(r3), opacity: o3, quadPoints: e3, boxes: null, pageIndex: h3 - 1, rect: i3.slice(0), rotation: n3, id: a3, deleted: false, popupRef: l3 };
    } else if (t2 instanceof InkAnnotationElement) {
      const { data: { inkLists: e3, rect: i3, rotation: n3, id: a3, color: r3, borderStyle: { rawWidth: o3 }, popupRef: l3 }, parent: { page: { pageNumber: h3 } } } = t2;
      s2 = t2 = { annotationType: u.HIGHLIGHT, color: Array.from(r3), thickness: o3, inkLists: e3, boxes: null, pageIndex: h3 - 1, rect: i3.slice(0), rotation: n3, id: a3, deleted: false, popupRef: l3 };
    }
    const { color: n2, quadPoints: a2, inkLists: r2, opacity: o2 } = t2, l2 = await super.deserialize(t2, e2, i2);
    l2.color = Util.makeHexColor(...n2);
    __privateSet(l2, _rr, o2 || 1);
    r2 && __privateSet(l2, _ua2, t2.thickness);
    l2.annotationElementId = t2.id || null;
    l2._initialData = s2;
    const [h2, d2] = l2.pageDimensions, [c2, p2] = l2.pageTranslation;
    if (a2) {
      const t3 = __privateSet(l2, _Ja, []);
      for (let e3 = 0; e3 < a2.length; e3 += 8) t3.push({ x: (a2[e3] - c2) / h2, y: 1 - (a2[e3 + 1] - p2) / d2, width: (a2[e3 + 2] - a2[e3]) / h2, height: (a2[e3 + 1] - a2[e3 + 5]) / d2 });
      __privateMethod(_a5 = l2, _HighlightEditor_instances, ur_fn).call(_a5);
      __privateMethod(_b = l2, _HighlightEditor_instances, cr_fn).call(_b);
      l2.rotate(l2.rotation);
    } else if (r2) {
      __privateSet(l2, _ar, true);
      const t3 = r2[0], i3 = { x: t3[0] - c2, y: d2 - (t3[1] - p2) }, s3 = new FreeHighlightOutliner(i3, [0, 0, h2, d2], 1, __privateGet(l2, _ua2) / 2, true, 1e-3);
      for (let e3 = 0, n4 = t3.length; e3 < n4; e3 += 2) {
        i3.x = t3[e3] - c2;
        i3.y = d2 - (t3[e3 + 1] - p2);
        s3.add(i3);
      }
      const { id: n3, clipPathId: a3 } = e2.drawLayer.draw({ bbox: [0, 0, 1, 1], root: { viewBox: "0 0 1 1", fill: l2.color, "fill-opacity": l2._defaultOpacity }, rootClass: { highlight: true, free: true }, path: { d: s3.toSVGPath() } }, true, true);
      __privateMethod(_c = l2, _HighlightEditor_instances, dr_fn).call(_c, { highlightOutlines: s3.getOutlines(), highlightId: n3, clipPathId: a3 });
      __privateMethod(_d = l2, _HighlightEditor_instances, cr_fn).call(_d);
      l2.rotate(l2.parentRotation);
    }
    return l2;
  }
  serialize(t2 = false) {
    if (this.isEmpty() || t2) return null;
    if (this.deleted) return this.serializeDeleted();
    const e2 = this.getRect(0, 0), i2 = AnnotationEditor._colorManager.convert(this.color), s2 = { annotationType: u.HIGHLIGHT, color: i2, opacity: __privateGet(this, _rr), thickness: __privateGet(this, _ua2), quadPoints: __privateMethod(this, _HighlightEditor_instances, yr_fn).call(this), outlines: __privateMethod(this, _HighlightEditor_instances, vr_fn).call(this, e2), pageIndex: this.pageIndex, rect: e2, rotation: __privateMethod(this, _HighlightEditor_instances, mr_fn).call(this), structTreeParentId: this._structTreeParentId };
    if (this.annotationElementId && !__privateMethod(this, _HighlightEditor_instances, ta_fn2).call(this, s2)) return null;
    s2.id = this.annotationElementId;
    return s2;
  }
  renderAnnotationElement(t2) {
    t2.updateEdited({ rect: this.getRect(0, 0) });
    return null;
  }
  static canCreateNewEmptyEditor() {
    return false;
  }
};
_Ya = new WeakMap();
_Qa = new WeakMap();
_Ja = new WeakMap();
_Za = new WeakMap();
_n2 = new WeakMap();
_tr = new WeakMap();
_er = new WeakMap();
_ir = new WeakMap();
_sr = new WeakMap();
_nr = new WeakMap();
_y4 = new WeakMap();
_ar = new WeakMap();
_Ta2 = new WeakMap();
_rr = new WeakMap();
_or = new WeakMap();
_lr = new WeakMap();
_ua2 = new WeakMap();
_hr = new WeakMap();
_HighlightEditor_instances = new WeakSet();
ur_fn = function() {
  const t2 = new HighlightOutliner(__privateGet(this, _Ja), 1e-3);
  __privateSet(this, _nr, t2.getOutlines());
  [this.x, this.y, this.width, this.height] = __privateGet(this, _nr).box;
  const e2 = new HighlightOutliner(__privateGet(this, _Ja), 25e-4, 1e-3, "ltr" === this._uiManager.direction);
  __privateSet(this, _tr, e2.getOutlines());
  const { lastPoint: i2 } = __privateGet(this, _tr);
  __privateSet(this, _Ta2, [(i2[0] - this.x) / this.width, (i2[1] - this.y) / this.height]);
};
dr_fn = function({ highlightOutlines: t2, highlightId: e2, clipPathId: i2 }) {
  var _a5, _b;
  __privateSet(this, _nr, t2);
  __privateSet(this, _tr, t2.getNewOutline(__privateGet(this, _ua2) / 2 + 1.5, 25e-4));
  if (e2 >= 0) {
    __privateSet(this, _y4, e2);
    __privateSet(this, _Za, i2);
    this.parent.drawLayer.finalizeDraw(e2, { bbox: t2.box, path: { d: t2.toSVGPath() } });
    __privateSet(this, _or, this.parent.drawLayer.drawOutline({ rootClass: { highlightOutline: true, free: true }, bbox: __privateGet(this, _tr).box, path: { d: __privateGet(this, _tr).toSVGPath() } }, true));
  } else if (this.parent) {
    const e3 = this.parent.viewport.rotation;
    this.parent.drawLayer.updateProperties(__privateGet(this, _y4), { bbox: __privateMethod(_a5 = _HighlightEditor, _HighlightEditor_static, pr_fn).call(_a5, __privateGet(this, _nr).box, (e3 - this.rotation + 360) % 360), path: { d: t2.toSVGPath() } });
    this.parent.drawLayer.updateProperties(__privateGet(this, _or), { bbox: __privateMethod(_b = _HighlightEditor, _HighlightEditor_static, pr_fn).call(_b, __privateGet(this, _tr).box, e3), path: { d: __privateGet(this, _tr).toSVGPath() } });
  }
  const [s2, n2, a2, r2] = t2.box;
  switch (this.rotation) {
    case 0:
      this.x = s2;
      this.y = n2;
      this.width = a2;
      this.height = r2;
      break;
    case 90: {
      const [t3, e3] = this.parentDimensions;
      this.x = n2;
      this.y = 1 - s2;
      this.width = a2 * e3 / t3;
      this.height = r2 * t3 / e3;
      break;
    }
    case 180:
      this.x = 1 - s2;
      this.y = 1 - n2;
      this.width = a2;
      this.height = r2;
      break;
    case 270: {
      const [t3, e3] = this.parentDimensions;
      this.x = 1 - n2;
      this.y = s2;
      this.width = a2 * e3 / t3;
      this.height = r2 * t3 / e3;
      break;
    }
  }
  const { lastPoint: o2 } = __privateGet(this, _tr);
  __privateSet(this, _Ta2, [(o2[0] - s2) / a2, (o2[1] - n2) / r2]);
};
qn_fn2 = function(t2) {
  const setColorAndOpacity = (t3, e3) => {
    var _a5, _b;
    this.color = t3;
    __privateSet(this, _rr, e3);
    (_a5 = this.parent) == null ? void 0 : _a5.drawLayer.updateProperties(__privateGet(this, _y4), { root: { fill: t3, "fill-opacity": e3 } });
    (_b = __privateGet(this, _n2)) == null ? void 0 : _b.updateColor(t3);
  }, e2 = this.color, i2 = __privateGet(this, _rr);
  this.addCommands({ cmd: setColorAndOpacity.bind(this, t2, _HighlightEditor._defaultOpacity), undo: setColorAndOpacity.bind(this, e2, i2), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: true, type: p.HIGHLIGHT_COLOR, overwriteIfSameType: true, keepUndo: true });
  this._reportTelemetry({ action: "color_changed", color: this._uiManager.highlightColorNames.get(t2) }, true);
};
gr_fn = function(t2) {
  const e2 = __privateGet(this, _ua2), setThickness = (t3) => {
    __privateSet(this, _ua2, t3);
    __privateMethod(this, _HighlightEditor_instances, fr_fn).call(this, t3);
  };
  this.addCommands({ cmd: setThickness.bind(this, t2), undo: setThickness.bind(this, e2), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: true, type: p.INK_THICKNESS, overwriteIfSameType: true, keepUndo: true });
  this._reportTelemetry({ action: "thickness_changed", thickness: t2 }, true);
};
fr_fn = function(t2) {
  if (!__privateGet(this, _ar)) return;
  __privateMethod(this, _HighlightEditor_instances, dr_fn).call(this, { highlightOutlines: __privateGet(this, _nr).getNewOutline(t2 / 2) });
  this.fixAndSetPosition();
  const [e2, i2] = this.parentDimensions;
  this.setDims(this.width * e2, this.height * i2);
};
br_fn = function() {
  if (null !== __privateGet(this, _y4) && this.parent) {
    this.parent.drawLayer.remove(__privateGet(this, _y4));
    __privateSet(this, _y4, null);
    this.parent.drawLayer.remove(__privateGet(this, _or));
    __privateSet(this, _or, null);
  }
};
cr_fn = function(t2 = this.parent) {
  if (null === __privateGet(this, _y4)) {
    ({ id: __privateWrapper(this, _y4)._, clipPathId: __privateWrapper(this, _Za)._ } = t2.drawLayer.draw({ bbox: __privateGet(this, _nr).box, root: { viewBox: "0 0 1 1", fill: this.color, "fill-opacity": __privateGet(this, _rr) }, rootClass: { highlight: true, free: __privateGet(this, _ar) }, path: { d: __privateGet(this, _nr).toSVGPath() } }, false, true));
    __privateSet(this, _or, t2.drawLayer.drawOutline({ rootClass: { highlightOutline: true, free: __privateGet(this, _ar) }, bbox: __privateGet(this, _tr).box, path: { d: __privateGet(this, _tr).toSVGPath() } }, __privateGet(this, _ar)));
    __privateGet(this, _sr) && (__privateGet(this, _sr).style.clipPath = __privateGet(this, _Za));
  }
};
_HighlightEditor_static = new WeakSet();
pr_fn = function([t2, e2, i2, s2], n2) {
  switch (n2) {
    case 90:
      return [1 - e2 - s2, t2, s2, i2];
    case 180:
      return [1 - t2 - i2, 1 - e2 - s2, i2, s2];
    case 270:
      return [e2, 1 - t2 - i2, s2, i2];
  }
  return [t2, e2, i2, s2];
};
Ar_fn = function(t2) {
  _HighlightEditor._keyboardManager.exec(this, t2);
};
wr_fn = function(t2) {
  if (!__privateGet(this, _Ya)) return;
  const e2 = window.getSelection();
  t2 ? e2.setPosition(__privateGet(this, _Ya), __privateGet(this, _Qa)) : e2.setPosition(__privateGet(this, _er), __privateGet(this, _ir));
};
mr_fn = function() {
  return __privateGet(this, _ar) ? this.rotation : 0;
};
yr_fn = function() {
  if (__privateGet(this, _ar)) return null;
  const [t2, e2] = this.pageDimensions, [i2, s2] = this.pageTranslation, n2 = __privateGet(this, _Ja), a2 = new Float32Array(8 * n2.length);
  let r2 = 0;
  for (const { x: o2, y: l2, width: h2, height: d2 } of n2) {
    const n3 = o2 * t2 + i2, c2 = (1 - l2) * e2 + s2;
    a2[r2] = a2[r2 + 4] = n3;
    a2[r2 + 1] = a2[r2 + 3] = c2;
    a2[r2 + 2] = a2[r2 + 6] = n3 + h2 * t2;
    a2[r2 + 5] = a2[r2 + 7] = c2 - d2 * e2;
    r2 += 8;
  }
  return a2;
};
vr_fn = function(t2) {
  return __privateGet(this, _nr).serialize(t2, __privateMethod(this, _HighlightEditor_instances, mr_fn).call(this));
};
Er_fn = function(t2, e2) {
  this._freeHighlight.add(e2) && t2.drawLayer.updateProperties(this._freeHighlightId, { path: { d: this._freeHighlight.toSVGPath() } });
};
xr_fn = function(t2, e2) {
  this._freeHighlight.isEmpty() ? t2.drawLayer.remove(this._freeHighlightId) : t2.createAndAddNewEditor(e2, false, { highlightId: this._freeHighlightId, highlightOutlines: this._freeHighlight.getOutlines(), clipPathId: this._freeHighlightClipId, methodOfCreation: "main_toolbar" });
  this._freeHighlightId = -1;
  this._freeHighlight = null;
  this._freeHighlightClipId = "";
};
ta_fn2 = function(t2) {
  const { color: e2 } = this._initialData;
  return t2.color.some((t3, i2) => t3 !== e2[i2]);
};
__privateAdd(_HighlightEditor, _HighlightEditor_static);
__publicField(_HighlightEditor, "_defaultColor", null);
__publicField(_HighlightEditor, "_defaultOpacity", 1);
__publicField(_HighlightEditor, "_defaultThickness", 12);
__publicField(_HighlightEditor, "_type", "highlight");
__publicField(_HighlightEditor, "_editorType", u.HIGHLIGHT);
__publicField(_HighlightEditor, "_freeHighlightId", -1);
__publicField(_HighlightEditor, "_freeHighlight", null);
__publicField(_HighlightEditor, "_freeHighlightClipId", "");
var HighlightEditor = _HighlightEditor;
var __r;
var DrawingOptions = class {
  constructor() {
    __privateAdd(this, __r, /* @__PURE__ */ Object.create(null));
  }
  updateProperty(t2, e2) {
    this[t2] = e2;
    this.updateSVGProperty(t2, e2);
  }
  updateProperties(t2) {
    if (t2) for (const [e2, i2] of Object.entries(t2)) e2.startsWith("_") || this.updateProperty(e2, i2);
  }
  updateSVGProperty(t2, e2) {
    __privateGet(this, __r)[t2] = e2;
  }
  toSVGProperties() {
    const t2 = __privateGet(this, __r);
    __privateSet(this, __r, /* @__PURE__ */ Object.create(null));
    return { root: t2 };
  }
  reset() {
    __privateSet(this, __r, /* @__PURE__ */ Object.create(null));
  }
  updateAll(t2 = this) {
    this.updateProperties(t2);
  }
  clone() {
    unreachable("Not implemented");
  }
};
__r = new WeakMap();
var _Sr, _Cr, _Tr, _Mr, _Dr, _Pr, _kr, _Ir, _Rr, _DrawingEditor_instances, Fr_fn, Lr_fn, br_fn2, cr_fn2, Hr_fn, Nr_fn, Or_fn, Br_fn;
var _DrawingEditor = class _DrawingEditor extends AnnotationEditor {
  constructor(t2) {
    super(t2);
    __privateAdd(this, _DrawingEditor_instances);
    __privateAdd(this, _Sr, null);
    __privateAdd(this, _Cr);
    __publicField(this, "_drawId", null);
    __privateSet(this, _Cr, t2.mustBeCommitted || false);
    this._addOutlines(t2);
  }
  _addOutlines(t2) {
    if (t2.drawOutlines) {
      __privateMethod(this, _DrawingEditor_instances, Fr_fn).call(this, t2);
      __privateMethod(this, _DrawingEditor_instances, cr_fn2).call(this);
    }
  }
  static _mergeSVGProperties(t2, e2) {
    const i2 = new Set(Object.keys(t2));
    for (const [s2, n2] of Object.entries(e2)) i2.has(s2) ? Object.assign(t2[s2], n2) : t2[s2] = n2;
    return t2;
  }
  static getDefaultDrawingOptions(t2) {
    unreachable("Not implemented");
  }
  static get typesMap() {
    unreachable("Not implemented");
  }
  static get isDrawer() {
    return true;
  }
  static get supportMultipleDrawings() {
    return false;
  }
  static updateDefaultParams(t2, e2) {
    const i2 = this.typesMap.get(t2);
    i2 && this._defaultDrawingOptions.updateProperty(i2, e2);
    if (this._currentParent) {
      __privateGet(_DrawingEditor, _Tr).updateProperty(i2, e2);
      this._currentParent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());
    }
  }
  updateParams(t2, e2) {
    const i2 = this.constructor.typesMap.get(t2);
    i2 && this._updateProperty(t2, i2, e2);
  }
  static get defaultPropertiesToUpdate() {
    const t2 = [], e2 = this._defaultDrawingOptions;
    for (const [i2, s2] of this.typesMap) t2.push([i2, e2[s2]]);
    return t2;
  }
  get propertiesToUpdate() {
    const t2 = [], { _drawingOptions: e2 } = this;
    for (const [i2, s2] of this.constructor.typesMap) t2.push([i2, e2[s2]]);
    return t2;
  }
  _updateProperty(t2, e2, i2) {
    const s2 = this._drawingOptions, n2 = s2[e2], setter = (t3) => {
      var _a5;
      s2.updateProperty(e2, t3);
      const i3 = __privateGet(this, _Sr).updateProperty(e2, t3);
      i3 && __privateMethod(this, _DrawingEditor_instances, Or_fn).call(this, i3);
      (_a5 = this.parent) == null ? void 0 : _a5.drawLayer.updateProperties(this._drawId, s2.toSVGProperties());
    };
    this.addCommands({ cmd: setter.bind(this, i2), undo: setter.bind(this, n2), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: true, type: t2, overwriteIfSameType: true, keepUndo: true });
  }
  _onResizing() {
    var _a5;
    (_a5 = this.parent) == null ? void 0 : _a5.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties(__privateGet(this, _Sr).getPathResizingSVGProperties(__privateMethod(this, _DrawingEditor_instances, Nr_fn).call(this)), { bbox: __privateMethod(this, _DrawingEditor_instances, Br_fn).call(this) }));
  }
  _onResized() {
    var _a5;
    (_a5 = this.parent) == null ? void 0 : _a5.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties(__privateGet(this, _Sr).getPathResizedSVGProperties(__privateMethod(this, _DrawingEditor_instances, Nr_fn).call(this)), { bbox: __privateMethod(this, _DrawingEditor_instances, Br_fn).call(this) }));
  }
  _onTranslating(t2, e2) {
    var _a5;
    (_a5 = this.parent) == null ? void 0 : _a5.drawLayer.updateProperties(this._drawId, { bbox: __privateMethod(this, _DrawingEditor_instances, Br_fn).call(this) });
  }
  _onTranslated() {
    var _a5;
    (_a5 = this.parent) == null ? void 0 : _a5.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties(__privateGet(this, _Sr).getPathTranslatedSVGProperties(__privateMethod(this, _DrawingEditor_instances, Nr_fn).call(this), this.parentDimensions), { bbox: __privateMethod(this, _DrawingEditor_instances, Br_fn).call(this) }));
  }
  _onStartDragging() {
    var _a5;
    (_a5 = this.parent) == null ? void 0 : _a5.drawLayer.updateProperties(this._drawId, { rootClass: { moving: true } });
  }
  _onStopDragging() {
    var _a5;
    (_a5 = this.parent) == null ? void 0 : _a5.drawLayer.updateProperties(this._drawId, { rootClass: { moving: false } });
  }
  commit() {
    super.commit();
    this.disableEditMode();
    this.disableEditing();
  }
  disableEditing() {
    super.disableEditing();
    this.div.classList.toggle("disabled", true);
  }
  enableEditing() {
    super.enableEditing();
    this.div.classList.toggle("disabled", false);
  }
  getBaseTranslation() {
    return [0, 0];
  }
  get isResizable() {
    return true;
  }
  onceAdded(t2) {
    this.annotationElementId || this.parent.addUndoableEditor(this);
    this._isDraggable = true;
    if (__privateGet(this, _Cr)) {
      __privateSet(this, _Cr, false);
      this.commit();
      this.parent.setSelected(this);
      t2 && this.isOnScreen && this.div.focus();
    }
  }
  remove() {
    __privateMethod(this, _DrawingEditor_instances, br_fn2).call(this);
    super.remove();
  }
  rebuild() {
    if (this.parent) {
      super.rebuild();
      if (null !== this.div) {
        __privateMethod(this, _DrawingEditor_instances, cr_fn2).call(this);
        __privateMethod(this, _DrawingEditor_instances, Or_fn).call(this, __privateGet(this, _Sr).box);
        this.isAttachedToDOM || this.parent.add(this);
      }
    }
  }
  setParent(t2) {
    var _a5;
    let e2 = false;
    if (this.parent && !t2) {
      this._uiManager.removeShouldRescale(this);
      __privateMethod(this, _DrawingEditor_instances, br_fn2).call(this);
    } else if (t2) {
      this._uiManager.addShouldRescale(this);
      __privateMethod(this, _DrawingEditor_instances, cr_fn2).call(this, t2);
      e2 = !this.parent && ((_a5 = this.div) == null ? void 0 : _a5.classList.contains("selectedEditor"));
    }
    super.setParent(t2);
    e2 && this.select();
  }
  rotate() {
    this.parent && this.parent.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties({ bbox: __privateMethod(this, _DrawingEditor_instances, Br_fn).call(this) }, __privateGet(this, _Sr).updateRotation((this.parentRotation - this.rotation + 360) % 360)));
  }
  onScaleChanging() {
    this.parent && __privateMethod(this, _DrawingEditor_instances, Or_fn).call(this, __privateGet(this, _Sr).updateParentDimensions(this.parentDimensions, this.parent.scale));
  }
  static onScaleChangingWhenDrawing() {
  }
  render() {
    if (this.div) return this.div;
    let t2, e2;
    if (this._isCopy) {
      t2 = this.x;
      e2 = this.y;
    }
    const i2 = super.render();
    i2.classList.add("draw");
    const s2 = document.createElement("div");
    i2.append(s2);
    s2.setAttribute("aria-hidden", "true");
    s2.className = "internal";
    const [n2, a2] = this.parentDimensions;
    this.setDims(this.width * n2, this.height * a2);
    this._uiManager.addShouldRescale(this);
    this.disableEditing();
    this._isCopy && this._moveAfterPaste(t2, e2);
    return i2;
  }
  static createDrawerInstance(t2, e2, i2, s2, n2) {
    unreachable("Not implemented");
  }
  static startDrawing(t2, e2, i2, s2) {
    var _a5;
    const { target: n2, offsetX: a2, offsetY: r2, pointerId: o2, pointerType: l2 } = s2;
    if (__privateGet(_DrawingEditor, _kr) && __privateGet(_DrawingEditor, _kr) !== l2) return;
    const { viewport: { rotation: h2 } } = t2, { width: d2, height: c2 } = n2.getBoundingClientRect(), u2 = __privateSet(_DrawingEditor, _Mr, new AbortController()), p2 = t2.combinedSignal(u2);
    __privateGet(_DrawingEditor, _Pr) || __privateSet(_DrawingEditor, _Pr, o2);
    __privateGet(_DrawingEditor, _kr) ?? __privateSet(_DrawingEditor, _kr, l2);
    window.addEventListener("pointerup", (t3) => {
      var _a6;
      __privateGet(_DrawingEditor, _Pr) === t3.pointerId ? this._endDraw(t3) : (_a6 = __privateGet(_DrawingEditor, _Ir)) == null ? void 0 : _a6.delete(t3.pointerId);
    }, { signal: p2 });
    window.addEventListener("pointercancel", (t3) => {
      var _a6;
      __privateGet(_DrawingEditor, _Pr) === t3.pointerId ? this._currentParent.endDrawingSession() : (_a6 = __privateGet(_DrawingEditor, _Ir)) == null ? void 0 : _a6.delete(t3.pointerId);
    }, { signal: p2 });
    window.addEventListener("pointerdown", (t3) => {
      if (__privateGet(_DrawingEditor, _kr) === t3.pointerType) {
        (__privateGet(_DrawingEditor, _Ir) || __privateSet(_DrawingEditor, _Ir, /* @__PURE__ */ new Set())).add(t3.pointerId);
        if (__privateGet(_DrawingEditor, _Tr).isCancellable()) {
          __privateGet(_DrawingEditor, _Tr).removeLastElement();
          __privateGet(_DrawingEditor, _Tr).isEmpty() ? this._currentParent.endDrawingSession(true) : this._endDraw(null);
        }
      }
    }, { capture: true, passive: false, signal: p2 });
    window.addEventListener("contextmenu", noContextMenu, { signal: p2 });
    n2.addEventListener("pointermove", this._drawMove.bind(this), { signal: p2 });
    n2.addEventListener("touchmove", (t3) => {
      t3.timeStamp === __privateGet(_DrawingEditor, _Rr) && stopEvent(t3);
    }, { signal: p2 });
    t2.toggleDrawing();
    (_a5 = e2._editorUndoBar) == null ? void 0 : _a5.hide();
    if (__privateGet(_DrawingEditor, _Tr)) t2.drawLayer.updateProperties(this._currentDrawId, __privateGet(_DrawingEditor, _Tr).startNew(a2, r2, d2, c2, h2));
    else {
      e2.updateUIForDefaultProperties(this);
      __privateSet(_DrawingEditor, _Tr, this.createDrawerInstance(a2, r2, d2, c2, h2));
      __privateSet(_DrawingEditor, _Dr, this.getDefaultDrawingOptions());
      this._currentParent = t2;
      ({ id: this._currentDrawId } = t2.drawLayer.draw(this._mergeSVGProperties(__privateGet(_DrawingEditor, _Dr).toSVGProperties(), __privateGet(_DrawingEditor, _Tr).defaultSVGProperties), true, false));
    }
  }
  static _drawMove(t2) {
    var _a5;
    __privateSet(_DrawingEditor, _Rr, -1);
    if (!__privateGet(_DrawingEditor, _Tr)) return;
    const { offsetX: e2, offsetY: i2, pointerId: s2 } = t2;
    if (__privateGet(_DrawingEditor, _Pr) === s2) if (((_a5 = __privateGet(_DrawingEditor, _Ir)) == null ? void 0 : _a5.size) >= 1) this._endDraw(t2);
    else {
      this._currentParent.drawLayer.updateProperties(this._currentDrawId, __privateGet(_DrawingEditor, _Tr).add(e2, i2));
      __privateSet(_DrawingEditor, _Rr, t2.timeStamp);
      stopEvent(t2);
    }
  }
  static _cleanup(t2) {
    if (t2) {
      this._currentDrawId = -1;
      this._currentParent = null;
      __privateSet(_DrawingEditor, _Tr, null);
      __privateSet(_DrawingEditor, _Dr, null);
      __privateSet(_DrawingEditor, _kr, null);
      __privateSet(_DrawingEditor, _Rr, NaN);
    }
    if (__privateGet(_DrawingEditor, _Mr)) {
      __privateGet(_DrawingEditor, _Mr).abort();
      __privateSet(_DrawingEditor, _Mr, null);
      __privateSet(_DrawingEditor, _Pr, NaN);
      __privateSet(_DrawingEditor, _Ir, null);
    }
  }
  static _endDraw(t2) {
    const e2 = this._currentParent;
    if (e2) {
      e2.toggleDrawing(true);
      this._cleanup(false);
      (t2 == null ? void 0 : t2.target) === e2.div && e2.drawLayer.updateProperties(this._currentDrawId, __privateGet(_DrawingEditor, _Tr).end(t2.offsetX, t2.offsetY));
      if (this.supportMultipleDrawings) {
        const t3 = __privateGet(_DrawingEditor, _Tr), i2 = this._currentDrawId, s2 = t3.getLastElement();
        e2.addCommands({ cmd: () => {
          e2.drawLayer.updateProperties(i2, t3.setLastElement(s2));
        }, undo: () => {
          e2.drawLayer.updateProperties(i2, t3.removeLastElement());
        }, mustExec: false, type: p.DRAW_STEP });
      } else this.endDrawing(false);
    }
  }
  static endDrawing(t2) {
    const e2 = this._currentParent;
    if (!e2) return null;
    e2.toggleDrawing(true);
    e2.cleanUndoStack(p.DRAW_STEP);
    if (!__privateGet(_DrawingEditor, _Tr).isEmpty()) {
      const { pageDimensions: [i2, s2], scale: n2 } = e2, a2 = e2.createAndAddNewEditor({ offsetX: 0, offsetY: 0 }, false, { drawId: this._currentDrawId, drawOutlines: __privateGet(_DrawingEditor, _Tr).getOutlines(i2 * n2, s2 * n2, n2, this._INNER_MARGIN), drawingOptions: __privateGet(_DrawingEditor, _Dr), mustBeCommitted: !t2 });
      this._cleanup(true);
      return a2;
    }
    e2.drawLayer.remove(this._currentDrawId);
    this._cleanup(true);
    return null;
  }
  createDrawingOptions(t2) {
  }
  static deserializeDraw(t2, e2, i2, s2, n2, a2) {
    unreachable("Not implemented");
  }
  static async deserialize(t2, e2, i2) {
    var _a5, _b;
    const { rawDims: { pageWidth: s2, pageHeight: n2, pageX: a2, pageY: r2 } } = e2.viewport, o2 = this.deserializeDraw(a2, r2, s2, n2, this._INNER_MARGIN, t2), l2 = await super.deserialize(t2, e2, i2);
    l2.createDrawingOptions(t2);
    __privateMethod(_a5 = l2, _DrawingEditor_instances, Fr_fn).call(_a5, { drawOutlines: o2 });
    __privateMethod(_b = l2, _DrawingEditor_instances, cr_fn2).call(_b);
    l2.onScaleChanging();
    l2.rotate();
    return l2;
  }
  serializeDraw(t2) {
    const [e2, i2] = this.pageTranslation, [s2, n2] = this.pageDimensions;
    return __privateGet(this, _Sr).serialize([e2, i2, s2, n2], t2);
  }
  renderAnnotationElement(t2) {
    t2.updateEdited({ rect: this.getRect(0, 0) });
    return null;
  }
  static canCreateNewEmptyEditor() {
    return false;
  }
};
_Sr = new WeakMap();
_Cr = new WeakMap();
_Tr = new WeakMap();
_Mr = new WeakMap();
_Dr = new WeakMap();
_Pr = new WeakMap();
_kr = new WeakMap();
_Ir = new WeakMap();
_Rr = new WeakMap();
_DrawingEditor_instances = new WeakSet();
Fr_fn = function({ drawOutlines: t2, drawId: e2, drawingOptions: i2 }) {
  __privateSet(this, _Sr, t2);
  this._drawingOptions || (this._drawingOptions = i2);
  if (e2 >= 0) {
    this._drawId = e2;
    this.parent.drawLayer.finalizeDraw(e2, t2.defaultProperties);
  } else this._drawId = __privateMethod(this, _DrawingEditor_instances, Lr_fn).call(this, t2, this.parent);
  __privateMethod(this, _DrawingEditor_instances, Or_fn).call(this, t2.box);
};
Lr_fn = function(t2, e2) {
  const { id: i2 } = e2.drawLayer.draw(_DrawingEditor._mergeSVGProperties(this._drawingOptions.toSVGProperties(), t2.defaultSVGProperties), false, false);
  return i2;
};
br_fn2 = function() {
  if (null !== this._drawId && this.parent) {
    this.parent.drawLayer.remove(this._drawId);
    this._drawId = null;
    this._drawingOptions.reset();
  }
};
cr_fn2 = function(t2 = this.parent) {
  if (null === this._drawId || this.parent !== t2) if (null === this._drawId) {
    this._drawingOptions.updateAll();
    this._drawId = __privateMethod(this, _DrawingEditor_instances, Lr_fn).call(this, __privateGet(this, _Sr), t2);
  } else this.parent.drawLayer.updateParent(this._drawId, t2.drawLayer);
};
Hr_fn = function([t2, e2, i2, s2]) {
  const { parentDimensions: [n2, a2], rotation: r2 } = this;
  switch (r2) {
    case 90:
      return [e2, 1 - t2, i2 * (a2 / n2), s2 * (n2 / a2)];
    case 180:
      return [1 - t2, 1 - e2, i2, s2];
    case 270:
      return [1 - e2, t2, i2 * (a2 / n2), s2 * (n2 / a2)];
    default:
      return [t2, e2, i2, s2];
  }
};
Nr_fn = function() {
  const { x: t2, y: e2, width: i2, height: s2, parentDimensions: [n2, a2], rotation: r2 } = this;
  switch (r2) {
    case 90:
      return [1 - e2, t2, i2 * (n2 / a2), s2 * (a2 / n2)];
    case 180:
      return [1 - t2, 1 - e2, i2, s2];
    case 270:
      return [e2, 1 - t2, i2 * (n2 / a2), s2 * (a2 / n2)];
    default:
      return [t2, e2, i2, s2];
  }
};
Or_fn = function(t2) {
  [this.x, this.y, this.width, this.height] = __privateMethod(this, _DrawingEditor_instances, Hr_fn).call(this, t2);
  if (this.div) {
    this.fixAndSetPosition();
    const [t3, e2] = this.parentDimensions;
    this.setDims(this.width * t3, this.height * e2);
  }
  this._onResized();
};
Br_fn = function() {
  const { x: t2, y: e2, width: i2, height: s2, rotation: n2, parentRotation: a2, parentDimensions: [r2, o2] } = this;
  switch ((4 * n2 + a2) / 90) {
    case 1:
      return [1 - e2 - s2, t2, s2, i2];
    case 2:
      return [1 - t2 - i2, 1 - e2 - s2, i2, s2];
    case 3:
      return [e2, 1 - t2 - i2, s2, i2];
    case 4:
      return [t2, e2 - i2 * (r2 / o2), s2 * (o2 / r2), i2 * (r2 / o2)];
    case 5:
      return [1 - e2, t2, i2 * (r2 / o2), s2 * (o2 / r2)];
    case 6:
      return [1 - t2 - s2 * (o2 / r2), 1 - e2, s2 * (o2 / r2), i2 * (r2 / o2)];
    case 7:
      return [e2 - i2 * (r2 / o2), 1 - t2 - s2 * (o2 / r2), i2 * (r2 / o2), s2 * (o2 / r2)];
    case 8:
      return [t2 - i2, e2 - s2, i2, s2];
    case 9:
      return [1 - e2, t2 - i2, s2, i2];
    case 10:
      return [1 - t2, 1 - e2, i2, s2];
    case 11:
      return [e2 - s2, 1 - t2, s2, i2];
    case 12:
      return [t2 - s2 * (o2 / r2), e2, s2 * (o2 / r2), i2 * (r2 / o2)];
    case 13:
      return [1 - e2 - i2 * (r2 / o2), t2 - s2 * (o2 / r2), i2 * (r2 / o2), s2 * (o2 / r2)];
    case 14:
      return [1 - t2, 1 - e2 - i2 * (r2 / o2), s2 * (o2 / r2), i2 * (r2 / o2)];
    case 15:
      return [e2, 1 - t2, i2 * (r2 / o2), s2 * (o2 / r2)];
    default:
      return [t2, e2, i2, s2];
  }
};
__publicField(_DrawingEditor, "_currentDrawId", -1);
__publicField(_DrawingEditor, "_currentParent", null);
__privateAdd(_DrawingEditor, _Tr, null);
__privateAdd(_DrawingEditor, _Mr, null);
__privateAdd(_DrawingEditor, _Dr, null);
__privateAdd(_DrawingEditor, _Pr, NaN);
__privateAdd(_DrawingEditor, _kr, null);
__privateAdd(_DrawingEditor, _Ir, null);
__privateAdd(_DrawingEditor, _Rr, NaN);
__publicField(_DrawingEditor, "_INNER_MARGIN", 3);
var DrawingEditor = _DrawingEditor;
var _ra2, _Mn2, _Ur, _as2, _ua3, _pa3, _zr, _Gr, _La2, _$r, _Wr, _InkDrawOutliner_instances, Vr_fn;
var InkDrawOutliner = class {
  constructor(t2, e2, i2, s2, n2, a2) {
    __privateAdd(this, _InkDrawOutliner_instances);
    __privateAdd(this, _ra2, new Float64Array(6));
    __privateAdd(this, _Mn2);
    __privateAdd(this, _Ur);
    __privateAdd(this, _as2);
    __privateAdd(this, _ua3);
    __privateAdd(this, _pa3);
    __privateAdd(this, _zr, "");
    __privateAdd(this, _Gr, 0);
    __privateAdd(this, _La2, new InkDrawOutline());
    __privateAdd(this, _$r);
    __privateAdd(this, _Wr);
    __privateSet(this, _$r, i2);
    __privateSet(this, _Wr, s2);
    __privateSet(this, _as2, n2);
    __privateSet(this, _ua3, a2);
    [t2, e2] = __privateMethod(this, _InkDrawOutliner_instances, Vr_fn).call(this, t2, e2);
    const r2 = __privateSet(this, _Mn2, [NaN, NaN, NaN, NaN, t2, e2]);
    __privateSet(this, _pa3, [t2, e2]);
    __privateSet(this, _Ur, [{ line: r2, points: __privateGet(this, _pa3) }]);
    __privateGet(this, _ra2).set(r2, 0);
  }
  updateProperty(t2, e2) {
    "stroke-width" === t2 && __privateSet(this, _ua3, e2);
  }
  isEmpty() {
    return !__privateGet(this, _Ur) || 0 === __privateGet(this, _Ur).length;
  }
  isCancellable() {
    return __privateGet(this, _pa3).length <= 10;
  }
  add(t2, e2) {
    [t2, e2] = __privateMethod(this, _InkDrawOutliner_instances, Vr_fn).call(this, t2, e2);
    const [i2, s2, n2, a2] = __privateGet(this, _ra2).subarray(2, 6), r2 = t2 - n2, o2 = e2 - a2;
    if (Math.hypot(__privateGet(this, _$r) * r2, __privateGet(this, _Wr) * o2) <= 2) return null;
    __privateGet(this, _pa3).push(t2, e2);
    if (isNaN(i2)) {
      __privateGet(this, _ra2).set([n2, a2, t2, e2], 2);
      __privateGet(this, _Mn2).push(NaN, NaN, NaN, NaN, t2, e2);
      return { path: { d: this.toSVGPath() } };
    }
    isNaN(__privateGet(this, _ra2)[0]) && __privateGet(this, _Mn2).splice(6, 6);
    __privateGet(this, _ra2).set([i2, s2, n2, a2, t2, e2], 0);
    __privateGet(this, _Mn2).push(...Outline.createBezierPoints(i2, s2, n2, a2, t2, e2));
    return { path: { d: this.toSVGPath() } };
  }
  end(t2, e2) {
    const i2 = this.add(t2, e2);
    return i2 || (2 === __privateGet(this, _pa3).length ? { path: { d: this.toSVGPath() } } : null);
  }
  startNew(t2, e2, i2, s2, n2) {
    __privateSet(this, _$r, i2);
    __privateSet(this, _Wr, s2);
    __privateSet(this, _as2, n2);
    [t2, e2] = __privateMethod(this, _InkDrawOutliner_instances, Vr_fn).call(this, t2, e2);
    const a2 = __privateSet(this, _Mn2, [NaN, NaN, NaN, NaN, t2, e2]);
    __privateSet(this, _pa3, [t2, e2]);
    const r2 = __privateGet(this, _Ur).at(-1);
    if (r2) {
      r2.line = new Float32Array(r2.line);
      r2.points = new Float32Array(r2.points);
    }
    __privateGet(this, _Ur).push({ line: a2, points: __privateGet(this, _pa3) });
    __privateGet(this, _ra2).set(a2, 0);
    __privateSet(this, _Gr, 0);
    this.toSVGPath();
    return null;
  }
  getLastElement() {
    return __privateGet(this, _Ur).at(-1);
  }
  setLastElement(t2) {
    if (!__privateGet(this, _Ur)) return __privateGet(this, _La2).setLastElement(t2);
    __privateGet(this, _Ur).push(t2);
    __privateSet(this, _Mn2, t2.line);
    __privateSet(this, _pa3, t2.points);
    __privateSet(this, _Gr, 0);
    return { path: { d: this.toSVGPath() } };
  }
  removeLastElement() {
    if (!__privateGet(this, _Ur)) return __privateGet(this, _La2).removeLastElement();
    __privateGet(this, _Ur).pop();
    __privateSet(this, _zr, "");
    for (let t2 = 0, e2 = __privateGet(this, _Ur).length; t2 < e2; t2++) {
      const { line: e3, points: i2 } = __privateGet(this, _Ur)[t2];
      __privateSet(this, _Mn2, e3);
      __privateSet(this, _pa3, i2);
      __privateSet(this, _Gr, 0);
      this.toSVGPath();
    }
    return { path: { d: __privateGet(this, _zr) } };
  }
  toSVGPath() {
    const t2 = Outline.svgRound(__privateGet(this, _Mn2)[4]), e2 = Outline.svgRound(__privateGet(this, _Mn2)[5]);
    if (2 === __privateGet(this, _pa3).length) {
      __privateSet(this, _zr, `${__privateGet(this, _zr)} M ${t2} ${e2} Z`);
      return __privateGet(this, _zr);
    }
    if (__privateGet(this, _pa3).length <= 6) {
      const i3 = __privateGet(this, _zr).lastIndexOf("M");
      __privateSet(this, _zr, `${__privateGet(this, _zr).slice(0, i3)} M ${t2} ${e2}`);
      __privateSet(this, _Gr, 6);
    }
    if (4 === __privateGet(this, _pa3).length) {
      const t3 = Outline.svgRound(__privateGet(this, _Mn2)[10]), e3 = Outline.svgRound(__privateGet(this, _Mn2)[11]);
      __privateSet(this, _zr, `${__privateGet(this, _zr)} L ${t3} ${e3}`);
      __privateSet(this, _Gr, 12);
      return __privateGet(this, _zr);
    }
    const i2 = [];
    if (0 === __privateGet(this, _Gr)) {
      i2.push(`M ${t2} ${e2}`);
      __privateSet(this, _Gr, 6);
    }
    for (let t3 = __privateGet(this, _Gr), e3 = __privateGet(this, _Mn2).length; t3 < e3; t3 += 6) {
      const [e4, s2, n2, a2, r2, o2] = __privateGet(this, _Mn2).slice(t3, t3 + 6).map(Outline.svgRound);
      i2.push(`C${e4} ${s2} ${n2} ${a2} ${r2} ${o2}`);
    }
    __privateSet(this, _zr, __privateGet(this, _zr) + i2.join(" "));
    __privateSet(this, _Gr, __privateGet(this, _Mn2).length);
    return __privateGet(this, _zr);
  }
  getOutlines(t2, e2, i2, s2) {
    const n2 = __privateGet(this, _Ur).at(-1);
    n2.line = new Float32Array(n2.line);
    n2.points = new Float32Array(n2.points);
    __privateGet(this, _La2).build(__privateGet(this, _Ur), t2, e2, i2, __privateGet(this, _as2), __privateGet(this, _ua3), s2);
    __privateSet(this, _ra2, null);
    __privateSet(this, _Mn2, null);
    __privateSet(this, _Ur, null);
    __privateSet(this, _zr, null);
    return __privateGet(this, _La2);
  }
  get defaultSVGProperties() {
    return { root: { viewBox: "0 0 10000 10000" }, rootClass: { draw: true }, bbox: [0, 0, 1, 1] };
  }
};
_ra2 = new WeakMap();
_Mn2 = new WeakMap();
_Ur = new WeakMap();
_as2 = new WeakMap();
_ua3 = new WeakMap();
_pa3 = new WeakMap();
_zr = new WeakMap();
_Gr = new WeakMap();
_La2 = new WeakMap();
_$r = new WeakMap();
_Wr = new WeakMap();
_InkDrawOutliner_instances = new WeakSet();
Vr_fn = function(t2, e2) {
  return Outline._normalizePoint(t2, e2, __privateGet(this, _$r), __privateGet(this, _Wr), __privateGet(this, _as2));
};
var __a2, _jr, _sa3, _Ur2, _$r2, _Wr2, _qr, _as3, _ua4, _InkDrawOutline_instances, Yr_fn, Kr_fn, Xr_fn, gr_fn2;
var InkDrawOutline = class extends Outline {
  constructor() {
    super(...arguments);
    __privateAdd(this, _InkDrawOutline_instances);
    __privateAdd(this, __a2);
    __privateAdd(this, _jr, 0);
    __privateAdd(this, _sa3);
    __privateAdd(this, _Ur2);
    __privateAdd(this, _$r2);
    __privateAdd(this, _Wr2);
    __privateAdd(this, _qr);
    __privateAdd(this, _as3);
    __privateAdd(this, _ua4);
  }
  build(t2, e2, i2, s2, n2, a2, r2) {
    __privateSet(this, _$r2, e2);
    __privateSet(this, _Wr2, i2);
    __privateSet(this, _qr, s2);
    __privateSet(this, _as3, n2);
    __privateSet(this, _ua4, a2);
    __privateSet(this, _sa3, r2 ?? 0);
    __privateSet(this, _Ur2, t2);
    __privateMethod(this, _InkDrawOutline_instances, Xr_fn).call(this);
  }
  get thickness() {
    return __privateGet(this, _ua4);
  }
  setLastElement(t2) {
    __privateGet(this, _Ur2).push(t2);
    return { path: { d: this.toSVGPath() } };
  }
  removeLastElement() {
    __privateGet(this, _Ur2).pop();
    return { path: { d: this.toSVGPath() } };
  }
  toSVGPath() {
    const t2 = [];
    for (const { line: e2 } of __privateGet(this, _Ur2)) {
      t2.push(`M${Outline.svgRound(e2[4])} ${Outline.svgRound(e2[5])}`);
      if (6 !== e2.length) if (12 === e2.length && isNaN(e2[6])) t2.push(`L${Outline.svgRound(e2[10])} ${Outline.svgRound(e2[11])}`);
      else for (let i2 = 6, s2 = e2.length; i2 < s2; i2 += 6) {
        const [s3, n2, a2, r2, o2, l2] = e2.subarray(i2, i2 + 6).map(Outline.svgRound);
        t2.push(`C${s3} ${n2} ${a2} ${r2} ${o2} ${l2}`);
      }
      else t2.push("Z");
    }
    return t2.join("");
  }
  serialize([t2, e2, i2, s2], n2) {
    const a2 = [], r2 = [], [o2, l2, h2, d2] = __privateMethod(this, _InkDrawOutline_instances, Kr_fn).call(this);
    let c2, u2, p2, g2, f2, m2, b2, A2, w2;
    switch (__privateGet(this, _as3)) {
      case 0:
        w2 = Outline._rescale;
        c2 = t2;
        u2 = e2 + s2;
        p2 = i2;
        g2 = -s2;
        f2 = t2 + o2 * i2;
        m2 = e2 + (1 - l2 - d2) * s2;
        b2 = t2 + (o2 + h2) * i2;
        A2 = e2 + (1 - l2) * s2;
        break;
      case 90:
        w2 = Outline._rescaleAndSwap;
        c2 = t2;
        u2 = e2;
        p2 = i2;
        g2 = s2;
        f2 = t2 + l2 * i2;
        m2 = e2 + o2 * s2;
        b2 = t2 + (l2 + d2) * i2;
        A2 = e2 + (o2 + h2) * s2;
        break;
      case 180:
        w2 = Outline._rescale;
        c2 = t2 + i2;
        u2 = e2;
        p2 = -i2;
        g2 = s2;
        f2 = t2 + (1 - o2 - h2) * i2;
        m2 = e2 + l2 * s2;
        b2 = t2 + (1 - o2) * i2;
        A2 = e2 + (l2 + d2) * s2;
        break;
      case 270:
        w2 = Outline._rescaleAndSwap;
        c2 = t2 + i2;
        u2 = e2 + s2;
        p2 = -i2;
        g2 = -s2;
        f2 = t2 + (1 - l2 - d2) * i2;
        m2 = e2 + (1 - o2 - h2) * s2;
        b2 = t2 + (1 - l2) * i2;
        A2 = e2 + (1 - o2) * s2;
    }
    for (const { line: t3, points: e3 } of __privateGet(this, _Ur2)) {
      a2.push(w2(t3, c2, u2, p2, g2, n2 ? new Array(t3.length) : null));
      r2.push(w2(e3, c2, u2, p2, g2, n2 ? new Array(e3.length) : null));
    }
    return { lines: a2, points: r2, rect: [f2, m2, b2, A2] };
  }
  static deserialize(t2, e2, i2, s2, n2, { paths: { lines: a2, points: r2 }, rotation: o2, thickness: l2 }) {
    const h2 = [];
    let d2, c2, u2, p2, g2;
    switch (o2) {
      case 0:
        g2 = Outline._rescale;
        d2 = -t2 / i2;
        c2 = e2 / s2 + 1;
        u2 = 1 / i2;
        p2 = -1 / s2;
        break;
      case 90:
        g2 = Outline._rescaleAndSwap;
        d2 = -e2 / s2;
        c2 = -t2 / i2;
        u2 = 1 / s2;
        p2 = 1 / i2;
        break;
      case 180:
        g2 = Outline._rescale;
        d2 = t2 / i2 + 1;
        c2 = -e2 / s2;
        u2 = -1 / i2;
        p2 = 1 / s2;
        break;
      case 270:
        g2 = Outline._rescaleAndSwap;
        d2 = e2 / s2 + 1;
        c2 = t2 / i2 + 1;
        u2 = -1 / s2;
        p2 = -1 / i2;
    }
    if (!a2) {
      a2 = [];
      for (const t3 of r2) {
        const e3 = t3.length;
        if (2 === e3) {
          a2.push(new Float32Array([NaN, NaN, NaN, NaN, t3[0], t3[1]]));
          continue;
        }
        if (4 === e3) {
          a2.push(new Float32Array([NaN, NaN, NaN, NaN, t3[0], t3[1], NaN, NaN, NaN, NaN, t3[2], t3[3]]));
          continue;
        }
        const i3 = new Float32Array(3 * (e3 - 2));
        a2.push(i3);
        let [s3, n3, r3, o3] = t3.subarray(0, 4);
        i3.set([NaN, NaN, NaN, NaN, s3, n3], 0);
        for (let a3 = 4; a3 < e3; a3 += 2) {
          const e4 = t3[a3], l3 = t3[a3 + 1];
          i3.set(Outline.createBezierPoints(s3, n3, r3, o3, e4, l3), 3 * (a3 - 2));
          [s3, n3, r3, o3] = [r3, o3, e4, l3];
        }
      }
    }
    for (let t3 = 0, e3 = a2.length; t3 < e3; t3++) h2.push({ line: g2(a2[t3].map((t4) => t4 ?? NaN), d2, c2, u2, p2), points: g2(r2[t3].map((t4) => t4 ?? NaN), d2, c2, u2, p2) });
    const f2 = new this.prototype.constructor();
    f2.build(h2, i2, s2, 1, o2, l2, n2);
    return f2;
  }
  get box() {
    return __privateGet(this, __a2);
  }
  updateProperty(t2, e2) {
    return "stroke-width" === t2 ? __privateMethod(this, _InkDrawOutline_instances, gr_fn2).call(this, e2) : null;
  }
  updateParentDimensions([t2, e2], i2) {
    const [s2, n2] = __privateMethod(this, _InkDrawOutline_instances, Yr_fn).call(this);
    __privateSet(this, _$r2, t2);
    __privateSet(this, _Wr2, e2);
    __privateSet(this, _qr, i2);
    const [a2, r2] = __privateMethod(this, _InkDrawOutline_instances, Yr_fn).call(this), o2 = a2 - s2, l2 = r2 - n2, h2 = __privateGet(this, __a2);
    h2[0] -= o2;
    h2[1] -= l2;
    h2[2] += 2 * o2;
    h2[3] += 2 * l2;
    return h2;
  }
  updateRotation(t2) {
    __privateSet(this, _jr, t2);
    return { path: { transform: this.rotationTransform } };
  }
  get viewBox() {
    return __privateGet(this, __a2).map(Outline.svgRound).join(" ");
  }
  get defaultProperties() {
    const [t2, e2] = __privateGet(this, __a2);
    return { root: { viewBox: this.viewBox }, path: { "transform-origin": `${Outline.svgRound(t2)} ${Outline.svgRound(e2)}` } };
  }
  get rotationTransform() {
    const [, , t2, e2] = __privateGet(this, __a2);
    let i2 = 0, s2 = 0, n2 = 0, a2 = 0, r2 = 0, o2 = 0;
    switch (__privateGet(this, _jr)) {
      case 90:
        s2 = e2 / t2;
        n2 = -t2 / e2;
        r2 = t2;
        break;
      case 180:
        i2 = -1;
        a2 = -1;
        r2 = t2;
        o2 = e2;
        break;
      case 270:
        s2 = -e2 / t2;
        n2 = t2 / e2;
        o2 = e2;
        break;
      default:
        return "";
    }
    return `matrix(${i2} ${s2} ${n2} ${a2} ${Outline.svgRound(r2)} ${Outline.svgRound(o2)})`;
  }
  getPathResizingSVGProperties([t2, e2, i2, s2]) {
    const [n2, a2] = __privateMethod(this, _InkDrawOutline_instances, Yr_fn).call(this), [r2, o2, l2, h2] = __privateGet(this, __a2);
    if (Math.abs(l2 - n2) <= Outline.PRECISION || Math.abs(h2 - a2) <= Outline.PRECISION) {
      const n3 = t2 + i2 / 2 - (r2 + l2 / 2), a3 = e2 + s2 / 2 - (o2 + h2 / 2);
      return { path: { "transform-origin": `${Outline.svgRound(t2)} ${Outline.svgRound(e2)}`, transform: `${this.rotationTransform} translate(${n3} ${a3})` } };
    }
    const d2 = (i2 - 2 * n2) / (l2 - 2 * n2), c2 = (s2 - 2 * a2) / (h2 - 2 * a2), u2 = l2 / i2, p2 = h2 / s2;
    return { path: { "transform-origin": `${Outline.svgRound(r2)} ${Outline.svgRound(o2)}`, transform: `${this.rotationTransform} scale(${u2} ${p2}) translate(${Outline.svgRound(n2)} ${Outline.svgRound(a2)}) scale(${d2} ${c2}) translate(${Outline.svgRound(-n2)} ${Outline.svgRound(-a2)})` } };
  }
  getPathResizedSVGProperties([t2, e2, i2, s2]) {
    const [n2, a2] = __privateMethod(this, _InkDrawOutline_instances, Yr_fn).call(this), r2 = __privateGet(this, __a2), [o2, l2, h2, d2] = r2;
    r2[0] = t2;
    r2[1] = e2;
    r2[2] = i2;
    r2[3] = s2;
    if (Math.abs(h2 - n2) <= Outline.PRECISION || Math.abs(d2 - a2) <= Outline.PRECISION) {
      const n3 = t2 + i2 / 2 - (o2 + h2 / 2), a3 = e2 + s2 / 2 - (l2 + d2 / 2);
      for (const { line: t3, points: e3 } of __privateGet(this, _Ur2)) {
        Outline._translate(t3, n3, a3, t3);
        Outline._translate(e3, n3, a3, e3);
      }
      return { root: { viewBox: this.viewBox }, path: { "transform-origin": `${Outline.svgRound(t2)} ${Outline.svgRound(e2)}`, transform: this.rotationTransform || null, d: this.toSVGPath() } };
    }
    const c2 = (i2 - 2 * n2) / (h2 - 2 * n2), u2 = (s2 - 2 * a2) / (d2 - 2 * a2), p2 = -c2 * (o2 + n2) + t2 + n2, g2 = -u2 * (l2 + a2) + e2 + a2;
    if (1 !== c2 || 1 !== u2 || 0 !== p2 || 0 !== g2) for (const { line: t3, points: e3 } of __privateGet(this, _Ur2)) {
      Outline._rescale(t3, p2, g2, c2, u2, t3);
      Outline._rescale(e3, p2, g2, c2, u2, e3);
    }
    return { root: { viewBox: this.viewBox }, path: { "transform-origin": `${Outline.svgRound(t2)} ${Outline.svgRound(e2)}`, transform: this.rotationTransform || null, d: this.toSVGPath() } };
  }
  getPathTranslatedSVGProperties([t2, e2], i2) {
    const [s2, n2] = i2, a2 = __privateGet(this, __a2), r2 = t2 - a2[0], o2 = e2 - a2[1];
    if (__privateGet(this, _$r2) === s2 && __privateGet(this, _Wr2) === n2) for (const { line: t3, points: e3 } of __privateGet(this, _Ur2)) {
      Outline._translate(t3, r2, o2, t3);
      Outline._translate(e3, r2, o2, e3);
    }
    else {
      const t3 = __privateGet(this, _$r2) / s2, e3 = __privateGet(this, _Wr2) / n2;
      __privateSet(this, _$r2, s2);
      __privateSet(this, _Wr2, n2);
      for (const { line: i3, points: s3 } of __privateGet(this, _Ur2)) {
        Outline._rescale(i3, r2, o2, t3, e3, i3);
        Outline._rescale(s3, r2, o2, t3, e3, s3);
      }
      a2[2] *= t3;
      a2[3] *= e3;
    }
    a2[0] = t2;
    a2[1] = e2;
    return { root: { viewBox: this.viewBox }, path: { d: this.toSVGPath(), "transform-origin": `${Outline.svgRound(t2)} ${Outline.svgRound(e2)}` } };
  }
  get defaultSVGProperties() {
    const t2 = __privateGet(this, __a2);
    return { root: { viewBox: this.viewBox }, rootClass: { draw: true }, path: { d: this.toSVGPath(), "transform-origin": `${Outline.svgRound(t2[0])} ${Outline.svgRound(t2[1])}`, transform: this.rotationTransform || null }, bbox: t2 };
  }
};
__a2 = new WeakMap();
_jr = new WeakMap();
_sa3 = new WeakMap();
_Ur2 = new WeakMap();
_$r2 = new WeakMap();
_Wr2 = new WeakMap();
_qr = new WeakMap();
_as3 = new WeakMap();
_ua4 = new WeakMap();
_InkDrawOutline_instances = new WeakSet();
Yr_fn = function(t2 = __privateGet(this, _ua4)) {
  const e2 = __privateGet(this, _sa3) + t2 / 2 * __privateGet(this, _qr);
  return __privateGet(this, _as3) % 180 == 0 ? [e2 / __privateGet(this, _$r2), e2 / __privateGet(this, _Wr2)] : [e2 / __privateGet(this, _Wr2), e2 / __privateGet(this, _$r2)];
};
Kr_fn = function() {
  const [t2, e2, i2, s2] = __privateGet(this, __a2), [n2, a2] = __privateMethod(this, _InkDrawOutline_instances, Yr_fn).call(this, 0);
  return [t2 + n2, e2 + a2, i2 - 2 * n2, s2 - 2 * a2];
};
Xr_fn = function() {
  const t2 = __privateSet(this, __a2, new Float32Array([1 / 0, 1 / 0, -1 / 0, -1 / 0]));
  for (const { line: e3 } of __privateGet(this, _Ur2)) {
    if (e3.length <= 12) {
      for (let i4 = 4, s3 = e3.length; i4 < s3; i4 += 6) Util.pointBoundingBox(e3[i4], e3[i4 + 1], t2);
      continue;
    }
    let i3 = e3[4], s2 = e3[5];
    for (let n2 = 6, a2 = e3.length; n2 < a2; n2 += 6) {
      const [a3, r2, o2, l2, h2, d2] = e3.subarray(n2, n2 + 6);
      Util.bezierBoundingBox(i3, s2, a3, r2, o2, l2, h2, d2, t2);
      i3 = h2;
      s2 = d2;
    }
  }
  const [e2, i2] = __privateMethod(this, _InkDrawOutline_instances, Yr_fn).call(this);
  t2[0] = MathClamp(t2[0] - e2, 0, 1);
  t2[1] = MathClamp(t2[1] - i2, 0, 1);
  t2[2] = MathClamp(t2[2] + e2, 0, 1);
  t2[3] = MathClamp(t2[3] + i2, 0, 1);
  t2[2] -= t2[0];
  t2[3] -= t2[1];
};
gr_fn2 = function(t2) {
  const [e2, i2] = __privateMethod(this, _InkDrawOutline_instances, Yr_fn).call(this);
  __privateSet(this, _ua4, t2);
  const [s2, n2] = __privateMethod(this, _InkDrawOutline_instances, Yr_fn).call(this), [a2, r2] = [s2 - e2, n2 - i2], o2 = __privateGet(this, __a2);
  o2[0] -= a2;
  o2[1] -= r2;
  o2[2] += 2 * a2;
  o2[3] += 2 * r2;
  return o2;
};
var InkDrawingOptions = class _InkDrawingOptions extends DrawingOptions {
  constructor(t2) {
    super();
    this._viewParameters = t2;
    super.updateProperties({ fill: "none", stroke: AnnotationEditor._defaultLineColor, "stroke-opacity": 1, "stroke-width": 1, "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-miterlimit": 10 });
  }
  updateSVGProperty(t2, e2) {
    if ("stroke-width" === t2) {
      e2 ?? (e2 = this["stroke-width"]);
      e2 *= this._viewParameters.realScale;
    }
    super.updateSVGProperty(t2, e2);
  }
  clone() {
    const t2 = new _InkDrawingOptions(this._viewParameters);
    t2.updateAll(this);
    return t2;
  }
};
var _InkEditor_instances, ta_fn3;
var _InkEditor = class _InkEditor extends DrawingEditor {
  constructor(t2) {
    super({ ...t2, name: "inkEditor" });
    __privateAdd(this, _InkEditor_instances);
    this._willKeepAspectRatio = true;
    this.defaultL10nId = "pdfjs-editor-ink-editor";
  }
  static initialize(t2, e2) {
    AnnotationEditor.initialize(t2, e2);
    this._defaultDrawingOptions = new InkDrawingOptions(e2.viewParameters);
  }
  static getDefaultDrawingOptions(t2) {
    const e2 = this._defaultDrawingOptions.clone();
    e2.updateProperties(t2);
    return e2;
  }
  static get supportMultipleDrawings() {
    return true;
  }
  static get typesMap() {
    return shadow(this, "typesMap", /* @__PURE__ */ new Map([[p.INK_THICKNESS, "stroke-width"], [p.INK_COLOR, "stroke"], [p.INK_OPACITY, "stroke-opacity"]]));
  }
  static createDrawerInstance(t2, e2, i2, s2, n2) {
    return new InkDrawOutliner(t2, e2, i2, s2, n2, this._defaultDrawingOptions["stroke-width"]);
  }
  static deserializeDraw(t2, e2, i2, s2, n2, a2) {
    return InkDrawOutline.deserialize(t2, e2, i2, s2, n2, a2);
  }
  static async deserialize(t2, e2, i2) {
    let s2 = null;
    if (t2 instanceof InkAnnotationElement) {
      const { data: { inkLists: e3, rect: i3, rotation: n3, id: a2, color: r2, opacity: o2, borderStyle: { rawWidth: l2 }, popupRef: h2 }, parent: { page: { pageNumber: d2 } } } = t2;
      s2 = t2 = { annotationType: u.INK, color: Array.from(r2), thickness: l2, opacity: o2, paths: { points: e3 }, boxes: null, pageIndex: d2 - 1, rect: i3.slice(0), rotation: n3, id: a2, deleted: false, popupRef: h2 };
    }
    const n2 = await super.deserialize(t2, e2, i2);
    n2.annotationElementId = t2.id || null;
    n2._initialData = s2;
    return n2;
  }
  onScaleChanging() {
    if (!this.parent) return;
    super.onScaleChanging();
    const { _drawId: t2, _drawingOptions: e2, parent: i2 } = this;
    e2.updateSVGProperty("stroke-width");
    i2.drawLayer.updateProperties(t2, e2.toSVGProperties());
  }
  static onScaleChangingWhenDrawing() {
    const t2 = this._currentParent;
    if (t2) {
      super.onScaleChangingWhenDrawing();
      this._defaultDrawingOptions.updateSVGProperty("stroke-width");
      t2.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());
    }
  }
  createDrawingOptions({ color: t2, thickness: e2, opacity: i2 }) {
    this._drawingOptions = _InkEditor.getDefaultDrawingOptions({ stroke: Util.makeHexColor(...t2), "stroke-width": e2, "stroke-opacity": i2 });
  }
  serialize(t2 = false) {
    if (this.isEmpty()) return null;
    if (this.deleted) return this.serializeDeleted();
    const { lines: e2, points: i2, rect: s2 } = this.serializeDraw(t2), { _drawingOptions: { stroke: n2, "stroke-opacity": a2, "stroke-width": r2 } } = this, o2 = { annotationType: u.INK, color: AnnotationEditor._colorManager.convert(n2), opacity: a2, thickness: r2, paths: { lines: e2, points: i2 }, pageIndex: this.pageIndex, rect: s2, rotation: this.rotation, structTreeParentId: this._structTreeParentId };
    if (t2) {
      o2.isCopy = true;
      return o2;
    }
    if (this.annotationElementId && !__privateMethod(this, _InkEditor_instances, ta_fn3).call(this, o2)) return null;
    o2.id = this.annotationElementId;
    return o2;
  }
  renderAnnotationElement(t2) {
    const { points: e2, rect: i2 } = this.serializeDraw(false);
    t2.updateEdited({ rect: i2, thickness: this._drawingOptions["stroke-width"], points: e2 });
    return null;
  }
};
_InkEditor_instances = new WeakSet();
ta_fn3 = function(t2) {
  const { color: e2, thickness: i2, opacity: s2, pageIndex: n2 } = this._initialData;
  return this._hasBeenMoved || this._hasBeenResized || t2.color.some((t3, i3) => t3 !== e2[i3]) || t2.thickness !== i2 || t2.opacity !== s2 || t2.pageIndex !== n2;
};
__publicField(_InkEditor, "_type", "ink");
__publicField(_InkEditor, "_editorType", u.INK);
__publicField(_InkEditor, "_defaultDrawingOptions", null);
var InkEditor = _InkEditor;
var ContourDrawOutline = class extends InkDrawOutline {
  toSVGPath() {
    let t2 = super.toSVGPath();
    t2.endsWith("Z") || (t2 += "Z");
    return t2;
  }
};
var _Qr, _SignatureExtractor_static, Jr_fn, _Zr, to_fn, eo_fn, io_fn, so_fn, no_fn, ao_fn, ro_fn, oo_fn, lo_fn, ho_fn;
var SignatureExtractor = class {
  static extractContoursFromText(t2, { fontFamily: e2, fontStyle: i2, fontWeight: s2 }, n2, a2, r2, o2) {
    let l2 = new OffscreenCanvas(1, 1), h2 = l2.getContext("2d", { alpha: false });
    const d2 = h2.font = `${i2} ${s2} 200px ${e2}`, { actualBoundingBoxLeft: c2, actualBoundingBoxRight: u2, actualBoundingBoxAscent: p2, actualBoundingBoxDescent: g2, fontBoundingBoxAscent: f2, fontBoundingBoxDescent: m2, width: b2 } = h2.measureText(t2), A2 = 1.5, w2 = Math.ceil(Math.max(Math.abs(c2) + Math.abs(u2) || 0, b2) * A2), y2 = Math.ceil(Math.max(Math.abs(p2) + Math.abs(g2) || 200, Math.abs(f2) + Math.abs(m2) || 200) * A2);
    l2 = new OffscreenCanvas(w2, y2);
    h2 = l2.getContext("2d", { alpha: true, willReadFrequently: true });
    h2.font = d2;
    h2.filter = "grayscale(1)";
    h2.fillStyle = "white";
    h2.fillRect(0, 0, w2, y2);
    h2.fillStyle = "black";
    h2.fillText(t2, 0.5 * w2 / 2, 1.5 * y2 / 2);
    const v2 = __privateMethod(this, _SignatureExtractor_static, oo_fn).call(this, h2.getImageData(0, 0, w2, y2).data), x2 = __privateMethod(this, _SignatureExtractor_static, ro_fn).call(this, v2), E2 = __privateMethod(this, _SignatureExtractor_static, lo_fn).call(this, x2), _2 = __privateMethod(this, _SignatureExtractor_static, io_fn).call(this, v2, w2, y2, E2);
    return this.processDrawnLines({ lines: { curves: _2, width: w2, height: y2 }, pageWidth: n2, pageHeight: a2, rotation: r2, innerMargin: o2, mustSmooth: true, areContours: true });
  }
  static process(t2, e2, i2, s2, n2) {
    const [a2, r2, o2] = __privateMethod(this, _SignatureExtractor_static, ho_fn).call(this, t2), [l2, h2] = __privateMethod(this, _SignatureExtractor_static, ao_fn).call(this, a2, r2, o2, Math.hypot(r2, o2) * __privateGet(this, _Qr).sigmaSFactor, __privateGet(this, _Qr).sigmaR, __privateGet(this, _Qr).kernelSize), d2 = __privateMethod(this, _SignatureExtractor_static, lo_fn).call(this, h2), c2 = __privateMethod(this, _SignatureExtractor_static, io_fn).call(this, l2, r2, o2, d2);
    return this.processDrawnLines({ lines: { curves: c2, width: r2, height: o2 }, pageWidth: e2, pageHeight: i2, rotation: s2, innerMargin: n2, mustSmooth: true, areContours: true });
  }
  static processDrawnLines({ lines: t2, pageWidth: e2, pageHeight: i2, rotation: s2, innerMargin: n2, mustSmooth: a2, areContours: r2 }) {
    s2 % 180 != 0 && ([e2, i2] = [i2, e2]);
    const { curves: o2, width: l2, height: h2 } = t2, d2 = t2.thickness ?? 0, c2 = [], u2 = Math.min(e2 / l2, i2 / h2), p2 = u2 / e2, g2 = u2 / i2, f2 = [];
    for (const { points: t3 } of o2) {
      const e3 = a2 ? __privateMethod(this, _SignatureExtractor_static, no_fn).call(this, t3) : t3;
      if (!e3) continue;
      f2.push(e3);
      const i3 = e3.length, s3 = new Float32Array(i3), n3 = new Float32Array(3 * (2 === i3 ? 2 : i3 - 2));
      c2.push({ line: n3, points: s3 });
      if (2 === i3) {
        s3[0] = e3[0] * p2;
        s3[1] = e3[1] * g2;
        n3.set([NaN, NaN, NaN, NaN, s3[0], s3[1]], 0);
        continue;
      }
      let [r3, o3, l3, h3] = e3;
      r3 *= p2;
      o3 *= g2;
      l3 *= p2;
      h3 *= g2;
      s3.set([r3, o3, l3, h3], 0);
      n3.set([NaN, NaN, NaN, NaN, r3, o3], 0);
      for (let t4 = 4; t4 < i3; t4 += 2) {
        const i4 = s3[t4] = e3[t4] * p2, a3 = s3[t4 + 1] = e3[t4 + 1] * g2;
        n3.set(Outline.createBezierPoints(r3, o3, l3, h3, i4, a3), 3 * (t4 - 2));
        [r3, o3, l3, h3] = [l3, h3, i4, a3];
      }
    }
    if (0 === c2.length) return null;
    const m2 = r2 ? new ContourDrawOutline() : new InkDrawOutline();
    m2.build(c2, e2, i2, 1, s2, r2 ? 0 : d2, n2);
    return { outline: m2, newCurves: f2, areContours: r2, thickness: d2, width: l2, height: h2 };
  }
  static async compressSignature({ outlines: t2, areContours: e2, thickness: i2, width: s2, height: n2 }) {
    let a2, r2 = 1 / 0, o2 = -1 / 0, l2 = 0;
    for (const e3 of t2) {
      l2 += e3.length;
      for (let t3 = 2, i3 = e3.length; t3 < i3; t3++) {
        const i4 = e3[t3] - e3[t3 - 2];
        r2 = Math.min(r2, i4);
        o2 = Math.max(o2, i4);
      }
    }
    a2 = r2 >= -128 && o2 <= 127 ? Int8Array : r2 >= -32768 && o2 <= 32767 ? Int16Array : Int32Array;
    const h2 = t2.length, d2 = 8 + 3 * h2, c2 = new Uint32Array(d2);
    let u2 = 0;
    c2[u2++] = d2 * Uint32Array.BYTES_PER_ELEMENT + (l2 - 2 * h2) * a2.BYTES_PER_ELEMENT;
    c2[u2++] = 0;
    c2[u2++] = s2;
    c2[u2++] = n2;
    c2[u2++] = e2 ? 0 : 1;
    c2[u2++] = Math.max(0, Math.floor(i2 ?? 0));
    c2[u2++] = h2;
    c2[u2++] = a2.BYTES_PER_ELEMENT;
    for (const e3 of t2) {
      c2[u2++] = e3.length - 2;
      c2[u2++] = e3[0];
      c2[u2++] = e3[1];
    }
    const p2 = new CompressionStream("deflate-raw"), g2 = p2.writable.getWriter();
    await g2.ready;
    g2.write(c2);
    const f2 = a2.prototype.constructor;
    for (const e3 of t2) {
      const t3 = new f2(e3.length - 2);
      for (let i3 = 2, s3 = e3.length; i3 < s3; i3++) t3[i3 - 2] = e3[i3] - e3[i3 - 2];
      g2.write(t3);
    }
    g2.close();
    const m2 = await new Response(p2.readable).arrayBuffer();
    return toBase64Util(new Uint8Array(m2));
  }
  static async decompressSignature(t2) {
    try {
      const e2 = function fromBase64Util(t3) {
        return Uint8Array.fromBase64 ? Uint8Array.fromBase64(t3) : stringToBytes(atob(t3));
      }(t2), { readable: i2, writable: s2 } = new DecompressionStream("deflate-raw"), n2 = s2.getWriter();
      await n2.ready;
      n2.write(e2).then(async () => {
        await n2.ready;
        await n2.close();
      }).catch(() => {
      });
      let a2 = null, r2 = 0;
      for await (const t3 of i2) {
        a2 || (a2 = new Uint8Array(new Uint32Array(t3.buffer, 0, 4)[0]));
        a2.set(t3, r2);
        r2 += t3.length;
      }
      const o2 = new Uint32Array(a2.buffer, 0, a2.length >> 2), l2 = o2[1];
      if (0 !== l2) throw new Error(`Invalid version: ${l2}`);
      const h2 = o2[2], d2 = o2[3], c2 = 0 === o2[4], u2 = o2[5], p2 = o2[6], g2 = o2[7], f2 = [], m2 = (8 + 3 * p2) * Uint32Array.BYTES_PER_ELEMENT;
      let b2;
      switch (g2) {
        case Int8Array.BYTES_PER_ELEMENT:
          b2 = new Int8Array(a2.buffer, m2);
          break;
        case Int16Array.BYTES_PER_ELEMENT:
          b2 = new Int16Array(a2.buffer, m2);
          break;
        case Int32Array.BYTES_PER_ELEMENT:
          b2 = new Int32Array(a2.buffer, m2);
      }
      r2 = 0;
      for (let t3 = 0; t3 < p2; t3++) {
        const e3 = o2[3 * t3 + 8], i3 = new Float32Array(e3 + 2);
        f2.push(i3);
        for (let e4 = 0; e4 < 2; e4++) i3[e4] = o2[3 * t3 + 8 + e4 + 1];
        for (let t4 = 0; t4 < e3; t4++) i3[t4 + 2] = i3[t4] + b2[r2++];
      }
      return { areContours: c2, thickness: u2, outlines: f2, width: h2, height: d2 };
    } catch (t3) {
      warn(`decompressSignature: ${t3}`);
      return null;
    }
  }
};
_Qr = new WeakMap();
_SignatureExtractor_static = new WeakSet();
Jr_fn = function(t2, e2, i2, s2) {
  s2 -= e2;
  return 0 === (i2 -= t2) ? s2 > 0 ? 0 : 4 : 1 === i2 ? s2 + 6 : 2 - s2;
};
_Zr = new WeakMap();
to_fn = function(t2, e2, i2, s2, n2, a2, r2) {
  const o2 = __privateMethod(this, _SignatureExtractor_static, Jr_fn).call(this, i2, s2, n2, a2);
  for (let n3 = 0; n3 < 8; n3++) {
    const a3 = (-n3 + o2 - r2 + 16) % 8;
    if (0 !== t2[(i2 + __privateGet(this, _Zr)[2 * a3]) * e2 + (s2 + __privateGet(this, _Zr)[2 * a3 + 1])]) return a3;
  }
  return -1;
};
eo_fn = function(t2, e2, i2, s2, n2, a2, r2) {
  const o2 = __privateMethod(this, _SignatureExtractor_static, Jr_fn).call(this, i2, s2, n2, a2);
  for (let n3 = 0; n3 < 8; n3++) {
    const a3 = (n3 + o2 + r2 + 16) % 8;
    if (0 !== t2[(i2 + __privateGet(this, _Zr)[2 * a3]) * e2 + (s2 + __privateGet(this, _Zr)[2 * a3 + 1])]) return a3;
  }
  return -1;
};
io_fn = function(t2, e2, i2, s2) {
  const n2 = t2.length, a2 = new Int32Array(n2);
  for (let e3 = 0; e3 < n2; e3++) a2[e3] = t2[e3] <= s2 ? 1 : 0;
  for (let t3 = 1; t3 < i2 - 1; t3++) a2[t3 * e2] = a2[t3 * e2 + e2 - 1] = 0;
  for (let t3 = 0; t3 < e2; t3++) a2[t3] = a2[e2 * i2 - 1 - t3] = 0;
  let r2, o2 = 1;
  const l2 = [];
  for (let t3 = 1; t3 < i2 - 1; t3++) {
    r2 = 1;
    for (let i3 = 1; i3 < e2 - 1; i3++) {
      const s3 = t3 * e2 + i3, n3 = a2[s3];
      if (0 === n3) continue;
      let h2 = t3, d2 = i3;
      if (1 === n3 && 0 === a2[s3 - 1]) {
        o2 += 1;
        d2 -= 1;
      } else {
        if (!(n3 >= 1 && 0 === a2[s3 + 1])) {
          1 !== n3 && (r2 = Math.abs(n3));
          continue;
        }
        o2 += 1;
        d2 += 1;
        n3 > 1 && (r2 = n3);
      }
      const c2 = [i3, t3], u2 = d2 === i3 + 1, p2 = { isHole: u2, points: c2, id: o2, parent: 0 };
      l2.push(p2);
      let g2;
      for (const t4 of l2) if (t4.id === r2) {
        g2 = t4;
        break;
      }
      g2 ? g2.isHole ? p2.parent = u2 ? g2.parent : r2 : p2.parent = u2 ? r2 : g2.parent : p2.parent = u2 ? r2 : 0;
      const f2 = __privateMethod(this, _SignatureExtractor_static, to_fn).call(this, a2, e2, t3, i3, h2, d2, 0);
      if (-1 === f2) {
        a2[s3] = -o2;
        1 !== a2[s3] && (r2 = Math.abs(a2[s3]));
        continue;
      }
      let m2 = __privateGet(this, _Zr)[2 * f2], b2 = __privateGet(this, _Zr)[2 * f2 + 1];
      const A2 = t3 + m2, w2 = i3 + b2;
      h2 = A2;
      d2 = w2;
      let y2 = t3, v2 = i3;
      for (; ; ) {
        const n4 = __privateMethod(this, _SignatureExtractor_static, eo_fn).call(this, a2, e2, y2, v2, h2, d2, 1);
        m2 = __privateGet(this, _Zr)[2 * n4];
        b2 = __privateGet(this, _Zr)[2 * n4 + 1];
        const l3 = y2 + m2, u3 = v2 + b2;
        c2.push(u3, l3);
        const p3 = y2 * e2 + v2;
        0 === a2[p3 + 1] ? a2[p3] = -o2 : 1 === a2[p3] && (a2[p3] = o2);
        if (l3 === t3 && u3 === i3 && y2 === A2 && v2 === w2) {
          1 !== a2[s3] && (r2 = Math.abs(a2[s3]));
          break;
        }
        h2 = y2;
        d2 = v2;
        y2 = l3;
        v2 = u3;
      }
    }
  }
  return l2;
};
so_fn = function(t2, e2, i2, s2) {
  if (i2 - e2 <= 4) {
    for (let n3 = e2; n3 < i2 - 2; n3 += 2) s2.push(t2[n3], t2[n3 + 1]);
    return;
  }
  const n2 = t2[e2], a2 = t2[e2 + 1], r2 = t2[i2 - 4] - n2, o2 = t2[i2 - 3] - a2, l2 = Math.hypot(r2, o2), h2 = r2 / l2, d2 = o2 / l2, c2 = h2 * a2 - d2 * n2, u2 = o2 / r2, p2 = 1 / l2, g2 = Math.atan(u2), f2 = Math.cos(g2), m2 = Math.sin(g2), b2 = p2 * (Math.abs(f2) + Math.abs(m2)), A2 = p2 * (1 - b2 + b2 ** 2), w2 = Math.max(Math.atan(Math.abs(m2 + f2) * A2), Math.atan(Math.abs(m2 - f2) * A2));
  let y2 = 0, v2 = e2;
  for (let s3 = e2 + 2; s3 < i2 - 2; s3 += 2) {
    const e3 = Math.abs(c2 - h2 * t2[s3 + 1] + d2 * t2[s3]);
    if (e3 > y2) {
      v2 = s3;
      y2 = e3;
    }
  }
  if (y2 > (l2 * w2) ** 2) {
    __privateMethod(this, _SignatureExtractor_static, so_fn).call(this, t2, e2, v2 + 2, s2);
    __privateMethod(this, _SignatureExtractor_static, so_fn).call(this, t2, v2, i2, s2);
  } else s2.push(n2, a2);
};
no_fn = function(t2) {
  const e2 = [], i2 = t2.length;
  __privateMethod(this, _SignatureExtractor_static, so_fn).call(this, t2, 0, i2, e2);
  e2.push(t2[i2 - 2], t2[i2 - 1]);
  return e2.length <= 4 ? null : e2;
};
ao_fn = function(t2, e2, i2, s2, n2, a2) {
  const r2 = new Float32Array(a2 ** 2), o2 = -2 * s2 ** 2, l2 = a2 >> 1;
  for (let t3 = 0; t3 < a2; t3++) {
    const e3 = (t3 - l2) ** 2;
    for (let i3 = 0; i3 < a2; i3++) r2[t3 * a2 + i3] = Math.exp((e3 + (i3 - l2) ** 2) / o2);
  }
  const h2 = new Float32Array(256), d2 = -2 * n2 ** 2;
  for (let t3 = 0; t3 < 256; t3++) h2[t3] = Math.exp(t3 ** 2 / d2);
  const c2 = t2.length, u2 = new Uint8Array(c2), p2 = new Uint32Array(256);
  for (let s3 = 0; s3 < i2; s3++) for (let n3 = 0; n3 < e2; n3++) {
    const o3 = s3 * e2 + n3, d3 = t2[o3];
    let c3 = 0, g2 = 0;
    for (let o4 = 0; o4 < a2; o4++) {
      const u3 = s3 + o4 - l2;
      if (!(u3 < 0 || u3 >= i2)) for (let i3 = 0; i3 < a2; i3++) {
        const s4 = n3 + i3 - l2;
        if (s4 < 0 || s4 >= e2) continue;
        const p3 = t2[u3 * e2 + s4], f2 = r2[o4 * a2 + i3] * h2[Math.abs(p3 - d3)];
        c3 += p3 * f2;
        g2 += f2;
      }
    }
    p2[u2[o3] = Math.round(c3 / g2)]++;
  }
  return [u2, p2];
};
ro_fn = function(t2) {
  const e2 = new Uint32Array(256);
  for (const i2 of t2) e2[i2]++;
  return e2;
};
oo_fn = function(t2) {
  const e2 = t2.length, i2 = new Uint8ClampedArray(e2 >> 2);
  let s2 = -1 / 0, n2 = 1 / 0;
  for (let e3 = 0, a3 = i2.length; e3 < a3; e3++) {
    if (0 === t2[3 + (e3 << 2)]) {
      s2 = i2[e3] = 255;
      continue;
    }
    const a4 = i2[e3] = t2[e3 << 2];
    a4 > s2 && (s2 = a4);
    a4 < n2 && (n2 = a4);
  }
  const a2 = 255 / (s2 - n2);
  for (let t3 = 0; t3 < e2; t3++) i2[t3] = (i2[t3] - n2) * a2;
  return i2;
};
lo_fn = function(t2) {
  let e2, i2 = -1 / 0, s2 = -1 / 0;
  const n2 = t2.findIndex((t3) => 0 !== t3);
  let a2 = n2, r2 = n2;
  for (e2 = n2; e2 < 256; e2++) {
    const n3 = t2[e2];
    if (n3 > i2) {
      if (e2 - a2 > s2) {
        s2 = e2 - a2;
        r2 = e2 - 1;
      }
      i2 = n3;
      a2 = e2;
    }
  }
  for (e2 = r2 - 1; e2 >= 0 && !(t2[e2] > t2[e2 + 1]); e2--) ;
  return e2;
};
ho_fn = function(t2) {
  const e2 = t2, { width: i2, height: s2 } = t2, { maxDim: n2 } = __privateGet(this, _Qr);
  let a2 = i2, r2 = s2;
  if (i2 > n2 || s2 > n2) {
    let o3 = i2, l3 = s2, h2 = Math.log2(Math.max(i2, s2) / n2);
    const d2 = Math.floor(h2);
    h2 = h2 === d2 ? d2 - 1 : d2;
    for (let i3 = 0; i3 < h2; i3++) {
      a2 = Math.ceil(o3 / 2);
      r2 = Math.ceil(l3 / 2);
      const i4 = new OffscreenCanvas(a2, r2);
      i4.getContext("2d").drawImage(t2, 0, 0, o3, l3, 0, 0, a2, r2);
      o3 = a2;
      l3 = r2;
      t2 !== e2 && t2.close();
      t2 = i4.transferToImageBitmap();
    }
    const c2 = Math.min(n2 / a2, n2 / r2);
    a2 = Math.round(a2 * c2);
    r2 = Math.round(r2 * c2);
  }
  const o2 = new OffscreenCanvas(a2, r2).getContext("2d", { willReadFrequently: true });
  o2.filter = "grayscale(1)";
  o2.drawImage(t2, 0, 0, t2.width, t2.height, 0, 0, a2, r2);
  const l2 = o2.getImageData(0, 0, a2, r2).data;
  return [__privateMethod(this, _SignatureExtractor_static, oo_fn).call(this, l2), a2, r2];
};
__privateAdd(SignatureExtractor, _SignatureExtractor_static);
__privateAdd(SignatureExtractor, _Qr, { maxDim: 512, sigmaSFactor: 0.02, sigmaR: 25, kernelSize: 16 });
__privateAdd(SignatureExtractor, _Zr, new Int32Array([0, 1, -1, 1, -1, 0, -1, -1, 0, -1, 1, -1, 1, 0, 1, 1]));
var SignatureOptions = class _SignatureOptions extends DrawingOptions {
  constructor() {
    super();
    super.updateProperties({ fill: AnnotationEditor._defaultLineColor, "stroke-width": 0 });
  }
  clone() {
    const t2 = new _SignatureOptions();
    t2.updateAll(this);
    return t2;
  }
};
var DrawnSignatureOptions = class _DrawnSignatureOptions extends InkDrawingOptions {
  constructor(t2) {
    super(t2);
    super.updateProperties({ stroke: AnnotationEditor._defaultLineColor, "stroke-width": 1 });
  }
  clone() {
    const t2 = new _DrawnSignatureOptions(this._viewParameters);
    t2.updateAll(this);
    return t2;
  }
};
var _do, _co, _uo, _po;
var _SignatureEditor = class _SignatureEditor extends DrawingEditor {
  constructor(t2) {
    super({ ...t2, mustBeCommitted: true, name: "signatureEditor" });
    __privateAdd(this, _do, false);
    __privateAdd(this, _co, null);
    __privateAdd(this, _uo, null);
    __privateAdd(this, _po, null);
    this._willKeepAspectRatio = true;
    __privateSet(this, _uo, t2.signatureData || null);
    __privateSet(this, _co, null);
    this.defaultL10nId = "pdfjs-editor-signature-editor1";
  }
  static initialize(t2, e2) {
    AnnotationEditor.initialize(t2, e2);
    this._defaultDrawingOptions = new SignatureOptions();
    this._defaultDrawnSignatureOptions = new DrawnSignatureOptions(e2.viewParameters);
  }
  static getDefaultDrawingOptions(t2) {
    const e2 = this._defaultDrawingOptions.clone();
    e2.updateProperties(t2);
    return e2;
  }
  static get supportMultipleDrawings() {
    return false;
  }
  static get typesMap() {
    return shadow(this, "typesMap", /* @__PURE__ */ new Map());
  }
  static get isDrawer() {
    return false;
  }
  get telemetryFinalData() {
    return { type: "signature", hasDescription: !!__privateGet(this, _co) };
  }
  static computeTelemetryFinalData(t2) {
    const e2 = t2.get("hasDescription");
    return { hasAltText: e2.get(true) ?? 0, hasNoAltText: e2.get(false) ?? 0 };
  }
  get isResizable() {
    return true;
  }
  onScaleChanging() {
    null !== this._drawId && super.onScaleChanging();
  }
  render() {
    if (this.div) return this.div;
    let t2, e2;
    const { _isCopy: i2 } = this;
    if (i2) {
      this._isCopy = false;
      t2 = this.x;
      e2 = this.y;
    }
    super.render();
    if (null === this._drawId) if (__privateGet(this, _uo)) {
      const { lines: t3, mustSmooth: e3, areContours: i3, description: s2, uuid: n2, heightInPage: a2 } = __privateGet(this, _uo), { rawDims: { pageWidth: r2, pageHeight: o2 }, rotation: l2 } = this.parent.viewport, h2 = SignatureExtractor.processDrawnLines({ lines: t3, pageWidth: r2, pageHeight: o2, rotation: l2, innerMargin: _SignatureEditor._INNER_MARGIN, mustSmooth: e3, areContours: i3 });
      this.addSignature(h2, a2, s2, n2);
    } else {
      this.div.setAttribute("data-l10n-args", JSON.stringify({ description: "" }));
      this.div.hidden = true;
      this._uiManager.getSignature(this);
    }
    if (i2) {
      this._isCopy = true;
      this._moveAfterPaste(t2, e2);
    }
    return this.div;
  }
  setUuid(t2) {
    __privateSet(this, _po, t2);
    this.addEditToolbar();
  }
  getUuid() {
    return __privateGet(this, _po);
  }
  get description() {
    return __privateGet(this, _co);
  }
  set description(t2) {
    __privateSet(this, _co, t2);
    super.addEditToolbar().then((e2) => {
      e2 == null ? void 0 : e2.updateEditSignatureButton(t2);
    });
  }
  getSignaturePreview() {
    const { newCurves: t2, areContours: e2, thickness: i2, width: s2, height: n2 } = __privateGet(this, _uo), a2 = Math.max(s2, n2);
    return { areContours: e2, outline: SignatureExtractor.processDrawnLines({ lines: { curves: t2.map((t3) => ({ points: t3 })), thickness: i2, width: s2, height: n2 }, pageWidth: a2, pageHeight: a2, rotation: 0, innerMargin: 0, mustSmooth: false, areContours: e2 }).outline };
  }
  async addEditToolbar() {
    const t2 = await super.addEditToolbar();
    if (!t2) return null;
    if (this._uiManager.signatureManager && null !== __privateGet(this, _co)) {
      await t2.addEditSignatureButton(this._uiManager.signatureManager, __privateGet(this, _po), __privateGet(this, _co));
      t2.show();
    }
    return t2;
  }
  addSignature(t2, e2, i2, s2) {
    const { x: n2, y: a2 } = this, { outline: r2 } = __privateSet(this, _uo, t2);
    __privateSet(this, _do, r2 instanceof ContourDrawOutline);
    __privateSet(this, _co, i2);
    this.div.setAttribute("data-l10n-args", JSON.stringify({ description: i2 }));
    let o2;
    if (__privateGet(this, _do)) o2 = _SignatureEditor.getDefaultDrawingOptions();
    else {
      o2 = _SignatureEditor._defaultDrawnSignatureOptions.clone();
      o2.updateProperties({ "stroke-width": r2.thickness });
    }
    this._addOutlines({ drawOutlines: r2, drawingOptions: o2 });
    const [l2, h2] = this.parentDimensions, [, d2] = this.pageDimensions;
    let c2 = e2 / d2;
    c2 = c2 >= 1 ? 0.5 : c2;
    this.width *= c2 / this.height;
    if (this.width >= 1) {
      c2 *= 0.9 / this.width;
      this.width = 0.9;
    }
    this.height = c2;
    this.setDims(l2 * this.width, h2 * this.height);
    this.x = n2;
    this.y = a2;
    this.center();
    this._onResized();
    this.onScaleChanging();
    this.rotate();
    this._uiManager.addToAnnotationStorage(this);
    this.setUuid(s2);
    this._reportTelemetry({ action: "pdfjs.signature.inserted", data: { hasBeenSaved: !!s2, hasDescription: !!i2 } });
    this.div.hidden = false;
  }
  getFromImage(t2) {
    const { rawDims: { pageWidth: e2, pageHeight: i2 }, rotation: s2 } = this.parent.viewport;
    return SignatureExtractor.process(t2, e2, i2, s2, _SignatureEditor._INNER_MARGIN);
  }
  getFromText(t2, e2) {
    const { rawDims: { pageWidth: i2, pageHeight: s2 }, rotation: n2 } = this.parent.viewport;
    return SignatureExtractor.extractContoursFromText(t2, e2, i2, s2, n2, _SignatureEditor._INNER_MARGIN);
  }
  getDrawnSignature(t2) {
    const { rawDims: { pageWidth: e2, pageHeight: i2 }, rotation: s2 } = this.parent.viewport;
    return SignatureExtractor.processDrawnLines({ lines: t2, pageWidth: e2, pageHeight: i2, rotation: s2, innerMargin: _SignatureEditor._INNER_MARGIN, mustSmooth: false, areContours: false });
  }
  createDrawingOptions({ areContours: t2, thickness: e2 }) {
    if (t2) this._drawingOptions = _SignatureEditor.getDefaultDrawingOptions();
    else {
      this._drawingOptions = _SignatureEditor._defaultDrawnSignatureOptions.clone();
      this._drawingOptions.updateProperties({ "stroke-width": e2 });
    }
  }
  serialize(t2 = false) {
    if (this.isEmpty()) return null;
    const { lines: e2, points: i2, rect: s2 } = this.serializeDraw(t2), { _drawingOptions: { "stroke-width": n2 } } = this, a2 = { annotationType: u.SIGNATURE, isSignature: true, areContours: __privateGet(this, _do), color: [0, 0, 0], thickness: __privateGet(this, _do) ? 0 : n2, pageIndex: this.pageIndex, rect: s2, rotation: this.rotation, structTreeParentId: this._structTreeParentId };
    if (t2) {
      a2.paths = { lines: e2, points: i2 };
      a2.uuid = __privateGet(this, _po);
      a2.isCopy = true;
    } else a2.lines = e2;
    __privateGet(this, _co) && (a2.accessibilityData = { type: "Figure", alt: __privateGet(this, _co) });
    return a2;
  }
  static deserializeDraw(t2, e2, i2, s2, n2, a2) {
    return a2.areContours ? ContourDrawOutline.deserialize(t2, e2, i2, s2, n2, a2) : InkDrawOutline.deserialize(t2, e2, i2, s2, n2, a2);
  }
  static async deserialize(t2, e2, i2) {
    var _a5;
    const s2 = await super.deserialize(t2, e2, i2);
    __privateSet(s2, _do, t2.areContours);
    __privateSet(s2, _co, ((_a5 = t2.accessibilityData) == null ? void 0 : _a5.alt) || "");
    __privateSet(s2, _po, t2.uuid);
    return s2;
  }
};
_do = new WeakMap();
_co = new WeakMap();
_uo = new WeakMap();
_po = new WeakMap();
__publicField(_SignatureEditor, "_type", "signature");
__publicField(_SignatureEditor, "_editorType", u.SIGNATURE);
__publicField(_SignatureEditor, "_defaultDrawingOptions", null);
var SignatureEditor = _SignatureEditor;
var _go, _fo, _mo, _bo, _Ao, _wo, _yo, _vo, _xo, _Eo, __o, _StampEditor_instances, So_fn, To_fn, Mo_fn, Co_fn, Po_fn, Do_fn, ko_fn, ta_fn4;
var StampEditor = class extends AnnotationEditor {
  constructor(t2) {
    super({ ...t2, name: "stampEditor" });
    __privateAdd(this, _StampEditor_instances);
    __privateAdd(this, _go, null);
    __privateAdd(this, _fo, null);
    __privateAdd(this, _mo, null);
    __privateAdd(this, _bo, null);
    __privateAdd(this, _Ao, null);
    __privateAdd(this, _wo, "");
    __privateAdd(this, _yo, null);
    __privateAdd(this, _vo, false);
    __privateAdd(this, _xo, null);
    __privateAdd(this, _Eo, false);
    __privateAdd(this, __o, false);
    __privateSet(this, _bo, t2.bitmapUrl);
    __privateSet(this, _Ao, t2.bitmapFile);
    this.defaultL10nId = "pdfjs-editor-stamp-editor";
  }
  static initialize(t2, e2) {
    AnnotationEditor.initialize(t2, e2);
  }
  static isHandlingMimeForPasting(t2) {
    return G.includes(t2);
  }
  static paste(t2, e2) {
    e2.pasteEditor({ mode: u.STAMP }, { bitmapFile: t2.getAsFile() });
  }
  altTextFinish() {
    this._uiManager.useNewAltTextFlow && (this.div.hidden = false);
    super.altTextFinish();
  }
  get telemetryFinalData() {
    var _a5;
    return { type: "stamp", hasAltText: !!((_a5 = this.altTextData) == null ? void 0 : _a5.altText) };
  }
  static computeTelemetryFinalData(t2) {
    const e2 = t2.get("hasAltText");
    return { hasAltText: e2.get(true) ?? 0, hasNoAltText: e2.get(false) ?? 0 };
  }
  async mlGuessAltText(t2 = null, e2 = true) {
    if (this.hasAltTextData()) return null;
    const { mlManager: i2 } = this._uiManager;
    if (!i2) throw new Error("No ML.");
    if (!await i2.isEnabledFor("altText")) throw new Error("ML isn't enabled for alt text.");
    const { data: s2, width: n2, height: a2 } = t2 || this.copyCanvas(null, null, true).imageData, r2 = await i2.guess({ name: "altText", request: { data: s2, width: n2, height: a2, channels: s2.length / (n2 * a2) } });
    if (!r2) throw new Error("No response from the AI service.");
    if (r2.error) throw new Error("Error from the AI service.");
    if (r2.cancel) return null;
    if (!r2.output) throw new Error("No valid response from the AI service.");
    const o2 = r2.output;
    await this.setGuessedAltText(o2);
    e2 && !this.hasAltTextData() && (this.altTextData = { alt: o2, decorative: false });
    return o2;
  }
  remove() {
    var _a5;
    if (__privateGet(this, _fo)) {
      __privateSet(this, _go, null);
      this._uiManager.imageManager.deleteId(__privateGet(this, _fo));
      (_a5 = __privateGet(this, _yo)) == null ? void 0 : _a5.remove();
      __privateSet(this, _yo, null);
      if (__privateGet(this, _xo)) {
        clearTimeout(__privateGet(this, _xo));
        __privateSet(this, _xo, null);
      }
    }
    super.remove();
  }
  rebuild() {
    if (this.parent) {
      super.rebuild();
      if (null !== this.div) {
        __privateGet(this, _fo) && null === __privateGet(this, _yo) && __privateMethod(this, _StampEditor_instances, Mo_fn).call(this);
        this.isAttachedToDOM || this.parent.add(this);
      }
    } else __privateGet(this, _fo) && __privateMethod(this, _StampEditor_instances, Mo_fn).call(this);
  }
  onceAdded(t2) {
    this._isDraggable = true;
    t2 && this.div.focus();
  }
  isEmpty() {
    return !(__privateGet(this, _mo) || __privateGet(this, _go) || __privateGet(this, _bo) || __privateGet(this, _Ao) || __privateGet(this, _fo) || __privateGet(this, _vo));
  }
  get isResizable() {
    return true;
  }
  render() {
    if (this.div) return this.div;
    let t2, e2;
    if (this._isCopy) {
      t2 = this.x;
      e2 = this.y;
    }
    super.render();
    this.div.hidden = true;
    this.addAltTextButton();
    __privateGet(this, _vo) || (__privateGet(this, _go) ? __privateMethod(this, _StampEditor_instances, Co_fn).call(this) : __privateMethod(this, _StampEditor_instances, Mo_fn).call(this));
    this._isCopy && this._moveAfterPaste(t2, e2);
    this._uiManager.addShouldRescale(this);
    return this.div;
  }
  setCanvas(t2, e2) {
    const { id: i2, bitmap: s2 } = this._uiManager.imageManager.getFromCanvas(t2, e2);
    e2.remove();
    if (i2 && this._uiManager.imageManager.isValidId(i2)) {
      __privateSet(this, _fo, i2);
      s2 && __privateSet(this, _go, s2);
      __privateSet(this, _vo, false);
      __privateMethod(this, _StampEditor_instances, Co_fn).call(this);
    }
  }
  _onResized() {
    this.onScaleChanging();
  }
  onScaleChanging() {
    if (!this.parent) return;
    null !== __privateGet(this, _xo) && clearTimeout(__privateGet(this, _xo));
    __privateSet(this, _xo, setTimeout(() => {
      __privateSet(this, _xo, null);
      __privateMethod(this, _StampEditor_instances, Do_fn).call(this);
    }, 200));
  }
  copyCanvas(t2, e2, i2 = false) {
    var _a5;
    t2 || (t2 = 224);
    const { width: s2, height: n2 } = __privateGet(this, _go), a2 = new OutputScale();
    let r2 = __privateGet(this, _go), o2 = s2, l2 = n2, h2 = null;
    if (e2) {
      if (s2 > e2 || n2 > e2) {
        const t4 = Math.min(e2 / s2, e2 / n2);
        o2 = Math.floor(s2 * t4);
        l2 = Math.floor(n2 * t4);
      }
      h2 = document.createElement("canvas");
      const t3 = h2.width = Math.ceil(o2 * a2.sx), i3 = h2.height = Math.ceil(l2 * a2.sy);
      __privateGet(this, _Eo) || (r2 = __privateMethod(this, _StampEditor_instances, Po_fn).call(this, t3, i3));
      const d3 = h2.getContext("2d");
      d3.filter = this._uiManager.hcmFilter;
      let c2 = "white", u2 = "#cfcfd8";
      if ("none" !== this._uiManager.hcmFilter) u2 = "black";
      else if ((_a5 = window.matchMedia) == null ? void 0 : _a5.call(window, "(prefers-color-scheme: dark)").matches) {
        c2 = "#8f8f9d";
        u2 = "#42414d";
      }
      const p2 = 15, g2 = p2 * a2.sx, f2 = p2 * a2.sy, m2 = new OffscreenCanvas(2 * g2, 2 * f2), b2 = m2.getContext("2d");
      b2.fillStyle = c2;
      b2.fillRect(0, 0, 2 * g2, 2 * f2);
      b2.fillStyle = u2;
      b2.fillRect(0, 0, g2, f2);
      b2.fillRect(g2, f2, g2, f2);
      d3.fillStyle = d3.createPattern(m2, "repeat");
      d3.fillRect(0, 0, t3, i3);
      d3.drawImage(r2, 0, 0, r2.width, r2.height, 0, 0, t3, i3);
    }
    let d2 = null;
    if (i2) {
      let e3, i3;
      if (a2.symmetric && r2.width < t2 && r2.height < t2) {
        e3 = r2.width;
        i3 = r2.height;
      } else {
        r2 = __privateGet(this, _go);
        if (s2 > t2 || n2 > t2) {
          const a3 = Math.min(t2 / s2, t2 / n2);
          e3 = Math.floor(s2 * a3);
          i3 = Math.floor(n2 * a3);
          __privateGet(this, _Eo) || (r2 = __privateMethod(this, _StampEditor_instances, Po_fn).call(this, e3, i3));
        }
      }
      const o3 = new OffscreenCanvas(e3, i3).getContext("2d", { willReadFrequently: true });
      o3.drawImage(r2, 0, 0, r2.width, r2.height, 0, 0, e3, i3);
      d2 = { width: e3, height: i3, data: o3.getImageData(0, 0, e3, i3).data };
    }
    return { canvas: h2, width: o2, height: l2, imageData: d2 };
  }
  static async deserialize(t2, e2, i2) {
    var _a5;
    let s2 = null, n2 = false;
    if (t2 instanceof StampAnnotationElement) {
      const { data: { rect: a3, rotation: r3, id: o3, structParent: l3, popupRef: h3 }, container: d3, parent: { page: { pageNumber: c3 } }, canvas: p3 } = t2;
      let g3, f2;
      if (p3) {
        delete t2.canvas;
        ({ id: g3, bitmap: f2 } = i2.imageManager.getFromCanvas(d3.id, p3));
        p3.remove();
      } else {
        n2 = true;
        t2._hasNoCanvas = true;
      }
      const m2 = ((_a5 = await e2._structTree.getAriaAttributes(`${U}${o3}`)) == null ? void 0 : _a5.get("aria-label")) || "";
      s2 = t2 = { annotationType: u.STAMP, bitmapId: g3, bitmap: f2, pageIndex: c3 - 1, rect: a3.slice(0), rotation: r3, id: o3, deleted: false, accessibilityData: { decorative: false, altText: m2 }, isSvg: false, structParent: l3, popupRef: h3 };
    }
    const a2 = await super.deserialize(t2, e2, i2), { rect: r2, bitmap: o2, bitmapUrl: l2, bitmapId: h2, isSvg: d2, accessibilityData: c2 } = t2;
    if (n2) {
      i2.addMissingCanvas(t2.id, a2);
      __privateSet(a2, _vo, true);
    } else if (h2 && i2.imageManager.isValidId(h2)) {
      __privateSet(a2, _fo, h2);
      o2 && __privateSet(a2, _go, o2);
    } else __privateSet(a2, _bo, l2);
    __privateSet(a2, _Eo, d2);
    const [p2, g2] = a2.pageDimensions;
    a2.width = (r2[2] - r2[0]) / p2;
    a2.height = (r2[3] - r2[1]) / g2;
    a2.annotationElementId = t2.id || null;
    c2 && (a2.altTextData = c2);
    a2._initialData = s2;
    __privateSet(a2, __o, !!s2);
    return a2;
  }
  serialize(t2 = false, e2 = null) {
    if (this.isEmpty()) return null;
    if (this.deleted) return this.serializeDeleted();
    const i2 = { annotationType: u.STAMP, bitmapId: __privateGet(this, _fo), pageIndex: this.pageIndex, rect: this.getRect(0, 0), rotation: this.rotation, isSvg: __privateGet(this, _Eo), structTreeParentId: this._structTreeParentId };
    if (t2) {
      i2.bitmapUrl = __privateMethod(this, _StampEditor_instances, ko_fn).call(this, true);
      i2.accessibilityData = this.serializeAltText(true);
      i2.isCopy = true;
      return i2;
    }
    const { decorative: s2, altText: n2 } = this.serializeAltText(false);
    !s2 && n2 && (i2.accessibilityData = { type: "Figure", alt: n2 });
    if (this.annotationElementId) {
      const t3 = __privateMethod(this, _StampEditor_instances, ta_fn4).call(this, i2);
      if (t3.isSame) return null;
      t3.isSameAltText ? delete i2.accessibilityData : i2.accessibilityData.structParent = this._initialData.structParent ?? -1;
    }
    i2.id = this.annotationElementId;
    if (null === e2) return i2;
    e2.stamps || (e2.stamps = /* @__PURE__ */ new Map());
    const a2 = __privateGet(this, _Eo) ? (i2.rect[2] - i2.rect[0]) * (i2.rect[3] - i2.rect[1]) : null;
    if (e2.stamps.has(__privateGet(this, _fo))) {
      if (__privateGet(this, _Eo)) {
        const t3 = e2.stamps.get(__privateGet(this, _fo));
        if (a2 > t3.area) {
          t3.area = a2;
          t3.serialized.bitmap.close();
          t3.serialized.bitmap = __privateMethod(this, _StampEditor_instances, ko_fn).call(this, false);
        }
      }
    } else {
      e2.stamps.set(__privateGet(this, _fo), { area: a2, serialized: i2 });
      i2.bitmap = __privateMethod(this, _StampEditor_instances, ko_fn).call(this, false);
    }
    return i2;
  }
  renderAnnotationElement(t2) {
    t2.updateEdited({ rect: this.getRect(0, 0) });
    return null;
  }
};
_go = new WeakMap();
_fo = new WeakMap();
_mo = new WeakMap();
_bo = new WeakMap();
_Ao = new WeakMap();
_wo = new WeakMap();
_yo = new WeakMap();
_vo = new WeakMap();
_xo = new WeakMap();
_Eo = new WeakMap();
__o = new WeakMap();
_StampEditor_instances = new WeakSet();
So_fn = function(t2, e2 = false) {
  if (t2) {
    __privateSet(this, _go, t2.bitmap);
    if (!e2) {
      __privateSet(this, _fo, t2.id);
      __privateSet(this, _Eo, t2.isSvg);
    }
    t2.file && __privateSet(this, _wo, t2.file.name);
    __privateMethod(this, _StampEditor_instances, Co_fn).call(this);
  } else this.remove();
};
To_fn = function() {
  __privateSet(this, _mo, null);
  this._uiManager.enableWaiting(false);
  if (__privateGet(this, _yo)) if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && __privateGet(this, _go)) {
    this._editToolbar.hide();
    this._uiManager.editAltText(this, true);
  } else {
    if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && __privateGet(this, _go)) {
      this._reportTelemetry({ action: "pdfjs.image.image_added", data: { alt_text_modal: false, alt_text_type: "empty" } });
      try {
        this.mlGuessAltText();
      } catch {
      }
    }
    this.div.focus();
  }
};
Mo_fn = function() {
  if (__privateGet(this, _fo)) {
    this._uiManager.enableWaiting(true);
    this._uiManager.imageManager.getFromId(__privateGet(this, _fo)).then((t3) => __privateMethod(this, _StampEditor_instances, So_fn).call(this, t3, true)).finally(() => __privateMethod(this, _StampEditor_instances, To_fn).call(this));
    return;
  }
  if (__privateGet(this, _bo)) {
    const t3 = __privateGet(this, _bo);
    __privateSet(this, _bo, null);
    this._uiManager.enableWaiting(true);
    __privateSet(this, _mo, this._uiManager.imageManager.getFromUrl(t3).then((t4) => __privateMethod(this, _StampEditor_instances, So_fn).call(this, t4)).finally(() => __privateMethod(this, _StampEditor_instances, To_fn).call(this)));
    return;
  }
  if (__privateGet(this, _Ao)) {
    const t3 = __privateGet(this, _Ao);
    __privateSet(this, _Ao, null);
    this._uiManager.enableWaiting(true);
    __privateSet(this, _mo, this._uiManager.imageManager.getFromFile(t3).then((t4) => __privateMethod(this, _StampEditor_instances, So_fn).call(this, t4)).finally(() => __privateMethod(this, _StampEditor_instances, To_fn).call(this)));
    return;
  }
  const t2 = document.createElement("input");
  t2.type = "file";
  t2.accept = G.join(",");
  const e2 = this._uiManager._signal;
  __privateSet(this, _mo, new Promise((i2) => {
    t2.addEventListener("change", async () => {
      if (t2.files && 0 !== t2.files.length) {
        this._uiManager.enableWaiting(true);
        const e3 = await this._uiManager.imageManager.getFromFile(t2.files[0]);
        this._reportTelemetry({ action: "pdfjs.image.image_selected", data: { alt_text_modal: this._uiManager.useNewAltTextFlow } });
        __privateMethod(this, _StampEditor_instances, So_fn).call(this, e3);
      } else this.remove();
      i2();
    }, { signal: e2 });
    t2.addEventListener("cancel", () => {
      this.remove();
      i2();
    }, { signal: e2 });
  }).finally(() => __privateMethod(this, _StampEditor_instances, To_fn).call(this)));
  t2.click();
};
Co_fn = function() {
  var _a5;
  const { div: t2 } = this;
  let { width: e2, height: i2 } = __privateGet(this, _go);
  const [s2, n2] = this.pageDimensions, a2 = 0.75;
  if (this.width) {
    e2 = this.width * s2;
    i2 = this.height * n2;
  } else if (e2 > a2 * s2 || i2 > a2 * n2) {
    const t3 = Math.min(a2 * s2 / e2, a2 * n2 / i2);
    e2 *= t3;
    i2 *= t3;
  }
  const [r2, o2] = this.parentDimensions;
  this.setDims(e2 * r2 / s2, i2 * o2 / n2);
  this._uiManager.enableWaiting(false);
  const l2 = __privateSet(this, _yo, document.createElement("canvas"));
  l2.setAttribute("role", "img");
  this.addContainer(l2);
  this.width = e2 / s2;
  this.height = i2 / n2;
  ((_a5 = this._initialOptions) == null ? void 0 : _a5.isCentered) ? this.center() : this.fixAndSetPosition();
  this._initialOptions = null;
  this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && !this.annotationElementId || (t2.hidden = false);
  __privateMethod(this, _StampEditor_instances, Do_fn).call(this);
  if (!__privateGet(this, __o)) {
    this.parent.addUndoableEditor(this);
    __privateSet(this, __o, true);
  }
  this._reportTelemetry({ action: "inserted_image" });
  __privateGet(this, _wo) && this.div.setAttribute("aria-description", __privateGet(this, _wo));
};
Po_fn = function(t2, e2) {
  const { width: i2, height: s2 } = __privateGet(this, _go);
  let n2 = i2, a2 = s2, r2 = __privateGet(this, _go);
  for (; n2 > 2 * t2 || a2 > 2 * e2; ) {
    const i3 = n2, s3 = a2;
    n2 > 2 * t2 && (n2 = n2 >= 16384 ? Math.floor(n2 / 2) - 1 : Math.ceil(n2 / 2));
    a2 > 2 * e2 && (a2 = a2 >= 16384 ? Math.floor(a2 / 2) - 1 : Math.ceil(a2 / 2));
    const o2 = new OffscreenCanvas(n2, a2);
    o2.getContext("2d").drawImage(r2, 0, 0, i3, s3, 0, 0, n2, a2);
    r2 = o2.transferToImageBitmap();
  }
  return r2;
};
Do_fn = function() {
  const [t2, e2] = this.parentDimensions, { width: i2, height: s2 } = this, n2 = new OutputScale(), a2 = Math.ceil(i2 * t2 * n2.sx), r2 = Math.ceil(s2 * e2 * n2.sy), o2 = __privateGet(this, _yo);
  if (!o2 || o2.width === a2 && o2.height === r2) return;
  o2.width = a2;
  o2.height = r2;
  const l2 = __privateGet(this, _Eo) ? __privateGet(this, _go) : __privateMethod(this, _StampEditor_instances, Po_fn).call(this, a2, r2), h2 = o2.getContext("2d");
  h2.filter = this._uiManager.hcmFilter;
  h2.drawImage(l2, 0, 0, l2.width, l2.height, 0, 0, a2, r2);
};
ko_fn = function(t2) {
  if (t2) {
    if (__privateGet(this, _Eo)) {
      const t4 = this._uiManager.imageManager.getSvgUrl(__privateGet(this, _fo));
      if (t4) return t4;
    }
    const t3 = document.createElement("canvas");
    ({ width: t3.width, height: t3.height } = __privateGet(this, _go));
    t3.getContext("2d").drawImage(__privateGet(this, _go), 0, 0);
    return t3.toDataURL();
  }
  if (__privateGet(this, _Eo)) {
    const [t3, e2] = this.pageDimensions, i2 = Math.round(this.width * t3 * PixelsPerInch.PDF_TO_CSS_UNITS), s2 = Math.round(this.height * e2 * PixelsPerInch.PDF_TO_CSS_UNITS), n2 = new OffscreenCanvas(i2, s2);
    n2.getContext("2d").drawImage(__privateGet(this, _go), 0, 0, __privateGet(this, _go).width, __privateGet(this, _go).height, 0, 0, i2, s2);
    return n2.transferToImageBitmap();
  }
  return structuredClone(__privateGet(this, _go));
};
ta_fn4 = function(t2) {
  var _a5;
  const { pageIndex: e2, accessibilityData: { altText: i2 } } = this._initialData, s2 = t2.pageIndex === e2, n2 = (((_a5 = t2.accessibilityData) == null ? void 0 : _a5.alt) || "") === i2;
  return { isSame: !this._hasBeenMoved && !this._hasBeenResized && s2 && n2, isSameAltText: n2 };
};
__publicField(StampEditor, "_type", "stamp");
__publicField(StampEditor, "_editorType", u.STAMP);
var _Nn2, _Io, _Ro, _Fo, _Lo, _Oo, _No, _Bo, _Ho, _Uo, _zo, _Go, _$o, _m3, _G2, _AnnotationEditorLayer_instances, Vo_fn, jo_get, qo_fn, Xo_fn, Wo_fn;
var _AnnotationEditorLayer = class _AnnotationEditorLayer {
  constructor({ uiManager: t2, pageIndex: e2, div: i2, structTreeLayer: s2, accessibilityManager: n2, annotationLayer: a2, drawLayer: r2, textLayer: o2, viewport: l2, l10n: h2 }) {
    __privateAdd(this, _AnnotationEditorLayer_instances);
    __privateAdd(this, _Nn2);
    __privateAdd(this, _Io, false);
    __privateAdd(this, _Ro, null);
    __privateAdd(this, _Fo, null);
    __privateAdd(this, _Lo, null);
    __privateAdd(this, _Oo, /* @__PURE__ */ new Map());
    __privateAdd(this, _No, false);
    __privateAdd(this, _Bo, false);
    __privateAdd(this, _Ho, false);
    __privateAdd(this, _Uo, null);
    __privateAdd(this, _zo, null);
    __privateAdd(this, _Go, null);
    __privateAdd(this, _$o, null);
    __privateAdd(this, _m3);
    const d2 = [...__privateGet(_AnnotationEditorLayer, _G2).values()];
    if (!_AnnotationEditorLayer._initialized) {
      _AnnotationEditorLayer._initialized = true;
      for (const e3 of d2) e3.initialize(h2, t2);
    }
    t2.registerEditorTypes(d2);
    __privateSet(this, _m3, t2);
    this.pageIndex = e2;
    this.div = i2;
    __privateSet(this, _Nn2, n2);
    __privateSet(this, _Ro, a2);
    this.viewport = l2;
    __privateSet(this, _Go, o2);
    this.drawLayer = r2;
    this._structTree = s2;
    __privateGet(this, _m3).addLayer(this);
  }
  get isEmpty() {
    return 0 === __privateGet(this, _Oo).size;
  }
  get isInvisible() {
    return this.isEmpty && __privateGet(this, _m3).getMode() === u.NONE;
  }
  updateToolbar(t2) {
    __privateGet(this, _m3).updateToolbar(t2);
  }
  updateMode(t2 = __privateGet(this, _m3).getMode()) {
    __privateMethod(this, _AnnotationEditorLayer_instances, Wo_fn).call(this);
    switch (t2) {
      case u.NONE:
        this.disableTextSelection();
        this.togglePointerEvents(false);
        this.toggleAnnotationLayerPointerEvents(true);
        this.disableClick();
        return;
      case u.INK:
        this.disableTextSelection();
        this.togglePointerEvents(true);
        this.enableClick();
        break;
      case u.HIGHLIGHT:
        this.enableTextSelection();
        this.togglePointerEvents(false);
        this.disableClick();
        break;
      default:
        this.disableTextSelection();
        this.togglePointerEvents(true);
        this.enableClick();
    }
    this.toggleAnnotationLayerPointerEvents(false);
    const { classList: e2 } = this.div;
    for (const i2 of __privateGet(_AnnotationEditorLayer, _G2).values()) e2.toggle(`${i2._type}Editing`, t2 === i2._editorType);
    this.div.hidden = false;
  }
  hasTextLayer(t2) {
    var _a5;
    return t2 === ((_a5 = __privateGet(this, _Go)) == null ? void 0 : _a5.div);
  }
  setEditingState(t2) {
    __privateGet(this, _m3).setEditingState(t2);
  }
  addCommands(t2) {
    __privateGet(this, _m3).addCommands(t2);
  }
  cleanUndoStack(t2) {
    __privateGet(this, _m3).cleanUndoStack(t2);
  }
  toggleDrawing(t2 = false) {
    this.div.classList.toggle("drawing", !t2);
  }
  togglePointerEvents(t2 = false) {
    this.div.classList.toggle("disabled", !t2);
  }
  toggleAnnotationLayerPointerEvents(t2 = false) {
    var _a5;
    (_a5 = __privateGet(this, _Ro)) == null ? void 0 : _a5.div.classList.toggle("disabled", !t2);
  }
  async enable() {
    __privateSet(this, _Ho, true);
    this.div.tabIndex = 0;
    this.togglePointerEvents(true);
    const t2 = /* @__PURE__ */ new Set();
    for (const e3 of __privateGet(this, _Oo).values()) {
      e3.enableEditing();
      e3.show(true);
      if (e3.annotationElementId) {
        __privateGet(this, _m3).removeChangedExistingAnnotation(e3);
        t2.add(e3.annotationElementId);
      }
    }
    if (!__privateGet(this, _Ro)) {
      __privateSet(this, _Ho, false);
      return;
    }
    const e2 = __privateGet(this, _Ro).getEditableAnnotations();
    for (const i2 of e2) {
      i2.hide();
      if (__privateGet(this, _m3).isDeletedAnnotationElement(i2.data.id)) continue;
      if (t2.has(i2.data.id)) continue;
      const e3 = await this.deserialize(i2);
      if (e3) {
        this.addOrRebuild(e3);
        e3.enableEditing();
      }
    }
    __privateSet(this, _Ho, false);
  }
  disable() {
    var _a5;
    __privateSet(this, _Bo, true);
    this.div.tabIndex = -1;
    this.togglePointerEvents(false);
    const t2 = /* @__PURE__ */ new Map(), e2 = /* @__PURE__ */ new Map();
    for (const i3 of __privateGet(this, _Oo).values()) {
      i3.disableEditing();
      if (i3.annotationElementId) if (null === i3.serialize()) {
        e2.set(i3.annotationElementId, i3);
        (_a5 = this.getEditableAnnotation(i3.annotationElementId)) == null ? void 0 : _a5.show();
        i3.remove();
      } else t2.set(i3.annotationElementId, i3);
    }
    if (__privateGet(this, _Ro)) {
      const i3 = __privateGet(this, _Ro).getEditableAnnotations();
      for (const s2 of i3) {
        const { id: i4 } = s2.data;
        if (__privateGet(this, _m3).isDeletedAnnotationElement(i4)) continue;
        let n2 = e2.get(i4);
        if (n2) {
          n2.resetAnnotationElement(s2);
          n2.show(false);
          s2.show();
        } else {
          n2 = t2.get(i4);
          if (n2) {
            __privateGet(this, _m3).addChangedExistingAnnotation(n2);
            n2.renderAnnotationElement(s2) && n2.show(false);
          }
          s2.show();
        }
      }
    }
    __privateMethod(this, _AnnotationEditorLayer_instances, Wo_fn).call(this);
    this.isEmpty && (this.div.hidden = true);
    const { classList: i2 } = this.div;
    for (const t3 of __privateGet(_AnnotationEditorLayer, _G2).values()) i2.remove(`${t3._type}Editing`);
    this.disableTextSelection();
    this.toggleAnnotationLayerPointerEvents(true);
    __privateSet(this, _Bo, false);
  }
  getEditableAnnotation(t2) {
    var _a5;
    return ((_a5 = __privateGet(this, _Ro)) == null ? void 0 : _a5.getEditableAnnotation(t2)) || null;
  }
  setActiveEditor(t2) {
    __privateGet(this, _m3).getActive() !== t2 && __privateGet(this, _m3).setActiveEditor(t2);
  }
  enableTextSelection() {
    var _a5;
    this.div.tabIndex = -1;
    if (((_a5 = __privateGet(this, _Go)) == null ? void 0 : _a5.div) && !__privateGet(this, _$o)) {
      __privateSet(this, _$o, new AbortController());
      const t2 = __privateGet(this, _m3).combinedSignal(__privateGet(this, _$o));
      __privateGet(this, _Go).div.addEventListener("pointerdown", __privateMethod(this, _AnnotationEditorLayer_instances, Vo_fn).bind(this), { signal: t2 });
      __privateGet(this, _Go).div.classList.add("highlighting");
    }
  }
  disableTextSelection() {
    var _a5;
    this.div.tabIndex = 0;
    if (((_a5 = __privateGet(this, _Go)) == null ? void 0 : _a5.div) && __privateGet(this, _$o)) {
      __privateGet(this, _$o).abort();
      __privateSet(this, _$o, null);
      __privateGet(this, _Go).div.classList.remove("highlighting");
    }
  }
  enableClick() {
    if (__privateGet(this, _Fo)) return;
    __privateSet(this, _Fo, new AbortController());
    const t2 = __privateGet(this, _m3).combinedSignal(__privateGet(this, _Fo));
    this.div.addEventListener("pointerdown", this.pointerdown.bind(this), { signal: t2 });
    const e2 = this.pointerup.bind(this);
    this.div.addEventListener("pointerup", e2, { signal: t2 });
    this.div.addEventListener("pointercancel", e2, { signal: t2 });
  }
  disableClick() {
    var _a5;
    (_a5 = __privateGet(this, _Fo)) == null ? void 0 : _a5.abort();
    __privateSet(this, _Fo, null);
  }
  attach(t2) {
    __privateGet(this, _Oo).set(t2.id, t2);
    const { annotationElementId: e2 } = t2;
    e2 && __privateGet(this, _m3).isDeletedAnnotationElement(e2) && __privateGet(this, _m3).removeDeletedAnnotationElement(t2);
  }
  detach(t2) {
    var _a5;
    __privateGet(this, _Oo).delete(t2.id);
    (_a5 = __privateGet(this, _Nn2)) == null ? void 0 : _a5.removePointerInTextLayer(t2.contentDiv);
    !__privateGet(this, _Bo) && t2.annotationElementId && __privateGet(this, _m3).addDeletedAnnotationElement(t2);
  }
  remove(t2) {
    this.detach(t2);
    __privateGet(this, _m3).removeEditor(t2);
    t2.div.remove();
    t2.isAttachedToDOM = false;
  }
  changeParent(t2) {
    var _a5;
    if (t2.parent !== this) {
      if (t2.parent && t2.annotationElementId) {
        __privateGet(this, _m3).addDeletedAnnotationElement(t2.annotationElementId);
        AnnotationEditor.deleteAnnotationElement(t2);
        t2.annotationElementId = null;
      }
      this.attach(t2);
      (_a5 = t2.parent) == null ? void 0 : _a5.detach(t2);
      t2.setParent(this);
      if (t2.div && t2.isAttachedToDOM) {
        t2.div.remove();
        this.div.append(t2.div);
      }
    }
  }
  add(t2) {
    if (t2.parent !== this || !t2.isAttachedToDOM) {
      this.changeParent(t2);
      __privateGet(this, _m3).addEditor(t2);
      this.attach(t2);
      if (!t2.isAttachedToDOM) {
        const e2 = t2.render();
        this.div.append(e2);
        t2.isAttachedToDOM = true;
      }
      t2.fixAndSetPosition();
      t2.onceAdded(!__privateGet(this, _Ho));
      __privateGet(this, _m3).addToAnnotationStorage(t2);
      t2._reportTelemetry(t2.telemetryInitialData);
    }
  }
  moveEditorInDOM(t2) {
    var _a5;
    if (!t2.isAttachedToDOM) return;
    const { activeElement: e2 } = document;
    if (t2.div.contains(e2) && !__privateGet(this, _Lo)) {
      t2._focusEventsAllowed = false;
      __privateSet(this, _Lo, setTimeout(() => {
        __privateSet(this, _Lo, null);
        if (t2.div.contains(document.activeElement)) t2._focusEventsAllowed = true;
        else {
          t2.div.addEventListener("focusin", () => {
            t2._focusEventsAllowed = true;
          }, { once: true, signal: __privateGet(this, _m3)._signal });
          e2.focus();
        }
      }, 0));
    }
    t2._structTreeParentId = (_a5 = __privateGet(this, _Nn2)) == null ? void 0 : _a5.moveElementInDOM(this.div, t2.div, t2.contentDiv, true);
  }
  addOrRebuild(t2) {
    if (t2.needsToBeRebuilt()) {
      t2.parent || (t2.parent = this);
      t2.rebuild();
      t2.show();
    } else this.add(t2);
  }
  addUndoableEditor(t2) {
    this.addCommands({ cmd: () => t2._uiManager.rebuild(t2), undo: () => {
      t2.remove();
    }, mustExec: false });
  }
  getNextId() {
    return __privateGet(this, _m3).getId();
  }
  combinedSignal(t2) {
    return __privateGet(this, _m3).combinedSignal(t2);
  }
  canCreateNewEmptyEditor() {
    var _a5;
    return (_a5 = __privateGet(this, _AnnotationEditorLayer_instances, jo_get)) == null ? void 0 : _a5.canCreateNewEmptyEditor();
  }
  async pasteEditor(t2, e2) {
    this.updateToolbar(t2);
    await __privateGet(this, _m3).updateMode(t2.mode);
    const { offsetX: i2, offsetY: s2 } = __privateMethod(this, _AnnotationEditorLayer_instances, Xo_fn).call(this), n2 = this.getNextId(), a2 = __privateMethod(this, _AnnotationEditorLayer_instances, qo_fn).call(this, { parent: this, id: n2, x: i2, y: s2, uiManager: __privateGet(this, _m3), isCentered: true, ...e2 });
    a2 && this.add(a2);
  }
  async deserialize(t2) {
    var _a5;
    return await ((_a5 = __privateGet(_AnnotationEditorLayer, _G2).get(t2.annotationType ?? t2.annotationEditorType)) == null ? void 0 : _a5.deserialize(t2, this, __privateGet(this, _m3))) || null;
  }
  createAndAddNewEditor(t2, e2, i2 = {}) {
    const s2 = this.getNextId(), n2 = __privateMethod(this, _AnnotationEditorLayer_instances, qo_fn).call(this, { parent: this, id: s2, x: t2.offsetX, y: t2.offsetY, uiManager: __privateGet(this, _m3), isCentered: e2, ...i2 });
    n2 && this.add(n2);
    return n2;
  }
  addNewEditor(t2 = {}) {
    this.createAndAddNewEditor(__privateMethod(this, _AnnotationEditorLayer_instances, Xo_fn).call(this), true, t2);
  }
  setSelected(t2) {
    __privateGet(this, _m3).setSelected(t2);
  }
  toggleSelected(t2) {
    __privateGet(this, _m3).toggleSelected(t2);
  }
  unselect(t2) {
    __privateGet(this, _m3).unselect(t2);
  }
  pointerup(t2) {
    var _a5;
    const { isMac: e2 } = util_FeatureTest.platform;
    if (0 !== t2.button || t2.ctrlKey && e2) return;
    if (t2.target !== this.div) return;
    if (!__privateGet(this, _No)) return;
    __privateSet(this, _No, false);
    if (((_a5 = __privateGet(this, _AnnotationEditorLayer_instances, jo_get)) == null ? void 0 : _a5.isDrawer) && __privateGet(this, _AnnotationEditorLayer_instances, jo_get).supportMultipleDrawings) return;
    if (!__privateGet(this, _Io)) {
      __privateSet(this, _Io, true);
      return;
    }
    const i2 = __privateGet(this, _m3).getMode();
    i2 !== u.STAMP && i2 !== u.SIGNATURE ? this.createAndAddNewEditor(t2, false) : __privateGet(this, _m3).unselectAll();
  }
  pointerdown(t2) {
    var _a5;
    __privateGet(this, _m3).getMode() === u.HIGHLIGHT && this.enableTextSelection();
    if (__privateGet(this, _No)) {
      __privateSet(this, _No, false);
      return;
    }
    const { isMac: e2 } = util_FeatureTest.platform;
    if (0 !== t2.button || t2.ctrlKey && e2) return;
    if (t2.target !== this.div) return;
    __privateSet(this, _No, true);
    if ((_a5 = __privateGet(this, _AnnotationEditorLayer_instances, jo_get)) == null ? void 0 : _a5.isDrawer) {
      this.startDrawingSession(t2);
      return;
    }
    const i2 = __privateGet(this, _m3).getActive();
    __privateSet(this, _Io, !i2 || i2.isEmpty());
  }
  startDrawingSession(t2) {
    this.div.focus({ preventScroll: true });
    if (__privateGet(this, _Uo)) {
      __privateGet(this, _AnnotationEditorLayer_instances, jo_get).startDrawing(this, __privateGet(this, _m3), false, t2);
      return;
    }
    __privateGet(this, _m3).setCurrentDrawingSession(this);
    __privateSet(this, _Uo, new AbortController());
    const e2 = __privateGet(this, _m3).combinedSignal(__privateGet(this, _Uo));
    this.div.addEventListener("blur", ({ relatedTarget: t3 }) => {
      if (t3 && !this.div.contains(t3)) {
        __privateSet(this, _zo, null);
        this.commitOrRemove();
      }
    }, { signal: e2 });
    __privateGet(this, _AnnotationEditorLayer_instances, jo_get).startDrawing(this, __privateGet(this, _m3), false, t2);
  }
  pause(t2) {
    if (t2) {
      const { activeElement: t3 } = document;
      this.div.contains(t3) && __privateSet(this, _zo, t3);
    } else __privateGet(this, _zo) && setTimeout(() => {
      var _a5;
      (_a5 = __privateGet(this, _zo)) == null ? void 0 : _a5.focus();
      __privateSet(this, _zo, null);
    }, 0);
  }
  endDrawingSession(t2 = false) {
    if (!__privateGet(this, _Uo)) return null;
    __privateGet(this, _m3).setCurrentDrawingSession(null);
    __privateGet(this, _Uo).abort();
    __privateSet(this, _Uo, null);
    __privateSet(this, _zo, null);
    return __privateGet(this, _AnnotationEditorLayer_instances, jo_get).endDrawing(t2);
  }
  findNewParent(t2, e2, i2) {
    const s2 = __privateGet(this, _m3).findParent(e2, i2);
    if (null === s2 || s2 === this) return false;
    s2.changeParent(t2);
    return true;
  }
  commitOrRemove() {
    if (__privateGet(this, _Uo)) {
      this.endDrawingSession();
      return true;
    }
    return false;
  }
  onScaleChanging() {
    __privateGet(this, _Uo) && __privateGet(this, _AnnotationEditorLayer_instances, jo_get).onScaleChangingWhenDrawing(this);
  }
  destroy() {
    var _a5, _b;
    this.commitOrRemove();
    if (((_a5 = __privateGet(this, _m3).getActive()) == null ? void 0 : _a5.parent) === this) {
      __privateGet(this, _m3).commitOrRemove();
      __privateGet(this, _m3).setActiveEditor(null);
    }
    if (__privateGet(this, _Lo)) {
      clearTimeout(__privateGet(this, _Lo));
      __privateSet(this, _Lo, null);
    }
    for (const t2 of __privateGet(this, _Oo).values()) {
      (_b = __privateGet(this, _Nn2)) == null ? void 0 : _b.removePointerInTextLayer(t2.contentDiv);
      t2.setParent(null);
      t2.isAttachedToDOM = false;
      t2.div.remove();
    }
    this.div = null;
    __privateGet(this, _Oo).clear();
    __privateGet(this, _m3).removeLayer(this);
  }
  render({ viewport: t2 }) {
    this.viewport = t2;
    setLayerDimensions(this.div, t2);
    for (const t3 of __privateGet(this, _m3).getEditors(this.pageIndex)) {
      this.add(t3);
      t3.rebuild();
    }
    this.updateMode();
  }
  update({ viewport: t2 }) {
    __privateGet(this, _m3).commitOrRemove();
    __privateMethod(this, _AnnotationEditorLayer_instances, Wo_fn).call(this);
    const e2 = this.viewport.rotation, i2 = t2.rotation;
    this.viewport = t2;
    setLayerDimensions(this.div, { rotation: i2 });
    if (e2 !== i2) for (const t3 of __privateGet(this, _Oo).values()) t3.rotate(i2);
  }
  get pageDimensions() {
    const { pageWidth: t2, pageHeight: e2 } = this.viewport.rawDims;
    return [t2, e2];
  }
  get scale() {
    return __privateGet(this, _m3).viewParameters.realScale;
  }
};
_Nn2 = new WeakMap();
_Io = new WeakMap();
_Ro = new WeakMap();
_Fo = new WeakMap();
_Lo = new WeakMap();
_Oo = new WeakMap();
_No = new WeakMap();
_Bo = new WeakMap();
_Ho = new WeakMap();
_Uo = new WeakMap();
_zo = new WeakMap();
_Go = new WeakMap();
_$o = new WeakMap();
_m3 = new WeakMap();
_G2 = new WeakMap();
_AnnotationEditorLayer_instances = new WeakSet();
Vo_fn = function(t2) {
  __privateGet(this, _m3).unselectAll();
  const { target: e2 } = t2;
  if (e2 === __privateGet(this, _Go).div || ("img" === e2.getAttribute("role") || e2.classList.contains("endOfContent")) && __privateGet(this, _Go).div.contains(e2)) {
    const { isMac: e3 } = util_FeatureTest.platform;
    if (0 !== t2.button || t2.ctrlKey && e3) return;
    __privateGet(this, _m3).showAllEditors("highlight", true, true);
    __privateGet(this, _Go).div.classList.add("free");
    this.toggleDrawing();
    HighlightEditor.startHighlighting(this, "ltr" === __privateGet(this, _m3).direction, { target: __privateGet(this, _Go).div, x: t2.x, y: t2.y });
    __privateGet(this, _Go).div.addEventListener("pointerup", () => {
      __privateGet(this, _Go).div.classList.remove("free");
      this.toggleDrawing(true);
    }, { once: true, signal: __privateGet(this, _m3)._signal });
    t2.preventDefault();
  }
};
jo_get = function() {
  return __privateGet(_AnnotationEditorLayer, _G2).get(__privateGet(this, _m3).getMode());
};
qo_fn = function(t2) {
  const e2 = __privateGet(this, _AnnotationEditorLayer_instances, jo_get);
  return e2 ? new e2.prototype.constructor(t2) : null;
};
Xo_fn = function() {
  const { x: t2, y: e2, width: i2, height: s2 } = this.div.getBoundingClientRect(), n2 = Math.max(0, t2), a2 = Math.max(0, e2), r2 = (n2 + Math.min(window.innerWidth, t2 + i2)) / 2 - t2, o2 = (a2 + Math.min(window.innerHeight, e2 + s2)) / 2 - e2, [l2, h2] = this.viewport.rotation % 180 == 0 ? [r2, o2] : [o2, r2];
  return { offsetX: l2, offsetY: h2 };
};
Wo_fn = function() {
  for (const t2 of __privateGet(this, _Oo).values()) t2.isEmpty() && t2.remove();
};
__publicField(_AnnotationEditorLayer, "_initialized", false);
__privateAdd(_AnnotationEditorLayer, _G2, new Map([FreeTextEditor, InkEditor, StampEditor, HighlightEditor, SignatureEditor].map((t2) => [t2._editorType, t2])));
var AnnotationEditorLayer = _AnnotationEditorLayer;
var _fn2, _Ko, _Yo, _y5, _DrawLayer_static, Qo_fn, _DrawLayer_instances, Jo_fn, Zo_fn, tl_fn;
var _DrawLayer = class _DrawLayer {
  constructor({ pageIndex: t2 }) {
    __privateAdd(this, _DrawLayer_instances);
    __privateAdd(this, _fn2, null);
    __privateAdd(this, _Ko, /* @__PURE__ */ new Map());
    __privateAdd(this, _Yo, /* @__PURE__ */ new Map());
    this.pageIndex = t2;
  }
  setParent(t2) {
    if (__privateGet(this, _fn2)) {
      if (__privateGet(this, _fn2) !== t2) {
        if (__privateGet(this, _Ko).size > 0) for (const e2 of __privateGet(this, _Ko).values()) {
          e2.remove();
          t2.append(e2);
        }
        __privateSet(this, _fn2, t2);
      }
    } else __privateSet(this, _fn2, t2);
  }
  static get _svgFactory() {
    return shadow(this, "_svgFactory", new DOMSVGFactory());
  }
  draw(t2, e2 = false, i2 = false) {
    const s2 = __privateWrapper(_DrawLayer, _y5)._++, n2 = __privateMethod(this, _DrawLayer_instances, Jo_fn).call(this), a2 = _DrawLayer._svgFactory.createElement("defs");
    n2.append(a2);
    const r2 = _DrawLayer._svgFactory.createElement("path");
    a2.append(r2);
    const o2 = `path_p${this.pageIndex}_${s2}`;
    r2.setAttribute("id", o2);
    r2.setAttribute("vector-effect", "non-scaling-stroke");
    e2 && __privateGet(this, _Yo).set(s2, r2);
    const l2 = i2 ? __privateMethod(this, _DrawLayer_instances, Zo_fn).call(this, a2, o2) : null, h2 = _DrawLayer._svgFactory.createElement("use");
    n2.append(h2);
    h2.setAttribute("href", `#${o2}`);
    this.updateProperties(n2, t2);
    __privateGet(this, _Ko).set(s2, n2);
    return { id: s2, clipPathId: `url(#${l2})` };
  }
  drawOutline(t2, e2) {
    const i2 = __privateWrapper(_DrawLayer, _y5)._++, s2 = __privateMethod(this, _DrawLayer_instances, Jo_fn).call(this), n2 = _DrawLayer._svgFactory.createElement("defs");
    s2.append(n2);
    const a2 = _DrawLayer._svgFactory.createElement("path");
    n2.append(a2);
    const r2 = `path_p${this.pageIndex}_${i2}`;
    a2.setAttribute("id", r2);
    a2.setAttribute("vector-effect", "non-scaling-stroke");
    let o2;
    if (e2) {
      const t3 = _DrawLayer._svgFactory.createElement("mask");
      n2.append(t3);
      o2 = `mask_p${this.pageIndex}_${i2}`;
      t3.setAttribute("id", o2);
      t3.setAttribute("maskUnits", "objectBoundingBox");
      const e3 = _DrawLayer._svgFactory.createElement("rect");
      t3.append(e3);
      e3.setAttribute("width", "1");
      e3.setAttribute("height", "1");
      e3.setAttribute("fill", "white");
      const s3 = _DrawLayer._svgFactory.createElement("use");
      t3.append(s3);
      s3.setAttribute("href", `#${r2}`);
      s3.setAttribute("stroke", "none");
      s3.setAttribute("fill", "black");
      s3.setAttribute("fill-rule", "nonzero");
      s3.classList.add("mask");
    }
    const l2 = _DrawLayer._svgFactory.createElement("use");
    s2.append(l2);
    l2.setAttribute("href", `#${r2}`);
    o2 && l2.setAttribute("mask", `url(#${o2})`);
    const h2 = l2.cloneNode();
    s2.append(h2);
    l2.classList.add("mainOutline");
    h2.classList.add("secondaryOutline");
    this.updateProperties(s2, t2);
    __privateGet(this, _Ko).set(i2, s2);
    return i2;
  }
  finalizeDraw(t2, e2) {
    __privateGet(this, _Yo).delete(t2);
    this.updateProperties(t2, e2);
  }
  updateProperties(t2, e2) {
    var _a5;
    if (!e2) return;
    const { root: i2, bbox: s2, rootClass: n2, path: a2 } = e2, r2 = "number" == typeof t2 ? __privateGet(this, _Ko).get(t2) : t2;
    if (r2) {
      i2 && __privateMethod(this, _DrawLayer_instances, tl_fn).call(this, r2, i2);
      s2 && __privateMethod(_a5 = _DrawLayer, _DrawLayer_static, Qo_fn).call(_a5, r2, s2);
      if (n2) {
        const { classList: t3 } = r2;
        for (const [e3, i3] of Object.entries(n2)) t3.toggle(e3, i3);
      }
      if (a2) {
        const t3 = r2.firstChild.firstChild;
        __privateMethod(this, _DrawLayer_instances, tl_fn).call(this, t3, a2);
      }
    }
  }
  updateParent(t2, e2) {
    if (e2 === this) return;
    const i2 = __privateGet(this, _Ko).get(t2);
    if (i2) {
      __privateGet(e2, _fn2).append(i2);
      __privateGet(this, _Ko).delete(t2);
      __privateGet(e2, _Ko).set(t2, i2);
    }
  }
  remove(t2) {
    __privateGet(this, _Yo).delete(t2);
    if (null !== __privateGet(this, _fn2)) {
      __privateGet(this, _Ko).get(t2).remove();
      __privateGet(this, _Ko).delete(t2);
    }
  }
  destroy() {
    __privateSet(this, _fn2, null);
    for (const t2 of __privateGet(this, _Ko).values()) t2.remove();
    __privateGet(this, _Ko).clear();
    __privateGet(this, _Yo).clear();
  }
};
_fn2 = new WeakMap();
_Ko = new WeakMap();
_Yo = new WeakMap();
_y5 = new WeakMap();
_DrawLayer_static = new WeakSet();
Qo_fn = function(t2, [e2, i2, s2, n2]) {
  const { style: a2 } = t2;
  a2.top = 100 * i2 + "%";
  a2.left = 100 * e2 + "%";
  a2.width = 100 * s2 + "%";
  a2.height = 100 * n2 + "%";
};
_DrawLayer_instances = new WeakSet();
Jo_fn = function() {
  const t2 = _DrawLayer._svgFactory.create(1, 1, true);
  __privateGet(this, _fn2).append(t2);
  t2.setAttribute("aria-hidden", true);
  return t2;
};
Zo_fn = function(t2, e2) {
  const i2 = _DrawLayer._svgFactory.createElement("clipPath");
  t2.append(i2);
  const s2 = `clip_${e2}`;
  i2.setAttribute("id", s2);
  i2.setAttribute("clipPathUnits", "objectBoundingBox");
  const n2 = _DrawLayer._svgFactory.createElement("use");
  i2.append(n2);
  n2.setAttribute("href", `#${e2}`);
  n2.classList.add("clip");
  return s2;
};
tl_fn = function(t2, e2) {
  for (const [i2, s2] of Object.entries(e2)) null === s2 ? t2.removeAttribute(i2) : t2.setAttribute(i2, s2);
};
__privateAdd(_DrawLayer, _DrawLayer_static);
__privateAdd(_DrawLayer, _y5, 0);
var DrawLayer = _DrawLayer;
globalThis._pdfjsTestingUtils = { HighlightOutliner };
globalThis.pdfjsLib = { AbortException, AnnotationEditorLayer, AnnotationEditorParamsType: p, AnnotationEditorType: u, AnnotationEditorUIManager, AnnotationLayer, AnnotationMode: c, AnnotationType: x, build: vt, ColorPicker, createValidAbsoluteUrl, DOMSVGFactory, DrawLayer, FeatureTest: util_FeatureTest, fetchData, getDocument, getFilenameFromUrl, getPdfFilenameFromUrl, getUuid, getXfaPageViewport, GlobalWorkerOptions, ImageKind: v, InvalidPDFException, isDataScheme, isPdfFile, isValidExplicitDest: q, MathClamp, noContextMenu, normalizeUnicode, OPS: D, OutputScale, PasswordResponses: F, PDFDataRangeTransport, PDFDateString, PDFWorker, PermissionFlag: g, PixelsPerInch, RenderingCancelledException, ResponseException, setLayerDimensions, shadow, SignatureExtractor, stopEvent, SupportedImageMimeTypes: G, TextLayer, TouchManager, updateUrlHash, Util, VerbosityLevel: M, version: yt, XfaLayer };
export {
  AbortException,
  AnnotationEditorLayer,
  p as AnnotationEditorParamsType,
  u as AnnotationEditorType,
  AnnotationEditorUIManager,
  AnnotationLayer,
  c as AnnotationMode,
  x as AnnotationType,
  ColorPicker,
  DOMSVGFactory,
  DrawLayer,
  util_FeatureTest as FeatureTest,
  GlobalWorkerOptions,
  v as ImageKind,
  InvalidPDFException,
  MathClamp,
  D as OPS,
  OutputScale,
  PDFDataRangeTransport,
  PDFDateString,
  PDFWorker,
  F as PasswordResponses,
  g as PermissionFlag,
  PixelsPerInch,
  RenderingCancelledException,
  ResponseException,
  SignatureExtractor,
  G as SupportedImageMimeTypes,
  TextLayer,
  TouchManager,
  Util,
  M as VerbosityLevel,
  XfaLayer,
  vt as build,
  createValidAbsoluteUrl,
  fetchData,
  getDocument,
  getFilenameFromUrl,
  getPdfFilenameFromUrl,
  getUuid,
  getXfaPageViewport,
  isDataScheme,
  isPdfFile,
  q as isValidExplicitDest,
  noContextMenu,
  normalizeUnicode,
  setLayerDimensions,
  shadow,
  stopEvent,
  updateUrlHash,
  yt as version
};
//# sourceMappingURL=pdfjs-dist_build_pdf__min__mjs.js.map
